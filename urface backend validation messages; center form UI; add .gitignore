[1mdiff --git a/.gitignore b/.gitignore[m
[1mnew file mode 100644[m
[1mindex 0000000..0920645[m
[1m--- /dev/null[m
[1m+++ b/.gitignore[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32m# Python virtual env[m
[32m+[m[32mvenv/[m
[32m+[m[32mECHO is on.[m
[32m+[m[32m# Byte-compiled / cache[m
[32m+[m[32m__pycache__/[m
[32m+[m[32m*.py[cod][m
[32m+[m[32mECHO is on.[m
[32m+[m[32m# VSCode[m
[32m+[m[32m.vscode/[m
[32m+[m[32mECHO is on.[m
[32m+[m[32m# OS files[m
[32m+[m[32m.DS_Store[m
[32m+[m[32mThumbs.db[m
[1mdiff --git a/app.py b/app.py[m
[1mindex 7393fee..15dbbbc 100644[m
[1m--- a/app.py[m
[1m+++ b/app.py[m
[36m@@ -1,7 +1,12 @@[m
[31m-from flask import Flask, request, render_template, redirect, url_for[m
[31m-from twilio.rest import Client[m
[32m+[m[32mfrom flask import Flask, request, render_template, redirect, url_for, jsonify, flash[m
[32m+[m[32mimport requests[m
[32m+[m[32mimport os[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m# from flask import Flask, request, render_template, redirect, url_for, flash[m
[32m+[m[32m# from twilio.rest import Client[m
 # Import necessary modules from Flask and Twilio[m
[31m-from email_validator import validate_email, EmailNotValidError[m
[32m+[m[32m# from email_validator import validate_email, EmailNotValidError[m
 # Import necessary modules from Flask and email_validator[m
 [m
 app = Flask(__name__) # creates flask app instance[m
[36m@@ -56,29 +61,67 @@[m [mdef submit():[m
     birthday = request.form['birthday'] # retrieves the birthday from the form[m
     event = request.form['event'] # retrieves the event from the form[m
     optin = 'optin' in request.form[m
[31m-    # retrieves the opt-in status from the form[m
[31m- [m
[31m-    # # validation[m
 [m
[31m-    # errors = [][m
[31m-    # try:[m
[31m-    #     valid = validate_email(email)  # validates the email format[m
[31m-    #     email = valid.email[m
[32m+[m[32m    api_url = "http://localhost:8080/api/customers" #local testing[m
[32m+[m[32m    # api_url = "https://marketing.brnhome.com/api/customers/"[m
[32m+[m[32m    payload = {[m
[32m+[m[32m        "Name" : request.form['name'], # retrieves the name from the form[m
[32m+[m[32m        "Email" : request.form['email'], # retrieves the email from the form[m
[32m+[m[32m        "PhoneNumber" : request.form['phone'], # retrieves the phone number from the form[m
[32m+[m[32m        "Birthday" : request.form['birthday'], # retrieves the birthday from the form[m
[32m+[m[32m        "Interest" : request.form['event'], # retrieves the event from the form[m
[32m+[m[32m        "AgreeToSms" : 'optin' in request.form[m
[32m+[m[32m    }[m
 [m
[31m-    # if not name or len(name) < 2:[m
[31m-    #     errors.append('Name must be at least 2 characters long.')[m
[32m+[m[32m    try:[m
[32m+[m[32m        response = requests.post(api_url, json=payload, timeout=10)[m
[32m+[m[32m    except requests.exceptions.RequestException as e:[m
[32m+[m[32m        flash("Could not contact backend. Please try again later.", "danger")[m
[32m+[m[32m        return redirect(url_for('customer_form'))[m
 [m
[31m-    [m
[32m+[m[32m    # If backend returned 4xx/5xx, try to extract a friendly message and show it to the user[m
[32m+[m[32m    if response.status_code >= 400:[m
[32m+[m[32m        backend_text = response.text or ""[m
[32m+[m[32m        backend_msg = None[m
[32m+[m
[32m+[m[32m        # If backend returned JSON, try to parse potential message fields[m
[32m+[m[32m        try:[m
[32m+[m[32m            data = response.json()[m
[32m+[m[32m            # common shapes: { "message": "..."} or { "error": "..."} or ModelState dict[m
[32m+[m[32m            backend_msg = data.get("message") or data.get("error") or data.get("detail")[m
[32m+[m[32m            # If ModelState (dictionary), join the errors[m
[32m+[m[32m            if backend_msg is None and isinstance(data, dict):[m
[32m+[m[32m                parts = [][m
[32m+[m[32m                for k, v in data.items():[m
[32m+[m[32m                    if isinstance(v, list):[m
[32m+[m[32m                        parts.extend(v)[m
[32m+[m[32m                    elif isinstance(v, str):[m
[32m+[m[32m                        parts.append(v)[m
[32m+[m[32m                if parts:[m
[32m+[m[32m                    backend_msg = "; ".join(parts)[m
[32m+[m[32m        except Exception:[m
[32m+[m[32m            # not JSON, fallback to raw text[m
[32m+[m[32m            backend_msg = backend_text.strip()[m
[32m+[m
[32m+[m[32m        if not backend_msg:[m
[32m+[m[32m            backend_msg = f"Server returned {response.status_code}"[m
 [m
[31m-    # save the data to a CSV file[m
[31m-    with open('data/customer_data.csv', 'a', encoding='utf-8') as f:[m
[31m-        import csv[m
[31m-        writer = csv.writer(f)[m
[31m-        writer.writerow([name, email, phone, birthday, event, optin])[m
[32m+[m[32m        flash(backend_msg, "danger")[m
[32m+[m[32m        return redirect(url_for('customer_form'))[m
 [m
[31m-    # writes the data to a CSV file[m
[31m-    return redirect(url_for('thank_you')) # redirects to thank you page[m
[32m+[m[32m    # success -> continue[m
[32m+[m[32m    return redirect(url_for('thank_you'))[m
[32m+[m
[32m+[m[32m    # try:[m
[32m+[m[32m    #     response = requests.post(api_url, json=payload)[m
[32m+[m[32m    #     response.raise_for_status()[m
[32m+[m[32m    # except requests.exceptions.RequestException as e:[m
[32m+[m[32m    #     return jsonify({"error": str(e)}), 500[m
[32m+[m
[32m+[m[32m    # return redirect(url_for('thank_you')) # redirects to thank you page[m
     [m
[32m+[m
[32m+[m
 @app.route('/thank-you') # defines the route for the thank you page[m
 def thank_you():[m
     return render_template('thank_you.html') # renders the thank you template[m
[1mdiff --git a/requirements.txt b/requirements.txt[m
[1mnew file mode 100644[m
[1mindex 0000000..67bc8b0[m
[1m--- /dev/null[m
[1m+++ b/requirements.txt[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mFlask[m
[32m+[m[32mtwilio[m
[32m+[m[32memail-validator[m
[32m+[m[32mrequests[m
[32m+[m[32mpython-dotenv[m
[32m+[m[32mphonenumbers[m
[32m+[m
[1mdiff --git a/templates/customer_form.html b/templates/customer_form.html[m
[1mindex f2af931..5a43725 100644[m
[1m--- a/templates/customer_form.html[m
[1m+++ b/templates/customer_form.html[m
[36m@@ -87,52 +87,53 @@[m
 <!-- Bootstrap JS (for modals, dropdowns, etc.) -->[m
 <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>[m
 [m
[31m-[m
 <body>[m
[31m-  <form action="{{ url_for('submit') }}" method="POST">[m
[31m-    <!-- The form action is set to the URL for the submit_form route -->[m
[31m-    <h2>Join Our VIP List</h2>[m
[31m-    [m
[31m-    <label for="name">Name</label>[m
[31m-    <input type="text" name="name" required>[m
[31m-[m
[31m-    <label for="email">Email</label>[m
[31m-    <input type="email" name="email" required>[m
[31m-[m
[31m-    <label for="phone">Phone Number</label>[m
[31m-    <input type="tel" name="phone" required>[m
[31m-[m
[31m-    <label for="birthday">Birthday</label>[m
[31m-    <input type="date" name="birthday">[m
[31m-[m
[31m-[m
[31m-[m
[31m-    <label for="event">Favorite Event Type</label>[m
[31m-    <select name="event">[m
[31m-      <option value="EDM">EDM</option>[m
[31m-      <option value="Hip-Hop">Hip-Hop</option>[m
[31m-      <option value="Karaoke">Karaoke</option>[m
[31m-      <option value="Live Band">Live Band</option>[m
[31m-    </select>[m
[31m-[m
[31m-    <div class="checkbox-container">[m
[31m-      <label for="optin" class="checkbox-label">[m
[31m-        I agree to receive text promotions[m
[31m-      </label>[m
[31m-      <input type="checkbox" id="optin" name="optin" required>[m
[32m+[m[32m  <div class="container min-vh-100 d-flex align-items-center justify-content-center">[m
[32m+[m[32m    <div class="w-100" style="max-width:480px;">[m
[32m+[m[32m      {% with messages = get_flashed_messages(with_categories=true) %}[m
[32m+[m[32m        {% if messages %}[m
[32m+[m[32m          <div id="flashes" class="mb-3">[m
[32m+[m[32m            {% for category, msg in messages %}[m
[32m+[m[32m              <div class="alert alert-{{ category if category else 'info' }} text-center rounded">{{ msg }}</div>[m
[32m+[m[32m            {% endfor %}[m
[32m+[m[32m          </div>[m
[32m+[m[32m        {% endif %}[m
[32m+[m[32m      {% endwith %}[m
[32m+[m
[32m+[m[32m      <form action="{{ url_for('submit') }}" method="POST" class="p-4 shadow-sm rounded bg-white">[m
[32m+[m[32m        <h2 class="mb-4 fw-bold text-primary text-center">Join Our VIP List</h2>[m
[32m+[m
[32m+[m[32m        <label for="name">Name</label>[m
[32m+[m[32m        <input type="text" name="name" required class="form-control">[m
[32m+[m
[32m+[m[32m        <label for="email" class="mt-3">Email</label>[m
[32m+[m[32m        <input type="email" name="email" required class="form-control">[m
[32m+[m
[32m+[m[32m        <label for="phone" class="mt-3">Phone Number</label>[m
[32m+[m[32m        <input type="tel" name="phone" required class="form-control">[m
[32m+[m
[32m+[m[32m        <label for="birthday" class="mt-3">Birthday</label>[m
[32m+[m[32m        <input type="date" name="birthday" class="form-control">[m
[32m+[m
[32m+[m[32m        <label for="event" class="mt-3">Favorite Event Type</label>[m
[32m+[m[32m        <select name="event" class="form-select">[m
[32m+[m[32m          <option value="EDM">EDM</option>[m
[32m+[m[32m          <option value="Hip-Hop">Hip-Hop</option>[m
[32m+[m[32m          <option value="Karaoke">Karaoke</option>[m
[32m+[m[32m          <option value="Live Band">Live Band</option>[m
[32m+[m[32m        </select>[m
[32m+[m
[32m+[m[32m        <div class="form-check form-check-inline mt-3 d-flex align-items-center justify-content-center">[m
[32m+[m[32m          <input class="form-check-input me-2" type="checkbox" id="optin" name="optin" required>[m
[32m+[m[32m          <label class="form-check-label" for="optin">I agree to receive text promotions</label>[m
[32m+[m[32m        </div>[m
[32m+[m
[32m+[m[32m        <button type="submit" class="btn btn-primary btn-lg w-100 mt-4">Join</button>[m
[32m+[m[32m      </form>[m
     </div>[m
[31m-    <!-- Checkbox for opting in to receive text promotions -->[m
[31m-        [m
[31m-[m
[31m-    <button type="submit">Join</button>[m
[31m-  </form>[m
[31m-[m
[31m-  <!-- test button DELETE ME[m
[31m-  <div class="text-center mt-4">[m
[31m-    <button class="btn btn-success" style="width: 200px;">It works!</button> [m
[31m-  </div> -->[m
[31m-[m
[32m+[m[32m  </div>[m
 </body>[m
[32m+[m
 </html>[m
 <!-- This is a simple HTML form for collecting customer information. It includes fields for name, phone number, birthday, and favorite event type. The form also includes a checkbox for opting in to receive text promotions. The form is styled with CSS for a clean and modern look. -->[m
 <!-- The form action is set to "/submit-form" which should be handled by the server-side code to process the form submission. -->[m
\ No newline at end of file[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/INSTALLER b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/INSTALLER[m
[1mdeleted file mode 100644[m
[1mindex a1b589e..0000000[m
[1m--- a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/INSTALLER[m
[1m+++ /dev/null[m
[36m@@ -1 +0,0 @@[m
[31m-pip[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/LICENSE.txt b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/LICENSE.txt[m
[1mdeleted file mode 100644[m
[1mindex 9d227a0..0000000[m
[1m--- a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/LICENSE.txt[m
[1m+++ /dev/null[m
[36m@@ -1,28 +0,0 @@[m
[31m-Copyright 2010 Pallets[m
[31m-[m
[31m-Redistribution and use in source and binary forms, with or without[m
[31m-modification, are permitted provided that the following conditions are[m
[31m-met:[m
[31m-[m
[31m-1.  Redistributions of source code must retain the above copyright[m
[31m-    notice, this list of conditions and the following disclaimer.[m
[31m-[m
[31m-2.  Redistributions in binary form must reproduce the above copyright[m
[31m-    notice, this list of conditions and the following disclaimer in the[m
[31m-    documentation and/or other materials provided with the distribution.[m
[31m-[m
[31m-3.  Neither the name of the copyright holder nor the names of its[m
[31m-    contributors may be used to endorse or promote products derived from[m
[31m-    this software without specific prior written permission.[m
[31m-[m
[31m-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS[m
[31m-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT[m
[31m-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A[m
[31m-PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT[m
[31m-HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,[m
[31m-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED[m
[31m-TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR[m
[31m-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF[m
[31m-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING[m
[31m-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS[m
[31m-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/METADATA b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/METADATA[m
[1mdeleted file mode 100644[m
[1mindex 82261f2..0000000[m
[1m--- a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/METADATA[m
[1m+++ /dev/null[m
[36m@@ -1,92 +0,0 @@[m
[31m-Metadata-Version: 2.1[m
[31m-Name: MarkupSafe[m
[31m-Version: 3.0.2[m
[31m-Summary: Safely add untrusted strings to HTML/XML markup.[m
[31m-Maintainer-email: Pallets <contact@palletsprojects.com>[m
[31m-License: Copyright 2010 Pallets[m
[31m-        [m
[31m-        Redistribution and use in source and binary forms, with or without[m
[31m-        modification, are permitted provided that the following conditions are[m
[31m-        met:[m
[31m-        [m
[31m-        1.  Redistributions of source code must retain the above copyright[m
[31m-            notice, this list of conditions and the following disclaimer.[m
[31m-        [m
[31m-        2.  Redistributions in binary form must reproduce the above copyright[m
[31m-            notice, this list of conditions and the following disclaimer in the[m
[31m-            documentation and/or other materials provided with the distribution.[m
[31m-        [m
[31m-        3.  Neither the name of the copyright holder nor the names of its[m
[31m-            contributors may be used to endorse or promote products derived from[m
[31m-            this software without specific prior written permission.[m
[31m-        [m
[31m-        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS[m
[31m-        "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT[m
[31m-        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A[m
[31m-        PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT[m
[31m-        HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,[m
[31m-        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED[m
[31m-        TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR[m
[31m-        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF[m
[31m-        LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING[m
[31m-        NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS[m
[31m-        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.[m
[31m-        [m
[31m-Project-URL: Donate, https://palletsprojects.com/donate[m
[31m-Project-URL: Documentation, https://markupsafe.palletsprojects.com/[m
[31m-Project-URL: Changes, https://markupsafe.palletsprojects.com/changes/[m
[31m-Project-URL: Source, https://github.com/pallets/markupsafe/[m
[31m-Project-URL: Chat, https://discord.gg/pallets[m
[31m-Classifier: Development Status :: 5 - Production/Stable[m
[31m-Classifier: Environment :: Web Environment[m
[31m-Classifier: Intended Audience :: Developers[m
[31m-Classifier: License :: OSI Approved :: BSD License[m
[31m-Classifier: Operating System :: OS Independent[m
[31m-Classifier: Programming Language :: Python[m
[31m-Classifier: Topic :: Internet :: WWW/HTTP :: Dynamic Content[m
[31m-Classifier: Topic :: Text Processing :: Markup :: HTML[m
[31m-Classifier: Typing :: Typed[m
[31m-Requires-Python: >=3.9[m
[31m-Description-Content-Type: text/markdown[m
[31m-License-File: LICENSE.txt[m
[31m-[m
[31m-# MarkupSafe[m
[31m-[m
[31m-MarkupSafe implements a text object that escapes characters so it is[m
[31m-safe to use in HTML and XML. Characters that have special meanings are[m
[31m-replaced so that they display as the actual characters. This mitigates[m
[31m-injection attacks, meaning untrusted user input can safely be displayed[m
[31m-on a page.[m
[31m-[m
[31m-[m
[31m-## Examples[m
[31m-[m
[31m-```pycon[m
[31m->>> from markupsafe import Markup, escape[m
[31m-[m
[31m->>> # escape replaces special characters and wraps in Markup[m
[31m->>> escape("<script>alert(document.cookie);</script>")[m
[31m-Markup('&lt;script&gt;alert(document.cookie);&lt;/script&gt;')[m
[31m-[m
[31m->>> # wrap in Markup to mark text "safe" and prevent escaping[m
[31m->>> Markup("<strong>Hello</strong>")[m
[31m-Markup('<strong>hello</strong>')[m
[31m-[m
[31m->>> escape(Markup("<strong>Hello</strong>"))[m
[31m-Markup('<strong>hello</strong>')[m
[31m-[m
[31m->>> # Markup is a str subclass[m
[31m->>> # methods and operators escape their arguments[m
[31m->>> template = Markup("Hello <em>{name}</em>")[m
[31m->>> template.format(name='"World"')[m
[31m-Markup('Hello <em>&#34;World&#34;</em>')[m
[31m-```[m
[31m-[m
[31m-## Donate[m
[31m-[m
[31m-The Pallets organization develops and supports MarkupSafe and other[m
[31m-popular packages. In order to grow the community of contributors and[m
[31m-users, and allow the maintainers to devote more time to the projects,[m
[31m-[please donate today][].[m
[31m-[m
[31m-[please donate today]: https://palletsprojects.com/donate[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/RECORD b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/RECORD[m
[1mdeleted file mode 100644[m
[1mindex 26bf81c..0000000[m
[1m--- a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/RECORD[m
[1m+++ /dev/null[m
[36m@@ -1,14 +0,0 @@[m
[31m-MarkupSafe-3.0.2.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4[m
[31m-MarkupSafe-3.0.2.dist-info/LICENSE.txt,sha256=RjHsDbX9kKVH4zaBcmTGeYIUM4FG-KyUtKV_lu6MnsQ,1503[m
[31m-MarkupSafe-3.0.2.dist-info/METADATA,sha256=nhoabjupBG41j_JxPCJ3ylgrZ6Fx8oMCFbiLF9Kafqc,4067[m
[31m-MarkupSafe-3.0.2.dist-info/RECORD,,[m
[31m-MarkupSafe-3.0.2.dist-info/WHEEL,sha256=62QJgqtUFevqILau0n0UncooEMoOyVCKVQitJpcuCig,101[m
[31m-MarkupSafe-3.0.2.dist-info/top_level.txt,sha256=qy0Plje5IJuvsCBjejJyhDCjEAdcDLK_2agVcex8Z6U,11[m
[31m-markupsafe/__init__.py,sha256=pREerPwvinB62tNCMOwqxBS2YHV6R52Wcq1d-rB4Z5o,13609[m
[31m-markupsafe/__pycache__/__init__.cpython-312.pyc,,[m
[31m-markupsafe/__pycache__/_native.cpython-312.pyc,,[m
[31m-markupsafe/_native.py,sha256=2ptkJ40yCcp9kq3L1NqpgjfpZB-obniYKFFKUOkHh4Q,218[m
[31m-markupsafe/_speedups.c,sha256=SglUjn40ti9YgQAO--OgkSyv9tXq9vvaHyVhQows4Ok,4353[m
[31m-markupsafe/_speedups.cp312-win_amd64.pyd,sha256=sC88mCi7HJOQhbSSrdMPZfdCvi_VBfOzwkVuQ7V6T3M,13312[m
[31m-markupsafe/_speedups.pyi,sha256=LSDmXYOefH4HVpAXuL8sl7AttLw0oXh1njVoVZp2wqQ,42[m
[31m-markupsafe/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/WHEEL b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/WHEEL[m
[1mdeleted file mode 100644[m
[1mindex bd4c259..0000000[m
[1m--- a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/WHEEL[m
[1m+++ /dev/null[m
[36m@@ -1,5 +0,0 @@[m
[31m-Wheel-Version: 1.0[m
[31m-Generator: setuptools (75.2.0)[m
[31m-Root-Is-Purelib: false[m
[31m-Tag: cp312-cp312-win_amd64[m
[31m-[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/top_level.txt b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/top_level.txt[m
[1mdeleted file mode 100644[m
[1mindex 75bf729..0000000[m
[1m--- a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/top_level.txt[m
[1m+++ /dev/null[m
[36m@@ -1 +0,0 @@[m
[31m-markupsafe[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/INSTALLER b/venv/Lib/site-packages/blinker-1.9.0.dist-info/INSTALLER[m
[1mdeleted file mode 100644[m
[1mindex a1b589e..0000000[m
[1m--- a/venv/Lib/site-packages/blinker-1.9.0.dist-info/INSTALLER[m
[1m+++ /dev/null[m
[36m@@ -1 +0,0 @@[m
[31m-pip[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/LICENSE.txt b/venv/Lib/site-packages/blinker-1.9.0.dist-info/LICENSE.txt[m
[1mdeleted file mode 100644[m
[1mindex 79c9825..0000000[m
[1m--- a/venv/Lib/site-packages/blinker-1.9.0.dist-info/LICENSE.txt[m
[1m+++ /dev/null[m
[36m@@ -1,20 +0,0 @@[m
[31m-Copyright 2010 Jason Kirtland[m
[31m-[m
[31m-Permission is hereby granted, free of charge, to any person obtaining a[m
[31m-copy of this software and associated documentation files (the[m
[31m-"Software"), to deal in the Software without restriction, including[m
[31m-without limitation the rights to use, copy, modify, merge, publish,[m
[31m-distribute, sublicense, and/or sell copies of the Software, and to[m
[31m-permit persons to whom the Software is furnished to do so, subject to[m
[31m-the following conditions:[m
[31m-[m
[31m-The above copyright notice and this permission notice shall be included[m
[31m-in all copies or substantial portions of the Software.[m
[31m-[m
[31m-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS[m
[31m-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[31m-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.[m
[31m-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY[m
[31m-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,[m
[31m-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE[m
[31m-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/METADATA b/venv/Lib/site-packages/blinker-1.9.0.dist-info/METADATA[m
[1mdeleted file mode 100644[m
[1mindex 6d343f5..0000000[m
[1m--- a/venv/Lib/site-packages/blinker-1.9.0.dist-info/METADATA[m
[1m+++ /dev/null[m
[36m@@ -1,60 +0,0 @@[m
[31m-Metadata-Version: 2.3[m
[31m-Name: blinker[m
[31m-Version: 1.9.0[m
[31m-Summary: Fast, simple object-to-object and broadcast signaling[m
[31m-Author: Jason Kirtland[m
[31m-Maintainer-email: Pallets Ecosystem <contact@palletsprojects.com>[m
[31m-Requires-Python: >=3.9[m
[31m-Description-Content-Type: text/markdown[m
[31m-Classifier: Development Status :: 5 - Production/Stable[m
[31m-Classifier: License :: OSI Approved :: MIT License[m
[31m-Classifier: Programming Language :: Python[m
[31m-Classifier: Typing :: Typed[m
[31m-Project-URL: Chat, https://discord.gg/pallets[m
[31m-Project-URL: Documentation, https://blinker.readthedocs.io[m
[31m-Project-URL: Source, https://github.com/pallets-eco/blinker/[m
[31m-[m
[31m-# Blinker[m
[31m-[m
[31m-Blinker provides a fast dispatching system that allows any number of[m
[31m-interested parties to subscribe to events, or "signals".[m
[31m-[m
[31m-[m
[31m-## Pallets Community Ecosystem[m
[31m-[m
[31m-> [!IMPORTANT]\[m
[31m-> This project is part of the Pallets Community Ecosystem. Pallets is the open[m
[31m-> source organization that maintains Flask; Pallets-Eco enables community[m
[31m-> maintenance of related projects. If you are interested in helping maintain[m
[31m-> this project, please reach out on [the Pallets Discord server][discord].[m
[31m->[m
[31m-> [discord]: https://discord.gg/pallets[m
[31m-[m
[31m-[m
[31m-## Example[m
[31m-[m
[31m-Signal receivers can subscribe to specific senders or receive signals[m
[31m-sent by any sender.[m
[31m-[m
[31m-```pycon[m
[31m->>> from blinker import signal[m
[31m->>> started = signal('round-started')[m
[31m->>> def each(round):[m
[31m-...     print(f"Round {round}")[m
[31m-...[m
[31m->>> started.connect(each)[m
[31m-[m
[31m->>> def round_two(round):[m
[31m-...     print("This is round two.")[m
[31m-...[m
[31m->>> started.connect(round_two, sender=2)[m
[31m-[m
[31m->>> for round in range(1, 4):[m
[31m-...     started.send(round)[m
[31m-...[m
[31m-Round 1![m
[31m-Round 2![m
[31m-This is round two.[m
[31m-Round 3![m
[31m-```[m
[31m-[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/RECORD b/venv/Lib/site-packages/blinker-1.9.0.dist-info/RECORD[m
[1mdeleted file mode 100644[m
[1mindex d4f985b..0000000[m
[1m--- a/venv/Lib/site-packages/blinker-1.9.0.dist-info/RECORD[m
[1m+++ /dev/null[m
[36m@@ -1,12 +0,0 @@[m
[31m-blinker-1.9.0.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4[m
[31m-blinker-1.9.0.dist-info/LICENSE.txt,sha256=nrc6HzhZekqhcCXSrhvjg5Ykx5XphdTw6Xac4p-spGc,1054[m
[31m-blinker-1.9.0.dist-info/METADATA,sha256=uIRiM8wjjbHkCtbCyTvctU37IAZk0kEe5kxAld1dvzA,1633[m
[31m-blinker-1.9.0.dist-info/RECORD,,[m
[31m-blinker-1.9.0.dist-info/WHEEL,sha256=CpUCUxeHQbRN5UGRQHYRJorO5Af-Qy_fHMctcQ8DSGI,82[m
[31m-blinker/__init__.py,sha256=I2EdZqpy4LyjX17Hn1yzJGWCjeLaVaPzsMgHkLfj_cQ,317[m
[31m-blinker/__pycache__/__init__.cpython-312.pyc,,[m
[31m-blinker/__pycache__/_utilities.cpython-312.pyc,,[m
[31m-blinker/__pycache__/base.cpython-312.pyc,,[m
[31m-blinker/_utilities.py,sha256=0J7eeXXTUx0Ivf8asfpx0ycVkp0Eqfqnj117x2mYX9E,1675[m
[31m-blinker/base.py,sha256=QpDuvXXcwJF49lUBcH5BiST46Rz9wSG7VW_p7N_027M,19132[m
[31m-blinker/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/WHEEL b/venv/Lib/site-packages/blinker-1.9.0.dist-info/WHEEL[m
[1mdeleted file mode 100644[m
[1mindex e3c6fee..0000000[m
[1m--- a/venv/Lib/site-packages/blinker-1.9.0.dist-info/WHEEL[m
[1m+++ /dev/null[m
[36m@@ -1,4 +0,0 @@[m
[31m-Wheel-Version: 1.0[m
[31m-Generator: flit 3.10.1[m
[31m-Root-Is-Purelib: true[m
[31m-Tag: py3-none-any[m
[1mdiff --git a/venv/Lib/site-packages/blinker/__init__.py b/venv/Lib/site-packages/blinker/__init__.py[m
[1mdeleted file mode 100644[m
[1mindex 1772fa4..0000000[m
[1m--- a/venv/Lib/site-packages/blinker/__init__.py[m
[1m+++ /dev/null[m
[36m@@ -1,17 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-from .base import ANY[m
[31m-from .base import default_namespace[m
[31m-from .base import NamedSignal[m
[31m-from .base import Namespace[m
[31m-from .base import Signal[m
[31m-from .base import signal[m
[31m-[m
[31m-__all__ = [[m
[31m-    "ANY",[m
[31m-    "default_namespace",[m
[31m-    "NamedSignal",[m
[31m-    "Namespace",[m
[31m-    "Signal",[m
[31m-    "signal",[m
[31m-][m
[1mdiff --git a/venv/Lib/site-packages/blinker/__pycache__/__init__.cpython-312.pyc b/venv/Lib/site-packages/blinker/__pycache__/__init__.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex 0674d06..0000000[m
Binary files a/venv/Lib/site-packages/blinker/__pycache__/__init__.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/blinker/__pycache__/_utilities.cpython-312.pyc b/venv/Lib/site-packages/blinker/__pycache__/_utilities.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex 0e3b16c..0000000[m
Binary files a/venv/Lib/site-packages/blinker/__pycache__/_utilities.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/blinker/__pycache__/base.cpython-312.pyc b/venv/Lib/site-packages/blinker/__pycache__/base.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex de3fd12..0000000[m
Binary files a/venv/Lib/site-packages/blinker/__pycache__/base.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/blinker/_utilities.py b/venv/Lib/site-packages/blinker/_utilities.py[m
[1mdeleted file mode 100644[m
[1mindex 000c902..0000000[m
[1m--- a/venv/Lib/site-packages/blinker/_utilities.py[m
[1m+++ /dev/null[m
[36m@@ -1,64 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as c[m
[31m-import inspect[m
[31m-import typing as t[m
[31m-from weakref import ref[m
[31m-from weakref import WeakMethod[m
[31m-[m
[31m-T = t.TypeVar("T")[m
[31m-[m
[31m-[m
[31m-class Symbol:[m
[31m-    """A constant symbol, nicer than ``object()``. Repeated calls return the[m
[31m-    same instance.[m
[31m-[m
[31m-    >>> Symbol('foo') is Symbol('foo')[m
[31m-    True[m
[31m-    >>> Symbol('foo')[m
[31m-    foo[m
[31m-    """[m
[31m-[m
[31m-    symbols: t.ClassVar[dict[str, Symbol]] = {}[m
[31m-[m
[31m-    def __new__(cls, name: str) -> Symbol:[m
[31m-        if name in cls.symbols:[m
[31m-            return cls.symbols[name][m
[31m-[m
[31m-        obj = super().__new__(cls)[m
[31m-        cls.symbols[name] = obj[m
[31m-        return obj[m
[31m-[m
[31m-    def __init__(self, name: str) -> None:[m
[31m-        self.name = name[m
[31m-[m
[31m-    def __repr__(self) -> str:[m
[31m-        return self.name[m
[31m-[m
[31m-    def __getnewargs__(self) -> tuple[t.Any, ...]:[m
[31m-        return (self.name,)[m
[31m-[m
[31m-[m
[31m-def make_id(obj: object) -> c.Hashable:[m
[31m-    """Get a stable identifier for a receiver or sender, to be used as a dict[m
[31m-    key or in a set.[m
[31m-    """[m
[31m-    if inspect.ismethod(obj):[m
[31m-        # The id of a bound method is not stable, but the id of the unbound[m
[31m-        # function and instance are.[m
[31m-        return id(obj.__func__), id(obj.__self__)[m
[31m-[m
[31m-    if isinstance(obj, (str, int)):[m
[31m-        # Instances with the same value always compare equal and have the same[m
[31m-        # hash, even if the id may change.[m
[31m-        return obj[m
[31m-[m
[31m-    # Assume other types are not hashable but will always be the same instance.[m
[31m-    return id(obj)[m
[31m-[m
[31m-[m
[31m-def make_ref(obj: T, callback: c.Callable[[ref[T]], None] | None = None) -> ref[T]:[m
[31m-    if inspect.ismethod(obj):[m
[31m-        return WeakMethod(obj, callback)  # type: ignore[arg-type, return-value][m
[31m-[m
[31m-    return ref(obj, callback)[m
[1mdiff --git a/venv/Lib/site-packages/blinker/base.py b/venv/Lib/site-packages/blinker/base.py[m
[1mdeleted file mode 100644[m
[1mindex d051b94..0000000[m
[1m--- a/venv/Lib/site-packages/blinker/base.py[m
[1m+++ /dev/null[m
[36m@@ -1,512 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as c[m
[31m-import sys[m
[31m-import typing as t[m
[31m-import weakref[m
[31m-from collections import defaultdict[m
[31m-from contextlib import contextmanager[m
[31m-from functools import cached_property[m
[31m-from inspect import iscoroutinefunction[m
[31m-[m
[31m-from ._utilities import make_id[m
[31m-from ._utilities import make_ref[m
[31m-from ._utilities import Symbol[m
[31m-[m
[31m-F = t.TypeVar("F", bound=c.Callable[..., t.Any])[m
[31m-[m
[31m-ANY = Symbol("ANY")[m
[31m-"""Symbol for "any sender"."""[m
[31m-[m
[31m-ANY_ID = 0[m
[31m-[m
[31m-[m
[31m-class Signal:[m
[31m-    """A notification emitter.[m
[31m-[m
[31m-    :param doc: The docstring for the signal.[m
[31m-    """[m
[31m-[m
[31m-    ANY = ANY[m
[31m-    """An alias for the :data:`~blinker.ANY` sender symbol."""[m
[31m-[m
[31m-    set_class: type[set[t.Any]] = set[m
[31m-    """The set class to use for tracking connected receivers and senders.[m
[31m-    Python's ``set`` is unordered. If receivers must be dispatched in the order[m
[31m-    they were connected, an ordered set implementation can be used.[m
[31m-[m
[31m-    .. versionadded:: 1.7[m
[31m-    """[m
[31m-[m
[31m-    @cached_property[m
[31m-    def receiver_connected(self) -> Signal:[m
[31m-        """Emitted at the end of each :meth:`connect` call.[m
[31m-[m
[31m-        The signal sender is the signal instance, and the :meth:`connect`[m
[31m-        arguments are passed through: ``receiver``, ``sender``, and ``weak``.[m
[31m-[m
[31m-        .. versionadded:: 1.2[m
[31m-        """[m
[31m-        return Signal(doc="Emitted after a receiver connects.")[m
[31m-[m
[31m-    @cached_property[m
[31m-    def receiver_disconnected(self) -> Signal:[m
[31m-        """Emitted at the end of each :meth:`disconnect` call.[m
[31m-[m
[31m-        The sender is the signal instance, and the :meth:`disconnect` arguments[m
[31m-        are passed through: ``receiver`` and ``sender``.[m
[31m-[m
[31m-        This signal is emitted **only** when :meth:`disconnect` is called[m
[31m-        explicitly. This signal cannot be emitted by an automatic disconnect[m
[31m-        when a weakly referenced receiver or sender goes out of scope, as the[m
[31m-        instance is no longer be available to be used as the sender for this[m
[31m-        signal.[m
[31m-[m
[31m-        An alternative approach is available by subscribing to[m
[31m-        :attr:`receiver_connected` and setting up a custom weakref cleanup[m
[31m-        callback on weak receivers and senders.[m
[31m-[m
[31m-        .. versionadded:: 1.2[m
[31m-        """[m
[31m-        return Signal(doc="Emitted after a receiver disconnects.")[m
[31m-[m
[31m-    def __init__(self, doc: str | None = None) -> None:[m
[31m-        if doc:[m
[31m-            self.__doc__ = doc[m
[31m-[m
[31m-        self.receivers: dict[[m
[31m-            t.Any, weakref.ref[c.Callable[..., t.Any]] | c.Callable[..., t.Any][m
[31m-        ] = {}[m
[31m-        """The map of connected receivers. Useful to quickly check if any[m
[31m-        receivers are connected to the signal: ``if s.receivers:``. The[m
[31m-        structure and data is not part of the public API, but checking its[m
[31m-        boolean value is.[m
[31m-        """[m
[31m-[m
[31m-        self.is_muted: bool = False[m
[31m-        self._by_receiver: dict[t.Any, set[t.Any]] = defaultdict(self.set_class)[m
[31m-        self._by_sender: dict[t.Any, set[t.Any]] = defaultdict(self.set_class)[m
[31m-        self._weak_senders: dict[t.Any, weakref.ref[t.Any]] = {}[m
[31m-[m
[31m-    def connect(self, receiver: F, sender: t.Any = ANY, weak: bool = True) -> F:[m
[31m-        """Connect ``receiver`` to be called when the signal is sent by[m
[31m-        ``sender``.[m
[31m-[m
[31m-        :param receiver: The callable to call when :meth:`send` is called with[m
[31m-            the given ``sender``, passing ``sender`` as a positional argument[m
[31m-            along with any extra keyword arguments.[m
[31m-        :param sender: Any object or :data:`ANY`. ``receiver`` will only be[m
[31m-            called when :meth:`send` is called with this sender. If ``ANY``, the[m
[31m-            receiver will be called for any sender. A receiver may be connected[m
[31m-            to multiple senders by calling :meth:`connect` multiple times.[m
[31m-        :param weak: Track the receiver with a :mod:`weakref`. The receiver will[m
[31m-            be automatically disconnected when it is garbage collected. When[m
[31m-            connecting a receiver defined within a function, set to ``False``,[m
[31m-            otherwise it will be disconnected when the function scope ends.[m
[31m-        """[m
[31m-        receiver_id = make_id(receiver)[m
[31m-        sender_id = ANY_ID if sender is ANY else make_id(sender)[m
[31m-[m
[31m-        if weak:[m
[31m-            self.receivers[receiver_id] = make_ref([m
[31m-                receiver, self._make_cleanup_receiver(receiver_id)[m
[31m-            )[m
[31m-        else:[m
[31m-            self.receivers[receiver_id] = receiver[m
[31m-[m
[31m-        self._by_sender[sender_id].add(receiver_id)[m
[31m-        self._by_receiver[receiver_id].add(sender_id)[m
[31m-[m
[31m-        if sender is not ANY and sender_id not in self._weak_senders:[m
[31m-            # store a cleanup for weakref-able senders[m
[31m-            try:[m
[31m-                self._weak_senders[sender_id] = make_ref([m
[31m-                    sender, self._make_cleanup_sender(sender_id)[m
[31m-                )[m
[31m-            except TypeError:[m
[31m-                pass[m
[31m-[m
[31m-        if "receiver_connected" in self.__dict__ and self.receiver_connected.receivers:[m
[31m-            try:[m
[31m-                self.receiver_connected.send([m
[31m-                    self, receiver=receiver, sender=sender, weak=weak[m
[31m-                )[m
[31m-            except TypeError:[m
[31m-                # TODO no explanation or test for this[m
[31m-                self.disconnect(receiver, sender)[m
[31m-                raise[m
[31m-[m
[31m-        return receiver[m
[31m-[m
[31m-    def connect_via(self, sender: t.Any, weak: bool = False) -> c.Callable[[F], F]:[m
[31m-        """Connect the decorated function to be called when the signal is sent[m
[31m-        by ``sender``.[m
[31m-[m
[31m-        The decorated function will be called when :meth:`send` is called with[m
[31m-        the given ``sender``, passing ``sender`` as a positional argument along[m
[31m-        with any extra keyword arguments.[m
[31m-[m
[31m-        :param sender: Any object or :data:`ANY`. ``receiver`` will only be[m
[31m-            called when :meth:`send` is called with this sender. If ``ANY``, the[m
[31m-            receiver will be called for any sender. A receiver may be connected[m
[31m-            to multiple senders by calling :meth:`connect` multiple times.[m
[31m-        :param weak: Track the receiver with a :mod:`weakref`. The receiver will[m
[31m-            be automatically disconnected when it is garbage collected. When[m
[31m-            connecting a receiver defined within a function, set to ``False``,[m
[31m-            otherwise it will be disconnected when the function scope ends.=[m
[31m-[m
[31m-        .. versionadded:: 1.1[m
[31m-        """[m
[31m-[m
[31m-        def decorator(fn: F) -> F:[m
[31m-            self.connect(fn, sender, weak)[m
[31m-            return fn[m
[31m-[m
[31m-        return decorator[m
[31m-[m
[31m-    @contextmanager[m
[31m-    def connected_to([m
[31m-        self, receiver: c.Callable[..., t.Any], sender: t.Any = ANY[m
[31m-    ) -> c.Generator[None, None, None]:[m
[31m-        """A context manager that temporarily connects ``receiver`` to the[m
[31m-        signal while a ``with`` block executes. When the block exits, the[m
[31m-        receiver is disconnected. Useful for tests.[m
[31m-[m
[31m-        :param receiver: The callable to call when :meth:`send` is called with[m
[31m-            the given ``sender``, passing ``sender`` as a positional argument[m
[31m-            along with any extra keyword arguments.[m
[31m-        :param sender: Any object or :data:`ANY`. ``receiver`` will only be[m
[31m-            called when :meth:`send` is called with this sender. If ``ANY``, the[m
[31m-            receiver will be called for any sender.[m
[31m-[m
[31m-        .. versionadded:: 1.1[m
[31m-        """[m
[31m-        self.connect(receiver, sender=sender, weak=False)[m
[31m-[m
[31m-        try:[m
[31m-            yield None[m
[31m-        finally:[m
[31m-            self.disconnect(receiver)[m
[31m-[m
[31m-    @contextmanager[m
[31m-    def muted(self) -> c.Generator[None, None, None]:[m
[31m-        """A context manager that temporarily disables the signal. No receivers[m
[31m-        will be called if the signal is sent, until the ``with`` block exits.[m
[31m-        Useful for tests.[m
[31m-        """[m
[31m-        self.is_muted = True[m
[31m-[m
[31m-        try:[m
[31m-            yield None[m
[31m-        finally:[m
[31m-            self.is_muted = False[m
[31m-[m
[31m-    def send([m
[31m-        self,[m
[31m-        sender: t.Any | None = None,[m
[31m-        /,[m
[31m-        *,[m
[31m-        _async_wrapper: c.Callable[[m
[31m-            [c.Callable[..., c.Coroutine[t.Any, t.Any, t.Any]]], c.Callable[..., t.Any][m
[31m-        ][m
[31m-        | None = None,[m
[31m-        **kwargs: t.Any,[m
[31m-    ) -> list[tuple[c.Callable[..., t.Any], t.Any]]:[m
[31m-        """Call all receivers that are connected to the given ``sender``[m
[31m-        or :data:`ANY`. Each receiver is called with ``sender`` as a positional[m
[31m-        argument along with any extra keyword arguments. Return a list of[m
[31m-        ``(receiver, return value)`` tuples.[m
[31m-[m
[31m-        The order receivers are called is undefined, but can be influenced by[m
[31m-        setting :attr:`set_class`.[m
[31m-[m
[31m-        If a receiver raises an exception, that exception will propagate up.[m
[31m-        This makes debugging straightforward, with an assumption that correctly[m
[31m-        implemented receivers will not raise.[m
[31m-[m
[31m-        :param sender: Call receivers connected to this sender, in addition to[m
[31m-            those connected to :data:`ANY`.[m
[31m-        :param _async_wrapper: Will be called on any receivers that are async[m
[31m-            coroutines to turn them into sync callables. For example, could run[m
[31m-            the receiver with an event loop.[m
[31m-        :param kwargs: Extra keyword arguments to pass to each receiver.[m
[31m-[m
[31m-        .. versionchanged:: 1.7[m
[31m-            Added the ``_async_wrapper`` argument.[m
[31m-        """[m
[31m-        if self.is_muted:[m
[31m-            return [][m
[31m-[m
[31m-        results = [][m
[31m-[m
[31m-        for receiver in self.receivers_for(sender):[m
[31m-            if iscoroutinefunction(receiver):[m
[31m-                if _async_wrapper is None:[m
[31m-                    raise RuntimeError("Cannot send to a coroutine function.")[m
[31m-[m
[31m-                result = _async_wrapper(receiver)(sender, **kwargs)[m
[31m-            else:[m
[31m-                result = receiver(sender, **kwargs)[m
[31m-[m
[31m-            results.append((receiver, result))[m
[31m-[m
[31m-        return results[m
[31m-[m
[31m-    async def send_async([m
[31m-        self,[m
[31m-        sender: t.Any | None = None,[m
[31m-        /,[m
[31m-        *,[m
[31m-        _sync_wrapper: c.Callable[[m
[31m-            [c.Callable[..., t.Any]], c.Callable[..., c.Coroutine[t.Any, t.Any, t.Any]][m
[31m-        ][m
[31m-        | None = None,[m
[31m-        **kwargs: t.Any,[m
[31m-    ) -> list[tuple[c.Callable[..., t.Any], t.Any]]:[m
[31m-        """Await all receivers that are connected to the given ``sender``[m
[31m-        or :data:`ANY`. Each receiver is called with ``sender`` as a positional[m
[31m-        argument along with any extra keyword arguments. Return a list of[m
[31m-        ``(receiver, return value)`` tuples.[m
[31m-[m
[31m-        The order receivers are called is undefined, but can be influenced by[m
[31m-        setting :attr:`set_class`.[m
[31m-[m
[31m-        If a receiver raises an exception, that exception will propagate up.[m
[31m-        This makes debugging straightforward, with an assumption that correctly[m
[31m-        implemented receivers will not raise.[m
[31m-[m
[31m-        :param sender: Call receivers connected to this sender, in addition to[m
[31m-            those connected to :data:`ANY`.[m
[31m-        :param _sync_wrapper: Will be called on any receivers that are sync[m
[31m-            callables to turn them into async coroutines. For example,[m
[31m-            could call the receiver in a thread.[m
[31m-        :param kwargs: Extra keyword arguments to pass to each receiver.[m
[31m-[m
[31m-        .. versionadded:: 1.7[m
[31m-        """[m
[31m-        if self.is_muted:[m
[31m-            return [][m
[31m-[m
[31m-        results = [][m
[31m-[m
[31m-        for receiver in self.receivers_for(sender):[m
[31m-            if not iscoroutinefunction(receiver):[m
[31m-                if _sync_wrapper is None:[m
[31m-                    raise RuntimeError("Cannot send to a non-coroutine function.")[m
[31m-[m
[31m-                result = await _sync_wrapper(receiver)(sender, **kwargs)[m
[31m-            else:[m
[31m-                result = await receiver(sender, **kwargs)[m
[31m-[m
[31m-            results.append((receiver, result))[m
[31m-[m
[31m-        return results[m
[31m-[m
[31m-    def has_receivers_for(self, sender: t.Any) -> bool:[m
[31m-        """Check if there is at least one receiver that will be called with the[m
[31m-        given ``sender``. A receiver connected to :data:`ANY` will always be[m
[31m-        called, regardless of sender. Does not check if weakly referenced[m
[31m-        receivers are still live. See :meth:`receivers_for` for a stronger[m
[31m-        search.[m
[31m-[m
[31m-        :param sender: Check for receivers connected to this sender, in addition[m
[31m-            to those connected to :data:`ANY`.[m
[31m-        """[m
[31m-        if not self.receivers:[m
[31m-            return False[m
[31m-[m
[31m-        if self._by_sender[ANY_ID]:[m
[31m-            return True[m
[31m-[m
[31m-        if sender is ANY:[m
[31m-            return False[m
[31m-[m
[31m-        return make_id(sender) in self._by_sender[m
[31m-[m
[31m-    def receivers_for([m
[31m-        self, sender: t.Any[m
[31m-    ) -> c.Generator[c.Callable[..., t.Any], None, None]:[m
[31m-        """Yield each receiver to be called for ``sender``, in addition to those[m
[31m-        to be called for :data:`ANY`. Weakly referenced receivers that are not[m
[31m-        live will be disconnected and skipped.[m
[31m-[m
[31m-        :param sender: Yield receivers connected to this sender, in addition[m
[31m-            to those connected to :data:`ANY`.[m
[31m-        """[m
[31m-        # TODO: test receivers_for(ANY)[m
[31m-        if not self.receivers:[m
[31m-            return[m
[31m-[m
[31m-        sender_id = make_id(sender)[m
[31m-[m
[31m-        if sender_id in self._by_sender:[m
[31m-            ids = self._by_sender[ANY_ID] | self._by_sender[sender_id][m
[31m-        else:[m
[31m-            ids = self._by_sender[ANY_ID].copy()[m
[31m-[m
[31m-        for receiver_id in ids:[m
[31m-            receiver = self.receivers.get(receiver_id)[m
[31m-[m
[31m-            if receiver is None:[m
[31m-                continue[m
[31m-[m
[31m-            if isinstance(receiver, weakref.ref):[m
[31m-                strong = receiver()[m
[31m-[m
[31m-                if strong is None:[m
[31m-                    self._disconnect(receiver_id, ANY_ID)[m
[31m-                    continue[m
[31m-[m
[31m-                yield strong[m
[31m-            else:[m
[31m-                yield receiver[m
[31m-[m
[31m-    def disconnect(self, receiver: c.Callable[..., t.Any], sender: t.Any = ANY) -> None:[m
[31m-        """Disconnect ``receiver`` from being called when the signal is sent by[m
[31m-        ``sender``.[m
[31m-[m
[31m-        :param receiver: A connected receiver callable.[m
[31m-        :param sender: Disconnect from only this sender. By default, disconnect[m
[31m-            from all senders.[m
[31m-        """[m
[31m-        sender_id: c.Hashable[m
[31m-[m
[31m-        if sender is ANY:[m
[31m-            sender_id = ANY_ID[m
[31m-        else:[m
[31m-            sender_id = make_id(sender)[m
[31m-[m
[31m-        receiver_id = make_id(receiver)[m
[31m-        self._disconnect(receiver_id, sender_id)[m
[31m-[m
[31m-        if ([m
[31m-            "receiver_disconnected" in self.__dict__[m
[31m-            and self.receiver_disconnected.receivers[m
[31m-        ):[m
[31m-            self.receiver_disconnected.send(self, receiver=receiver, sender=sender)[m
[31m-[m
[31m-    def _disconnect(self, receiver_id: c.Hashable, sender_id: c.Hashable) -> None:[m
[31m-        if sender_id == ANY_ID:[m
[31m-            if self._by_receiver.pop(receiver_id, None) is not None:[m
[31m-                for bucket in self._by_sender.values():[m
[31m-                    bucket.discard(receiver_id)[m
[31m-[m
[31m-            self.receivers.pop(receiver_id, None)[m
[31m-        else:[m
[31m-            self._by_sender[sender_id].discard(receiver_id)[m
[31m-            self._by_receiver[receiver_id].discard(sender_id)[m
[31m-[m
[31m-    def _make_cleanup_receiver([m
[31m-        self, receiver_id: c.Hashable[m
[31m-    ) -> c.Callable[[weakref.ref[c.Callable[..., t.Any]]], None]:[m
[31m-        """Create a callback function to disconnect a weakly referenced[m
[31m-        receiver when it is garbage collected.[m
[31m-        """[m
[31m-[m
[31m-        def cleanup(ref: weakref.ref[c.Callable[..., t.Any]]) -> None:[m
[31m-            # If the interpreter is shutting down, disconnecting can result in a[m
[31m-            # weird ignored exception. Don't call it in that case.[m
[31m-            if not sys.is_finalizing():[m
[31m-                self._disconnect(receiver_id, ANY_ID)[m
[31m-[m
[31m-        return cleanup[m
[31m-[m
[31m-    def _make_cleanup_sender([m
[31m-        self, sender_id: c.Hashable[m
[31m-    ) -> c.Callable[[weakref.ref[t.Any]], None]:[m
[31m-        """Create a callback function to disconnect all receivers for a weakly[m
[31m-        referenced sender when it is garbage collected.[m
[31m-        """[m
[31m-        assert sender_id != ANY_ID[m
[31m-[m
[31m-        def cleanup(ref: weakref.ref[t.Any]) -> None:[m
[31m-            self._weak_senders.pop(sender_id, None)[m
[31m-[m
[31m-            for receiver_id in self._by_sender.pop(sender_id, ()):[m
[31m-                self._by_receiver[receiver_id].discard(sender_id)[m
[31m-[m
[31m-        return cleanup[m
[31m-[m
[31m-    def _cleanup_bookkeeping(self) -> None:[m
[31m-        """Prune unused sender/receiver bookkeeping. Not threadsafe.[m
[31m-[m
[31m-        Connecting & disconnecting leaves behind a small amount of bookkeeping[m
[31m-        data. Typical workloads using Blinker, for example in most web apps,[m
[31m-        Flask, CLI scripts, etc., are not adversely affected by this[m
[31m-        bookkeeping.[m
[31m-[m
[31m-        With a long-running process performing dynamic signal routing with high[m
[31m-        volume, e.g. connecting to function closures, senders are all unique[m
[31m-        object instances. Doing all of this over and over may cause memory usage[m
[31m-        to grow due to extraneous bookkeeping. (An empty ``set`` for each stale[m
[31m-        sender/receiver pair.)[m
[31m-[m
[31m-        This method will prune that bookkeeping away, with the caveat that such[m
[31m-        pruning is not threadsafe. The risk is that cleanup of a fully[m
[31m-        disconnected receiver/sender pair occurs while another thread is[m
[31m-        connecting that same pair. If you are in the highly dynamic, unique[m
[31m-        receiver/sender situation that has lead you to this method, that failure[m
[31m-        mode is perhaps not a big deal for you.[m
[31m-        """[m
[31m-        for mapping in (self._by_sender, self._by_receiver):[m
[31m-            for ident, bucket in list(mapping.items()):[m
[31m-                if not bucket:[m
[31m-                    mapping.pop(ident, None)[m
[31m-[m
[31m-    def _clear_state(self) -> None:[m
[31m-        """Disconnect all receivers and senders. Useful for tests."""[m
[31m-        self._weak_senders.clear()[m
[31m-        self.receivers.clear()[m
[31m-        self._by_sender.clear()[m
[31m-        self._by_receiver.clear()[m
[31m-[m
[31m-[m
[31m-class NamedSignal(Signal):[m
[31m-    """A named generic notification emitter. The name is not used by the signal[m
[31m-    itself, but matches the key in the :class:`Namespace` that it belongs to.[m
[31m-[m
[31m-    :param name: The name of the signal within the namespace.[m
[31m-    :param doc: The docstring for the signal.[m
[31m-    """[m
[31m-[m
[31m-    def __init__(self, name: str, doc: str | None = None) -> None:[m
[31m-        super().__init__(doc)[m
[31m-[m
[31m-        #: The name of this signal.[m
[31m-        self.name: str = name[m
[31m-[m
[31m-    def __repr__(self) -> str:[m
[31m-        base = super().__repr__()[m
[31m-        return f"{base[:-1]}; {self.name!r}>"  # noqa: E702[m
[31m-[m
[31m-[m
[31m-class Namespace(dict[str, NamedSignal]):[m
[31m-    """A dict mapping names to signals."""[m
[31m-[m
[31m-    def signal(self, name: str, doc: str | None = None) -> NamedSignal:[m
[31m-        """Return the :class:`NamedSignal` for the given ``name``, creating it[m
[31m-        if required. Repeated calls with the same name return the same signal.[m
[31m-[m
[31m-        :param name: The name of the signal.[m
[31m-        :param doc: The docstring of the signal.[m
[31m-        """[m
[31m-        if name not in self:[m
[31m-            self[name] = NamedSignal(name, doc)[m
[31m-[m
[31m-        return self[name][m
[31m-[m
[31m-[m
[31m-class _PNamespaceSignal(t.Protocol):[m
[31m-    def __call__(self, name: str, doc: str | None = None) -> NamedSignal: ...[m
[31m-[m
[31m-[m
[31m-default_namespace: Namespace = Namespace()[m
[31m-"""A default :class:`Namespace` for creating named signals. :func:`signal`[m
[31m-creates a :class:`NamedSignal` in this namespace.[m
[31m-"""[m
[31m-[m
[31m-signal: _PNamespaceSignal = default_namespace.signal[m
[31m-"""Return a :class:`NamedSignal` in :data:`default_namespace` with the given[m
[31m-``name``, creating it if required. Repeated calls with the same name return the[m
[31m-same signal.[m
[31m-"""[m
[1mdiff --git a/venv/Lib/site-packages/blinker/py.typed b/venv/Lib/site-packages/blinker/py.typed[m
[1mdeleted file mode 100644[m
[1mindex e69de29..0000000[m
[1mdiff --git a/venv/Lib/site-packages/click-8.2.0.dist-info/INSTALLER b/venv/Lib/site-packages/click-8.2.0.dist-info/INSTALLER[m
[1mdeleted file mode 100644[m
[1mindex a1b589e..0000000[m
[1m--- a/venv/Lib/site-packages/click-8.2.0.dist-info/INSTALLER[m
[1m+++ /dev/null[m
[36m@@ -1 +0,0 @@[m
[31m-pip[m
[1mdiff --git a/venv/Lib/site-packages/click-8.2.0.dist-info/METADATA b/venv/Lib/site-packages/click-8.2.0.dist-info/METADATA[m
[1mdeleted file mode 100644[m
[1mindex 37ae330..0000000[m
[1m--- a/venv/Lib/site-packages/click-8.2.0.dist-info/METADATA[m
[1m+++ /dev/null[m
[36m@@ -1,82 +0,0 @@[m
[31m-Metadata-Version: 2.4[m
[31m-Name: click[m
[31m-Version: 8.2.0[m
[31m-Summary: Composable command line interface toolkit[m
[31m-Maintainer-email: Pallets <contact@palletsprojects.com>[m
[31m-Requires-Python: >=3.10[m
[31m-Description-Content-Type: text/markdown[m
[31m-License-Expression: BSD-3-Clause[m
[31m-Classifier: Development Status :: 5 - Production/Stable[m
[31m-Classifier: Intended Audience :: Developers[m
[31m-Classifier: Operating System :: OS Independent[m
[31m-Classifier: Programming Language :: Python[m
[31m-Classifier: Typing :: Typed[m
[31m-License-File: LICENSE.txt[m
[31m-Requires-Dist: colorama; platform_system == 'Windows'[m
[31m-Project-URL: Changes, https://click.palletsprojects.com/changes/[m
[31m-Project-URL: Chat, https://discord.gg/pallets[m
[31m-Project-URL: Documentation, https://click.palletsprojects.com/[m
[31m-Project-URL: Donate, https://palletsprojects.com/donate[m
[31m-Project-URL: Source, https://github.com/pallets/click/[m
[31m-[m
[31m-# $ click_[m
[31m-[m
[31m-Click is a Python package for creating beautiful command line interfaces[m
[31m-in a composable way with as little code as necessary. It's the "Command[m
[31m-Line Interface Creation Kit". It's highly configurable but comes with[m
[31m-sensible defaults out of the box.[m
[31m-[m
[31m-It aims to make the process of writing command line tools quick and fun[m
[31m-while also preventing any frustration caused by the inability to[m
[31m-implement an intended CLI API.[m
[31m-[m
[31m-Click in three points:[m
[31m-[m
[31m--   Arbitrary nesting of commands[m
[31m--   Automatic help page generation[m
[31m--   Supports lazy loading of subcommands at runtime[m
[31m-[m
[31m-[m
[31m-## A Simple Example[m
[31m-[m
[31m-```python[m
[31m-import click[m
[31m-[m
[31m-@click.command()[m
[31m-@click.option("--count", default=1, help="Number of greetings.")[m
[31m-@click.option("--name", prompt="Your name", help="The person to greet.")[m
[31m-def hello(count, name):[m
[31m-    """Simple program that greets NAME for a total of COUNT times."""[m
[31m-    for _ in range(count):[m
[31m-        click.echo(f"Hello, {name}!")[m
[31m-[m
[31m-if __name__ == '__main__':[m
[31m-    hello()[m
[31m-```[m
[31m-[m
[31m-```[m
[31m-$ python hello.py --count=3[m
[31m-Your name: Click[m
[31m-Hello, Click![m
[31m-Hello, Click![m
[31m-Hello, Click![m
[31m-```[m
[31m-[m
[31m-[m
[31m-## Donate[m
[31m-[m
[31m-The Pallets organization develops and supports Click and other popular[m
[31m-packages. In order to grow the community of contributors and users, and[m
[31m-allow the maintainers to devote more time to the projects, [please[m
[31m-donate today][].[m
[31m-[m
[31m-[please donate today]: https://palletsprojects.com/donate[m
[31m-[m
[31m-## Contributing[m
[31m-[m
[31m-See our [detailed contributing documentation][contrib] for many ways to[m
[31m-contribute, including reporting issues, requesting features, asking or answering[m
[31m-questions, and making PRs.[m
[31m-[m
[31m-[contrib]: https://palletsprojects.com/contributing/[m
[31m-[m
[1mdiff --git a/venv/Lib/site-packages/click-8.2.0.dist-info/RECORD b/venv/Lib/site-packages/click-8.2.0.dist-info/RECORD[m
[1mdeleted file mode 100644[m
[1mindex 7f9a267..0000000[m
[1m--- a/venv/Lib/site-packages/click-8.2.0.dist-info/RECORD[m
[1m+++ /dev/null[m
[36m@@ -1,38 +0,0 @@[m
[31m-click-8.2.0.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4[m
[31m-click-8.2.0.dist-info/METADATA,sha256=b1wO_9Blfi0EN6Dvjb6YKj6xj7jthLcEgTADVm3qiUc,2466[m
[31m-click-8.2.0.dist-info/RECORD,,[m
[31m-click-8.2.0.dist-info/WHEEL,sha256=G2gURzTEtmeR8nrdXUJfNiB3VYVxigPQ-bEQujpNiNs,82[m
[31m-click-8.2.0.dist-info/licenses/LICENSE.txt,sha256=morRBqOU6FO_4h9C9OctWSgZoigF2ZG18ydQKSkrZY0,1475[m
[31m-click/__init__.py,sha256=6YyS1aeyknZ0LYweWozNZy0A9nZ_11wmYIhv3cbQrYo,4473[m
[31m-click/__pycache__/__init__.cpython-312.pyc,,[m
[31m-click/__pycache__/_compat.cpython-312.pyc,,[m
[31m-click/__pycache__/_termui_impl.cpython-312.pyc,,[m
[31m-click/__pycache__/_textwrap.cpython-312.pyc,,[m
[31m-click/__pycache__/_winconsole.cpython-312.pyc,,[m
[31m-click/__pycache__/core.cpython-312.pyc,,[m
[31m-click/__pycache__/decorators.cpython-312.pyc,,[m
[31m-click/__pycache__/exceptions.cpython-312.pyc,,[m
[31m-click/__pycache__/formatting.cpython-312.pyc,,[m
[31m-click/__pycache__/globals.cpython-312.pyc,,[m
[31m-click/__pycache__/parser.cpython-312.pyc,,[m
[31m-click/__pycache__/shell_completion.cpython-312.pyc,,[m
[31m-click/__pycache__/termui.cpython-312.pyc,,[m
[31m-click/__pycache__/testing.cpython-312.pyc,,[m
[31m-click/__pycache__/types.cpython-312.pyc,,[m
[31m-click/__pycache__/utils.cpython-312.pyc,,[m
[31m-click/_compat.py,sha256=v3xBZkFbvA1BXPRkFfBJc6-pIwPI7345m-kQEnpVAs4,18693[m
[31m-click/_termui_impl.py,sha256=ASXhLi9IQIc0Js9KQSS-3-SLZcPet3VqysBf9WgbbpI,26712[m
[31m-click/_textwrap.py,sha256=BOae0RQ6vg3FkNgSJyOoGzG1meGMxJ_ukWVZKx_v-0o,1400[m
[31m-click/_winconsole.py,sha256=6hzKWpPTXRv-v9SuH3-SwBpuMl3W9Dgox5QHPJFc7e4,8488[m
[31m-click/core.py,sha256=yI_kKz2ewr2hFHnovdXUXZ5lFr88vFUkShCo7qrHLZo,117338[m
[31m-click/decorators.py,sha256=5P7abhJtAQYp_KHgjUvhMv464ERwOzrv2enNknlwHyQ,18461[m
[31m-click/exceptions.py,sha256=1rdtXgHJ1b3OjGkN-UpXB9t_HCBihJvh_DtpmLmwn9s,9891[m
[31m-click/formatting.py,sha256=Bhqx4QXdKQ9W4WKknIwj5KPKFmtduGOuGq1yw_THLZ8,9726[m
[31m-click/globals.py,sha256=gM-Nh6A4M0HB_SgkaF5M4ncGGMDHc_flHXu9_oh4GEU,1923[m
[31m-click/parser.py,sha256=nU1Ah2p11q29ul1vNdU9swPo_PUuKrxU6YXToi71q1c,18979[m
[31m-click/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0[m
[31m-click/shell_completion.py,sha256=-WBu9SXYo85hNdO1syMu4OgY1gA9F_yhY0iE9eSogMs,19857[m
[31m-click/termui.py,sha256=vAYrKC2a7f_NfEIhAThEVYfa__ib5XQbTSCGtJlABRA,30847[m
[31m-click/testing.py,sha256=dqC7F_EYJ-z84bcIVF5NTN5fP3dAuF7dq6hYace6PcQ,18487[m
[31m-click/types.py,sha256=KBTRxN28cR1VZ5mb9iJX98MQSw_p9SGzljqfEI8z5Tw,38389[m
[31m-click/utils.py,sha256=b1Mm-usEDBHtEwcPltPIn3zSK4nw2KTp5GC7_oSTlLo,20245[m
[1mdiff --git a/venv/Lib/site-packages/click-8.2.0.dist-info/WHEEL b/venv/Lib/site-packages/click-8.2.0.dist-info/WHEEL[m
[1mdeleted file mode 100644[m
[1mindex d8b9936..0000000[m
[1m--- a/venv/Lib/site-packages/click-8.2.0.dist-info/WHEEL[m
[1m+++ /dev/null[m
[36m@@ -1,4 +0,0 @@[m
[31m-Wheel-Version: 1.0[m
[31m-Generator: flit 3.12.0[m
[31m-Root-Is-Purelib: true[m
[31m-Tag: py3-none-any[m
[1mdiff --git a/venv/Lib/site-packages/click-8.2.0.dist-info/licenses/LICENSE.txt b/venv/Lib/site-packages/click-8.2.0.dist-info/licenses/LICENSE.txt[m
[1mdeleted file mode 100644[m
[1mindex d12a849..0000000[m
[1m--- a/venv/Lib/site-packages/click-8.2.0.dist-info/licenses/LICENSE.txt[m
[1m+++ /dev/null[m
[36m@@ -1,28 +0,0 @@[m
[31m-Copyright 2014 Pallets[m
[31m-[m
[31m-Redistribution and use in source and binary forms, with or without[m
[31m-modification, are permitted provided that the following conditions are[m
[31m-met:[m
[31m-[m
[31m-1.  Redistributions of source code must retain the above copyright[m
[31m-    notice, this list of conditions and the following disclaimer.[m
[31m-[m
[31m-2.  Redistributions in binary form must reproduce the above copyright[m
[31m-    notice, this list of conditions and the following disclaimer in the[m
[31m-    documentation and/or other materials provided with the distribution.[m
[31m-[m
[31m-3.  Neither the name of the copyright holder nor the names of its[m
[31m-    contributors may be used to endorse or promote products derived from[m
[31m-    this software without specific prior written permission.[m
[31m-[m
[31m-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS[m
[31m-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT[m
[31m-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A[m
[31m-PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT[m
[31m-HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,[m
[31m-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED[m
[31m-TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR[m
[31m-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF[m
[31m-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING[m
[31m-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS[m
[31m-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.[m
[1mdiff --git a/venv/Lib/site-packages/click/__init__.py b/venv/Lib/site-packages/click/__init__.py[m
[1mdeleted file mode 100644[m
[1mindex 1aa547c..0000000[m
[1m--- a/venv/Lib/site-packages/click/__init__.py[m
[1m+++ /dev/null[m
[36m@@ -1,123 +0,0 @@[m
[31m-"""[m
[31m-Click is a simple Python module inspired by the stdlib optparse to make[m
[31m-writing command line scripts fun. Unlike other modules, it's based[m
[31m-around a simple API that does not come with too much magic and is[m
[31m-composable.[m
[31m-"""[m
[31m-[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-from .core import Argument as Argument[m
[31m-from .core import Command as Command[m
[31m-from .core import CommandCollection as CommandCollection[m
[31m-from .core import Context as Context[m
[31m-from .core import Group as Group[m
[31m-from .core import Option as Option[m
[31m-from .core import Parameter as Parameter[m
[31m-from .decorators import argument as argument[m
[31m-from .decorators import command as command[m
[31m-from .decorators import confirmation_option as confirmation_option[m
[31m-from .decorators import group as group[m
[31m-from .decorators import help_option as help_option[m
[31m-from .decorators import make_pass_decorator as make_pass_decorator[m
[31m-from .decorators import option as option[m
[31m-from .decorators import pass_context as pass_context[m
[31m-from .decorators import pass_obj as pass_obj[m
[31m-from .decorators import password_option as password_option[m
[31m-from .decorators import version_option as version_option[m
[31m-from .exceptions import Abort as Abort[m
[31m-from .exceptions import BadArgumentUsage as BadArgumentUsage[m
[31m-from .exceptions import BadOptionUsage as BadOptionUsage[m
[31m-from .exceptions import BadParameter as BadParameter[m
[31m-from .exceptions import ClickException as ClickException[m
[31m-from .exceptions import FileError as FileError[m
[31m-from .exceptions import MissingParameter as MissingParameter[m
[31m-from .exceptions import NoSuchOption as NoSuchOption[m
[31m-from .exceptions import UsageError as UsageError[m
[31m-from .formatting import HelpFormatter as HelpFormatter[m
[31m-from .formatting import wrap_text as wrap_text[m
[31m-from .globals import get_current_context as get_current_context[m
[31m-from .termui import clear as clear[m
[31m-from .termui import confirm as confirm[m
[31m-from .termui import echo_via_pager as echo_via_pager[m
[31m-from .termui import edit as edit[m
[31m-from .termui import getchar as getchar[m
[31m-from .termui import launch as launch[m
[31m-from .termui import pause as pause[m
[31m-from .termui import progressbar as progressbar[m
[31m-from .termui import prompt as prompt[m
[31m-from .termui import secho as secho[m
[31m-from .termui import style as style[m
[31m-from .termui import unstyle as unstyle[m
[31m-from .types import BOOL as BOOL[m
[31m-from .types import Choice as Choice[m
[31m-from .types import DateTime as DateTime[m
[31m-from .types import File as File[m
[31m-from .types import FLOAT as FLOAT[m
[31m-from .types import FloatRange as FloatRange[m
[31m-from .types import INT as INT[m
[31m-from .types import IntRange as IntRange[m
[31m-from .types import ParamType as ParamType[m
[31m-from .types import Path as Path[m
[31m-from .types import STRING as STRING[m
[31m-from .types import Tuple as Tuple[m
[31m-from .types import UNPROCESSED as UNPROCESSED[m
[31m-from .types import UUID as UUID[m
[31m-from .utils import echo as echo[m
[31m-from .utils import format_filename as format_filename[m
[31m-from .utils import get_app_dir as get_app_dir[m
[31m-from .utils import get_binary_stream as get_binary_stream[m
[31m-from .utils import get_text_stream as get_text_stream[m
[31m-from .utils import open_file as open_file[m
[31m-[m
[31m-[m
[31m-def __getattr__(name: str) -> object:[m
[31m-    import warnings[m
[31m-[m
[31m-    if name == "BaseCommand":[m
[31m-        from .core import _BaseCommand[m
[31m-[m
[31m-        warnings.warn([m
[31m-            "'BaseCommand' is deprecated and will be removed in Click 9.0. Use"[m
[31m-            " 'Command' instead.",[m
[31m-            DeprecationWarning,[m
[31m-            stacklevel=2,[m
[31m-        )[m
[31m-        return _BaseCommand[m
[31m-[m
[31m-    if name == "MultiCommand":[m
[31m-        from .core import _MultiCommand[m
[31m-[m
[31m-        warnings.warn([m
[31m-            "'MultiCommand' is deprecated and will be removed in Click 9.0. Use"[m
[31m-            " 'Group' instead.",[m
[31m-            DeprecationWarning,[m
[31m-            stacklevel=2,[m
[31m-        )[m
[31m-        return _MultiCommand[m
[31m-[m
[31m-    if name == "OptionParser":[m
[31m-        from .parser import _OptionParser[m
[31m-[m
[31m-        warnings.warn([m
[31m-            "'OptionParser' is deprecated and will be removed in Click 9.0. The"[m
[31m-            " old parser is available in 'optparse'.",[m
[31m-            DeprecationWarning,[m
[31m-            stacklevel=2,[m
[31m-        )[m
[31m-        return _OptionParser[m
[31m-[m
[31m-    if name == "__version__":[m
[31m-        import importlib.metadata[m
[31m-        import warnings[m
[31m-[m
[31m-        warnings.warn([m
[31m-            "The '__version__' attribute is deprecated and will be removed in"[m
[31m-            " Click 9.1. Use feature detection or"[m
[31m-            " 'importlib.metadata.version(\"click\")' instead.",[m
[31m-            DeprecationWarning,[m
[31m-            stacklevel=2,[m
[31m-        )[m
[31m-        return importlib.metadata.version("click")[m
[31m-[m
[31m-    raise AttributeError(name)[m
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/__init__.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/__init__.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex c2c0508..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/__init__.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/_compat.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/_compat.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex b085eda..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/_compat.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/_termui_impl.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/_termui_impl.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex 7d7214f..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/_termui_impl.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/_textwrap.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/_textwrap.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex 67de568..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/_textwrap.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/_winconsole.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/_winconsole.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex 5353766..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/_winconsole.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/core.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/core.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex 576be1b..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/core.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/decorators.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/decorators.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex c3cfb53..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/decorators.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/exceptions.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/exceptions.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex ed311f2..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/exceptions.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/formatting.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/formatting.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex 6de8e8a..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/formatting.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/globals.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/globals.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex bd9c23d..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/globals.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/parser.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/parser.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex f769e5c..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/parser.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/shell_completion.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/shell_completion.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex 3bf861e..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/shell_completion.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/termui.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/termui.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex a5eacd7..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/termui.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/testing.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/testing.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex de66f42..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/testing.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/types.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/types.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex d938c20..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/types.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/__pycache__/utils.cpython-312.pyc b/venv/Lib/site-packages/click/__pycache__/utils.cpython-312.pyc[m
[1mdeleted file mode 100644[m
[1mindex 6d3294f..0000000[m
Binary files a/venv/Lib/site-packages/click/__pycache__/utils.cpython-312.pyc and /dev/null differ
[1mdiff --git a/venv/Lib/site-packages/click/_compat.py b/venv/Lib/site-packages/click/_compat.py[m
[1mdeleted file mode 100644[m
[1mindex f2726b9..0000000[m
[1m--- a/venv/Lib/site-packages/click/_compat.py[m
[1m+++ /dev/null[m
[36m@@ -1,622 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import codecs[m
[31m-import collections.abc as cabc[m
[31m-import io[m
[31m-import os[m
[31m-import re[m
[31m-import sys[m
[31m-import typing as t[m
[31m-from types import TracebackType[m
[31m-from weakref import WeakKeyDictionary[m
[31m-[m
[31m-CYGWIN = sys.platform.startswith("cygwin")[m
[31m-WIN = sys.platform.startswith("win")[m
[31m-auto_wrap_for_ansi: t.Callable[[t.TextIO], t.TextIO] | None = None[m
[31m-_ansi_re = re.compile(r"\033\[[;?0-9]*[a-zA-Z]")[m
[31m-[m
[31m-[m
[31m-def _make_text_stream([m
[31m-    stream: t.BinaryIO,[m
[31m-    encoding: str | None,[m
[31m-    errors: str | None,[m
[31m-    force_readable: bool = False,[m
[31m-    force_writable: bool = False,[m
[31m-) -> t.TextIO:[m
[31m-    if encoding is None:[m
[31m-        encoding = get_best_encoding(stream)[m
[31m-    if errors is None:[m
[31m-        errors = "replace"[m
[31m-    return _NonClosingTextIOWrapper([m
[31m-        stream,[m
[31m-        encoding,[m
[31m-        errors,[m
[31m-        line_buffering=True,[m
[31m-        force_readable=force_readable,[m
[31m-        force_writable=force_writable,[m
[31m-    )[m
[31m-[m
[31m-[m
[31m-def is_ascii_encoding(encoding: str) -> bool:[m
[31m-    """Checks if a given encoding is ascii."""[m
[31m-    try:[m
[31m-        return codecs.lookup(encoding).name == "ascii"[m
[31m-    except LookupError:[m
[31m-        return False[m
[31m-[m
[31m-[m
[31m-def get_best_encoding(stream: t.IO[t.Any]) -> str:[m
[31m-    """Returns the default stream encoding if not found."""[m
[31m-    rv = getattr(stream, "encoding", None) or sys.getdefaultencoding()[m
[31m-    if is_ascii_encoding(rv):[m
[31m-        return "utf-8"[m
[31m-    return rv[m
[31m-[m
[31m-[m
[31m-class _NonClosingTextIOWrapper(io.TextIOWrapper):[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        stream: t.BinaryIO,[m
[31m-        encoding: str | None,[m
[31m-        errors: str | None,[m
[31m-        force_readable: bool = False,[m
[31m-        force_writable: bool = False,[m
[31m-        **extra: t.Any,[m
[31m-    ) -> None:[m
[31m-        self._stream = stream = t.cast([m
[31m-            t.BinaryIO, _FixupStream(stream, force_readable, force_writable)[m
[31m-        )[m
[31m-        super().__init__(stream, encoding, errors, **extra)[m
[31m-[m
[31m-    def __del__(self) -> None:[m
[31m-        try:[m
[31m-            self.detach()[m
[31m-        except Exception:[m
[31m-            pass[m
[31m-[m
[31m-    def isatty(self) -> bool:[m
[31m-        # https://bitbucket.org/pypy/pypy/issue/1803[m
[31m-        return self._stream.isatty()[m
[31m-[m
[31m-[m
[31m-class _FixupStream:[m
[31m-    """The new io interface needs more from streams than streams[m
[31m-    traditionally implement.  As such, this fix-up code is necessary in[m
[31m-    some circumstances.[m
[31m-[m
[31m-    The forcing of readable and writable flags are there because some tools[m
[31m-    put badly patched objects on sys (one such offender are certain version[m
[31m-    of jupyter notebook).[m
[31m-    """[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        stream: t.BinaryIO,[m
[31m-        force_readable: bool = False,[m
[31m-        force_writable: bool = False,[m
[31m-    ):[m
[31m-        self._stream = stream[m
[31m-        self._force_readable = force_readable[m
[31m-        self._force_writable = force_writable[m
[31m-[m
[31m-    def __getattr__(self, name: str) -> t.Any:[m
[31m-        return getattr(self._stream, name)[m
[31m-[m
[31m-    def read1(self, size: int) -> bytes:[m
[31m-        f = getattr(self._stream, "read1", None)[m
[31m-[m
[31m-        if f is not None:[m
[31m-            return t.cast(bytes, f(size))[m
[31m-[m
[31m-        return self._stream.read(size)[m
[31m-[m
[31m-    def readable(self) -> bool:[m
[31m-        if self._force_readable:[m
[31m-            return True[m
[31m-        x = getattr(self._stream, "readable", None)[m
[31m-        if x is not None:[m
[31m-            return t.cast(bool, x())[m
[31m-        try:[m
[31m-            self._stream.read(0)[m
[31m-        except Exception:[m
[31m-            return False[m
[31m-        return True[m
[31m-[m
[31m-    def writable(self) -> bool:[m
[31m-        if self._force_writable:[m
[31m-            return True[m
[31m-        x = getattr(self._stream, "writable", None)[m
[31m-        if x is not None:[m
[31m-            return t.cast(bool, x())[m
[31m-        try:[m
[31m-            self._stream.write(b"")[m
[31m-        except Exception:[m
[31m-            try:[m
[31m-                self._stream.write(b"")[m
[31m-            except Exception:[m
[31m-                return False[m
[31m-        return True[m
[31m-[m
[31m-    def seekable(self) -> bool:[m
[31m-        x = getattr(self._stream, "seekable", None)[m
[31m-        if x is not None:[m
[31m-            return t.cast(bool, x())[m
[31m-        try:[m
[31m-            self._stream.seek(self._stream.tell())[m
[31m-        except Exception:[m
[31m-            return False[m
[31m-        return True[m
[31m-[m
[31m-[m
[31m-def _is_binary_reader(stream: t.IO[t.Any], default: bool = False) -> bool:[m
[31m-    try:[m
[31m-        return isinstance(stream.read(0), bytes)[m
[31m-    except Exception:[m
[31m-        return default[m
[31m-        # This happens in some cases where the stream was already[m
[31m-        # closed.  In this case, we assume the default.[m
[31m-[m
[31m-[m
[31m-def _is_binary_writer(stream: t.IO[t.Any], default: bool = False) -> bool:[m
[31m-    try:[m
[31m-        stream.write(b"")[m
[31m-    except Exception:[m
[31m-        try:[m
[31m-            stream.write("")[m
[31m-            return False[m
[31m-        except Exception:[m
[31m-            pass[m
[31m-        return default[m
[31m-    return True[m
[31m-[m
[31m-[m
[31m-def _find_binary_reader(stream: t.IO[t.Any]) -> t.BinaryIO | None:[m
[31m-    # We need to figure out if the given stream is already binary.[m
[31m-    # This can happen because the official docs recommend detaching[m
[31m-    # the streams to get binary streams.  Some code might do this, so[m
[31m-    # we need to deal with this case explicitly.[m
[31m-    if _is_binary_reader(stream, False):[m
[31m-        return t.cast(t.BinaryIO, stream)[m
[31m-[m
[31m-    buf = getattr(stream, "buffer", None)[m
[31m-[m
[31m-    # Same situation here; this time we assume that the buffer is[m
[31m-    # actually binary in case it's closed.[m
[31m-    if buf is not None and _is_binary_reader(buf, True):[m
[31m-        return t.cast(t.BinaryIO, buf)[m
[31m-[m
[31m-    return None[m
[31m-[m
[31m-[m
[31m-def _find_binary_writer(stream: t.IO[t.Any]) -> t.BinaryIO | None:[m
[31m-    # We need to figure out if the given stream is already binary.[m
[31m-    # This can happen because the official docs recommend detaching[m
[31m-    # the streams to get binary streams.  Some code might do this, so[m
[31m-    # we need to deal with this case explicitly.[m
[31m-    if _is_binary_writer(stream, False):[m
[31m-        return t.cast(t.BinaryIO, stream)[m
[31m-[m
[31m-    buf = getattr(stream, "buffer", None)[m
[31m-[m
[31m-    # Same situation here; this time we assume that the buffer is[m
[31m-    # actually binary in case it's closed.[m
[31m-    if buf is not None and _is_binary_writer(buf, True):[m
[31m-        return t.cast(t.BinaryIO, buf)[m
[31m-[m
[31m-    return None[m
[31m-[m
[31m-[m
[31m-def _stream_is_misconfigured(stream: t.TextIO) -> bool:[m
[31m-    """A stream is misconfigured if its encoding is ASCII."""[m
[31m-    # If the stream does not have an encoding set, we assume it's set[m
[31m-    # to ASCII.  This appears to happen in certain unittest[m
[31m-    # environments.  It's not quite clear what the correct behavior is[m
[31m-    # but this at least will force Click to recover somehow.[m
[31m-    return is_ascii_encoding(getattr(stream, "encoding", None) or "ascii")[m
[31m-[m
[31m-[m
[31m-def _is_compat_stream_attr(stream: t.TextIO, attr: str, value: str | None) -> bool:[m
[31m-    """A stream attribute is compatible if it is equal to the[m
[31m-    desired value or the desired value is unset and the attribute[m
[31m-    has a value.[m
[31m-    """[m
[31m-    stream_value = getattr(stream, attr, None)[m
[31m-    return stream_value == value or (value is None and stream_value is not None)[m
[31m-[m
[31m-[m
[31m-def _is_compatible_text_stream([m
[31m-    stream: t.TextIO, encoding: str | None, errors: str | None[m
[31m-) -> bool:[m
[31m-    """Check if a stream's encoding and errors attributes are[m
[31m-    compatible with the desired values.[m
[31m-    """[m
[31m-    return _is_compat_stream_attr([m
[31m-        stream, "encoding", encoding[m
[31m-    ) and _is_compat_stream_attr(stream, "errors", errors)[m
[31m-[m
[31m-[m
[31m-def _force_correct_text_stream([m
[31m-    text_stream: t.IO[t.Any],[m
[31m-    encoding: str | None,[m
[31m-    errors: str | None,[m
[31m-    is_binary: t.Callable[[t.IO[t.Any], bool], bool],[m
[31m-    find_binary: t.Callable[[t.IO[t.Any]], t.BinaryIO | None],[m
[31m-    force_readable: bool = False,[m
[31m-    force_writable: bool = False,[m
[31m-) -> t.TextIO:[m
[31m-    if is_binary(text_stream, False):[m
[31m-        binary_reader = t.cast(t.BinaryIO, text_stream)[m
[31m-    else:[m
[31m-        text_stream = t.cast(t.TextIO, text_stream)[m
[31m-        # If the stream looks compatible, and won't default to a[m
[31m-        # misconfigured ascii encoding, return it as-is.[m
[31m-        if _is_compatible_text_stream(text_stream, encoding, errors) and not ([m
[31m-            encoding is None and _stream_is_misconfigured(text_stream)[m
[31m-        ):[m
[31m-            return text_stream[m
[31m-[m
[31m-        # Otherwise, get the underlying binary reader.[m
[31m-        possible_binary_reader = find_binary(text_stream)[m
[31m-[m
[31m-        # If that's not possible, silently use the original reader[m
[31m-        # and get mojibake instead of exceptions.[m
[31m-        if possible_binary_reader is None:[m
[31m-            return text_stream[m
[31m-[m
[31m-        binary_reader = possible_binary_reader[m
[31m-[m
[31m-    # Default errors to replace instead of strict in order to get[m
[31m-    # something that works.[m
[31m-    if errors is None:[m
[31m-        errors = "replace"[m
[31m-[m
[31m-    # Wrap the binary stream in a text stream with the correct[m
[31m-    # encoding parameters.[m
[31m-    return _make_text_stream([m
[31m-        binary_reader,[m
[31m-        encoding,[m
[31m-        errors,[m
[31m-        force_readable=force_readable,[m
[31m-        force_writable=force_writable,[m
[31m-    )[m
[31m-[m
[31m-[m
[31m-def _force_correct_text_reader([m
[31m-    text_reader: t.IO[t.Any],[m
[31m-    encoding: str | None,[m
[31m-    errors: str | None,[m
[31m-    force_readable: bool = False,[m
[31m-) -> t.TextIO:[m
[31m-    return _force_correct_text_stream([m
[31m-        text_reader,[m
[31m-        encoding,[m
[31m-        errors,[m
[31m-        _is_binary_reader,[m
[31m-        _find_binary_reader,[m
[31m-        force_readable=force_readable,[m
[31m-    )[m
[31m-[m
[31m-[m
[31m-def _force_correct_text_writer([m
[31m-    text_writer: t.IO[t.Any],[m
[31m-    encoding: str | None,[m
[31m-    errors: str | None,[m
[31m-    force_writable: bool = False,[m
[31m-) -> t.TextIO:[m
[31m-    return _force_correct_text_stream([m
[31m-        text_writer,[m
[31m-        encoding,[m
[31m-        errors,[m
[31m-        _is_binary_writer,[m
[31m-        _find_binary_writer,[m
[31m-        force_writable=force_writable,[m
[31m-    )[m
[31m-[m
[31m-[m
[31m-def get_binary_stdin() -> t.BinaryIO:[m
[31m-    reader = _find_binary_reader(sys.stdin)[m
[31m-    if reader is None:[m
[31m-        raise RuntimeError("Was not able to determine binary stream for sys.stdin.")[m
[31m-    return reader[m
[31m-[m
[31m-[m
[31m-def get_binary_stdout() -> t.BinaryIO:[m
[31m-    writer = _find_binary_writer(sys.stdout)[m
[31m-    if writer is None:[m
[31m-        raise RuntimeError("Was not able to determine binary stream for sys.stdout.")[m
[31m-    return writer[m
[31m-[m
[31m-[m
[31m-def get_binary_stderr() -> t.BinaryIO:[m
[31m-    writer = _find_binary_writer(sys.stderr)[m
[31m-    if writer is None:[m
[31m-        raise RuntimeError("Was not able to determine binary stream for sys.stderr.")[m
[31m-    return writer[m
[31m-[m
[31m-[m
[31m-def get_text_stdin(encoding: str | None = None, errors: str | None = None) -> t.TextIO:[m
[31m-    rv = _get_windows_console_stream(sys.stdin, encoding, errors)[m
[31m-    if rv is not None:[m
[31m-        return rv[m
[31m-    return _force_correct_text_reader(sys.stdin, encoding, errors, force_readable=True)[m
[31m-[m
[31m-[m
[31m-def get_text_stdout(encoding: str | None = None, errors: str | None = None) -> t.TextIO:[m
[31m-    rv = _get_windows_console_stream(sys.stdout, encoding, errors)[m
[31m-    if rv is not None:[m
[31m-        return rv[m
[31m-    return _force_correct_text_writer(sys.stdout, encoding, errors, force_writable=True)[m
[31m-[m
[31m-[m
[31m-def get_text_stderr(encoding: str | None = None, errors: str | None = None) -> t.TextIO:[m
[31m-    rv = _get_windows_console_stream(sys.stderr, encoding, errors)[m
[31m-    if rv is not None:[m
[31m-        return rv[m
[31m-    return _force_correct_text_writer(sys.stderr, encoding, errors, force_writable=True)[m
[31m-[m
[31m-[m
[31m-def _wrap_io_open([m
[31m-    file: str | os.PathLike[str] | int,[m
[31m-    mode: str,[m
[31m-    encoding: str | None,[m
[31m-    errors: str | None,[m
[31m-) -> t.IO[t.Any]:[m
[31m-    """Handles not passing ``encoding`` and ``errors`` in binary mode."""[m
[31m-    if "b" in mode:[m
[31m-        return open(file, mode)[m
[31m-[m
[31m-    return open(file, mode, encoding=encoding, errors=errors)[m
[31m-[m
[31m-[m
[31m-def open_stream([m
[31m-    filename: str | os.PathLike[str],[m
[31m-    mode: str = "r",[m
[31m-    encoding: str | None = None,[m
[31m-    errors: str | None = "strict",[m
[31m-    atomic: bool = False,[m
[31m-) -> tuple[t.IO[t.Any], bool]:[m
[31m-    binary = "b" in mode[m
[31m-    filename = os.fspath(filename)[m
[31m-[m
[31m-    # Standard streams first. These are simple because they ignore the[m
[31m-    # atomic flag. Use fsdecode to handle Path("-").[m
[31m-    if os.fsdecode(filename) == "-":[m
[31m-        if any(m in mode for m in ["w", "a", "x"]):[m
[31m-            if binary:[m
[31m-                return get_binary_stdout(), False[m
[31m-            return get_text_stdout(encoding=encoding, errors=errors), False[m
[31m-        if binary:[m
[31m-            return get_binary_stdin(), False[m
[31m-        return get_text_stdin(encoding=encoding, errors=errors), False[m
[31m-[m
[31m-    # Non-atomic writes directly go out through the regular open functions.[m
[31m-    if not atomic:[m
[31m-        return _wrap_io_open(filename, mode, encoding, errors), True[m
[31m-[m
[31m-    # Some usability stuff for atomic writes[m
[31m-    if "a" in mode:[m
[31m-        raise ValueError([m
[31m-            "Appending to an existing file is not supported, because that"[m
[31m-            " would involve an expensive `copy`-operation to a temporary"[m
[31m-            " file. Open the file in normal `w`-mode and copy explicitly"[m
[31m-            " if that's what you're after."[m
[31m-        )[m
[31m-    if "x" in mode:[m
[31m-        raise ValueError("Use the `overwrite`-parameter instead.")[m
[31m-    if "w" not in mode:[m
[31m-        raise ValueError("Atomic writes only make sense with `w`-mode.")[m
[31m-[m
[31m-    # Atomic writes are more complicated.  They work by opening a file[m
[31m-    # as a proxy in the same folder and then using the fdopen[m
[31m-    # functionality to wrap it in a Python file.  Then we wrap it in an[m
[31m-    # atomic file that moves the file over on close.[m
[31m-    import errno[m
[31m-    import random[m
[31m-[m
[31m-    try:[m
[31m-        perm: int | None = os.stat(filename).st_mode[m
[31m-    except OSError:[m
[31m-        perm = None[m
[31m-[m
[31m-    flags = os.O_RDWR | os.O_CREAT | os.O_EXCL[m
[31m-[m
[31m-    if binary:[m
[31m-        flags |= getattr(os, "O_BINARY", 0)[m
[31m-[m
[31m-    while True:[m
[31m-        tmp_filename = os.path.join([m
[31m-            os.path.dirname(filename),[m
[31m-            f".__atomic-write{random.randrange(1 << 32):08x}",[m
[31m-        )[m
[31m-        try:[m
[31m-            fd = os.open(tmp_filename, flags, 0o666 if perm is None else perm)[m
[31m-            break[m
[31m-        except OSError as e:[m
[31m-            if e.errno == errno.EEXIST or ([m
[31m-                os.name == "nt"[m
[31m-                and e.errno == errno.EACCES[m
[31m-                and os.path.isdir(e.filename)[m
[31m-                and os.access(e.filename, os.W_OK)[m
[31m-            ):[m
[31m-                continue[m
[31m-            raise[m
[31m-[m
[31m-    if perm is not None:[m
[31m-        os.chmod(tmp_filename, perm)  # in case perm includes bits in umask[m
[31m-[m
[31m-    f = _wrap_io_open(fd, mode, encoding, errors)[m
[31m-    af = _AtomicFile(f, tmp_filename, os.path.realpath(filename))[m
[31m-    return t.cast(t.IO[t.Any], af), True[m
[31m-[m
[31m-[m
[31m-class _AtomicFile:[m
[31m-    def __init__(self, f: t.IO[t.Any], tmp_filename: str, real_filename: str) -> None:[m
[31m-        self._f = f[m
[31m-        self._tmp_filename = tmp_filename[m
[31m-        self._real_filename = real_filename[m
[31m-        self.closed = False[m
[31m-[m
[31m-    @property[m
[31m-    def name(self) -> str:[m
[31m-        return self._real_filename[m
[31m-[m
[31m-    def close(self, delete: bool = False) -> None:[m
[31m-        if self.closed:[m
[31m-            return[m
[31m-        self._f.close()[m
[31m-        os.replace(self._tmp_filename, self._real_filename)[m
[31m-        self.closed = True[m
[31m-[m
[31m-    def __getattr__(self, name: str) -> t.Any:[m
[31m-        return getattr(self._f, name)[m
[31m-[m
[31m-    def __enter__(self) -> _AtomicFile:[m
[31m-        return self[m
[31m-[m
[31m-    def __exit__([m
[31m-        self,[m
[31m-        exc_type: type[BaseException] | None,[m
[31m-        exc_value: BaseException | None,[m
[31m-        tb: TracebackType | None,[m
[31m-    ) -> None:[m
[31m-        self.close(delete=exc_type is not None)[m
[31m-[m
[31m-    def __repr__(self) -> str:[m
[31m-        return repr(self._f)[m
[31m-[m
[31m-[m
[31m-def strip_ansi(value: str) -> str:[m
[31m-    return _ansi_re.sub("", value)[m
[31m-[m
[31m-[m
[31m-def _is_jupyter_kernel_output(stream: t.IO[t.Any]) -> bool:[m
[31m-    while isinstance(stream, (_FixupStream, _NonClosingTextIOWrapper)):[m
[31m-        stream = stream._stream[m
[31m-[m
[31m-    return stream.__class__.__module__.startswith("ipykernel.")[m
[31m-[m
[31m-[m
[31m-def should_strip_ansi([m
[31m-    stream: t.IO[t.Any] | None = None, color: bool | None = None[m
[31m-) -> bool:[m
[31m-    if color is None:[m
[31m-        if stream is None:[m
[31m-            stream = sys.stdin[m
[31m-        return not isatty(stream) and not _is_jupyter_kernel_output(stream)[m
[31m-    return not color[m
[31m-[m
[31m-[m
[31m-# On Windows, wrap the output streams with colorama to support ANSI[m
[31m-# color codes.[m
[31m-# NOTE: double check is needed so mypy does not analyze this on Linux[m
[31m-if sys.platform.startswith("win") and WIN:[m
[31m-    from ._winconsole import _get_windows_console_stream[m
[31m-[m
[31m-    def _get_argv_encoding() -> str:[m
[31m-        import locale[m
[31m-[m
[31m-        return locale.getpreferredencoding()[m
[31m-[m
[31m-    _ansi_stream_wrappers: cabc.MutableMapping[t.TextIO, t.TextIO] = WeakKeyDictionary()[m
[31m-[m
[31m-    def auto_wrap_for_ansi(stream: t.TextIO, color: bool | None = None) -> t.TextIO:[m
[31m-        """Support ANSI color and style codes on Windows by wrapping a[m
[31m-        stream with colorama.[m
[31m-        """[m
[31m-        try:[m
[31m-            cached = _ansi_stream_wrappers.get(stream)[m
[31m-        except Exception:[m
[31m-            cached = None[m
[31m-[m
[31m-        if cached is not None:[m
[31m-            return cached[m
[31m-[m
[31m-        import colorama[m
[31m-[m
[31m-        strip = should_strip_ansi(stream, color)[m
[31m-        ansi_wrapper = colorama.AnsiToWin32(stream, strip=strip)[m
[31m-        rv = t.cast(t.TextIO, ansi_wrapper.stream)[m
[31m-        _write = rv.write[m
[31m-[m
[31m-        def _safe_write(s: str) -> int:[m
[31m-            try:[m
[31m-                return _write(s)[m
[31m-            except BaseException:[m
[31m-                ansi_wrapper.reset_all()[m
[31m-                raise[m
[31m-[m
[31m-        rv.write = _safe_write  # type: ignore[method-assign][m
[31m-[m
[31m-        try:[m
[31m-            _ansi_stream_wrappers[stream] = rv[m
[31m-        except Exception:[m
[31m-            pass[m
[31m-[m
[31m-        return rv[m
[31m-[m
[31m-else:[m
[31m-[m
[31m-    def _get_argv_encoding() -> str:[m
[31m-        return getattr(sys.stdin, "encoding", None) or sys.getfilesystemencoding()[m
[31m-[m
[31m-    def _get_windows_console_stream([m
[31m-        f: t.TextIO, encoding: str | None, errors: str | None[m
[31m-    ) -> t.TextIO | None:[m
[31m-        return None[m
[31m-[m
[31m-[m
[31m-def term_len(x: str) -> int:[m
[31m-    return len(strip_ansi(x))[m
[31m-[m
[31m-[m
[31m-def isatty(stream: t.IO[t.Any]) -> bool:[m
[31m-    try:[m
[31m-        return stream.isatty()[m
[31m-    except Exception:[m
[31m-        return False[m
[31m-[m
[31m-[m
[31m-def _make_cached_stream_func([m
[31m-    src_func: t.Callable[[], t.TextIO | None],[m
[31m-    wrapper_func: t.Callable[[], t.TextIO],[m
[31m-) -> t.Callable[[], t.TextIO | None]:[m
[31m-    cache: cabc.MutableMapping[t.TextIO, t.TextIO] = WeakKeyDictionary()[m
[31m-[m
[31m-    def func() -> t.TextIO | None:[m
[31m-        stream = src_func()[m
[31m-[m
[31m-        if stream is None:[m
[31m-            return None[m
[31m-[m
[31m-        try:[m
[31m-            rv = cache.get(stream)[m
[31m-        except Exception:[m
[31m-            rv = None[m
[31m-        if rv is not None:[m
[31m-            return rv[m
[31m-        rv = wrapper_func()[m
[31m-        try:[m
[31m-            cache[stream] = rv[m
[31m-        except Exception:[m
[31m-            pass[m
[31m-        return rv[m
[31m-[m
[31m-    return func[m
[31m-[m
[31m-[m
[31m-_default_text_stdin = _make_cached_stream_func(lambda: sys.stdin, get_text_stdin)[m
[31m-_default_text_stdout = _make_cached_stream_func(lambda: sys.stdout, get_text_stdout)[m
[31m-_default_text_stderr = _make_cached_stream_func(lambda: sys.stderr, get_text_stderr)[m
[31m-[m
[31m-[m
[31m-binary_streams: cabc.Mapping[str, t.Callable[[], t.BinaryIO]] = {[m
[31m-    "stdin": get_binary_stdin,[m
[31m-    "stdout": get_binary_stdout,[m
[31m-    "stderr": get_binary_stderr,[m
[31m-}[m
[31m-[m
[31m-text_streams: cabc.Mapping[str, t.Callable[[str | None, str | None], t.TextIO]] = {[m
[31m-    "stdin": get_text_stdin,[m
[31m-    "stdout": get_text_stdout,[m
[31m-    "stderr": get_text_stderr,[m
[31m-}[m
[1mdiff --git a/venv/Lib/site-packages/click/_termui_impl.py b/venv/Lib/site-packages/click/_termui_impl.py[m
[1mdeleted file mode 100644[m
[1mindex 51fd9bf..0000000[m
[1m--- a/venv/Lib/site-packages/click/_termui_impl.py[m
[1m+++ /dev/null[m
[36m@@ -1,839 +0,0 @@[m
[31m-"""[m
[31m-This module contains implementations for the termui module. To keep the[m
[31m-import time of Click down, some infrequently used functionality is[m
[31m-placed in this module and only imported as needed.[m
[31m-"""[m
[31m-[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as cabc[m
[31m-import contextlib[m
[31m-import math[m
[31m-import os[m
[31m-import shlex[m
[31m-import sys[m
[31m-import time[m
[31m-import typing as t[m
[31m-from gettext import gettext as _[m
[31m-from io import StringIO[m
[31m-from pathlib import Path[m
[31m-from shutil import which[m
[31m-from types import TracebackType[m
[31m-[m
[31m-from ._compat import _default_text_stdout[m
[31m-from ._compat import CYGWIN[m
[31m-from ._compat import get_best_encoding[m
[31m-from ._compat import isatty[m
[31m-from ._compat import open_stream[m
[31m-from ._compat import strip_ansi[m
[31m-from ._compat import term_len[m
[31m-from ._compat import WIN[m
[31m-from .exceptions import ClickException[m
[31m-from .utils import echo[m
[31m-[m
[31m-V = t.TypeVar("V")[m
[31m-[m
[31m-if os.name == "nt":[m
[31m-    BEFORE_BAR = "\r"[m
[31m-    AFTER_BAR = "\n"[m
[31m-else:[m
[31m-    BEFORE_BAR = "\r\033[?25l"[m
[31m-    AFTER_BAR = "\033[?25h\n"[m
[31m-[m
[31m-[m
[31m-class ProgressBar(t.Generic[V]):[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        iterable: cabc.Iterable[V] | None,[m
[31m-        length: int | None = None,[m
[31m-        fill_char: str = "#",[m
[31m-        empty_char: str = " ",[m
[31m-        bar_template: str = "%(bar)s",[m
[31m-        info_sep: str = "  ",[m
[31m-        hidden: bool = False,[m
[31m-        show_eta: bool = True,[m
[31m-        show_percent: bool | None = None,[m
[31m-        show_pos: bool = False,[m
[31m-        item_show_func: t.Callable[[V | None], str | None] | None = None,[m
[31m-        label: str | None = None,[m
[31m-        file: t.TextIO | None = None,[m
[31m-        color: bool | None = None,[m
[31m-        update_min_steps: int = 1,[m
[31m-        width: int = 30,[m
[31m-    ) -> None:[m
[31m-        self.fill_char = fill_char[m
[31m-        self.empty_char = empty_char[m
[31m-        self.bar_template = bar_template[m
[31m-        self.info_sep = info_sep[m
[31m-        self.hidden = hidden[m
[31m-        self.show_eta = show_eta[m
[31m-        self.show_percent = show_percent[m
[31m-        self.show_pos = show_pos[m
[31m-        self.item_show_func = item_show_func[m
[31m-        self.label: str = label or ""[m
[31m-[m
[31m-        if file is None:[m
[31m-            file = _default_text_stdout()[m
[31m-[m
[31m-            # There are no standard streams attached to write to. For example,[m
[31m-            # pythonw on Windows.[m
[31m-            if file is None:[m
[31m-                file = StringIO()[m
[31m-[m
[31m-        self.file = file[m
[31m-        self.color = color[m
[31m-        self.update_min_steps = update_min_steps[m
[31m-        self._completed_intervals = 0[m
[31m-        self.width: int = width[m
[31m-        self.autowidth: bool = width == 0[m
[31m-[m
[31m-        if length is None:[m
[31m-            from operator import length_hint[m
[31m-[m
[31m-            length = length_hint(iterable, -1)[m
[31m-[m
[31m-            if length == -1:[m
[31m-                length = None[m
[31m-        if iterable is None:[m
[31m-            if length is None:[m
[31m-                raise TypeError("iterable or length is required")[m
[31m-            iterable = t.cast("cabc.Iterable[V]", range(length))[m
[31m-        self.iter: cabc.Iterable[V] = iter(iterable)[m
[31m-        self.length = length[m
[31m-        self.pos: int = 0[m
[31m-        self.avg: list[float] = [][m
[31m-        self.last_eta: float[m
[31m-        self.start: float[m
[31m-        self.start = self.last_eta = time.time()[m
[31m-        self.eta_known: bool = False[m
[31m-        self.finished: bool = False[m
[31m-        self.max_width: int | None = None[m
[31m-        self.entered: bool = False[m
[31m-        self.current_item: V | None = None[m
[31m-        self._is_atty = isatty(self.file)[m
[31m-        self._last_line: str | None = None[m
[31m-[m
[31m-    def __enter__(self) -> ProgressBar[V]:[m
[31m-        self.entered = True[m
[31m-        self.render_progress()[m
[31m-        return self[m
[31m-[m
[31m-    def __exit__([m
[31m-        self,[m
[31m-        exc_type: type[BaseException] | None,[m
[31m-        exc_value: BaseException | None,[m
[31m-        tb: TracebackType | None,[m
[31m-    ) -> None:[m
[31m-        self.render_finish()[m
[31m-[m
[31m-    def __iter__(self) -> cabc.Iterator[V]:[m
[31m-        if not self.entered:[m
[31m-            raise RuntimeError("You need to use progress bars in a with block.")[m
[31m-        self.render_progress()[m
[31m-        return self.generator()[m
[31m-[m
[31m-    def __next__(self) -> V:[m
[31m-        # Iteration is defined in terms of a generator function,[m
[31m-        # returned by iter(self); use that to define next(). This works[m
[31m-        # because `self.iter` is an iterable consumed by that generator,[m
[31m-        # so it is re-entry safe. Calling `next(self.generator())`[m
[31m-        # twice works and does "what you want".[m
[31m-        return next(iter(self))[m
[31m-[m
[31m-    def render_finish(self) -> None:[m
[31m-        if self.hidden or not self._is_atty:[m
[31m-            return[m
[31m-        self.file.write(AFTER_BAR)[m
[31m-        self.file.flush()[m
[31m-[m
[31m-    @property[m
[31m-    def pct(self) -> float:[m
[31m-        if self.finished:[m
[31m-            return 1.0[m
[31m-        return min(self.pos / (float(self.length or 1) or 1), 1.0)[m
[31m-[m
[31m-    @property[m
[31m-    def time_per_iteration(self) -> float:[m
[31m-        if not self.avg:[m
[31m-            return 0.0[m
[31m-        return sum(self.avg) / float(len(self.avg))[m
[31m-[m
[31m-    @property[m
[31m-    def eta(self) -> float:[m
[31m-        if self.length is not None and not self.finished:[m
[31m-            return self.time_per_iteration * (self.length - self.pos)[m
[31m-        return 0.0[m
[31m-[m
[31m-    def format_eta(self) -> str:[m
[31m-        if self.eta_known:[m
[31m-            t = int(self.eta)[m
[31m-            seconds = t % 60[m
[31m-            t //= 60[m
[31m-            minutes = t % 60[m
[31m-            t //= 60[m
[31m-            hours = t % 24[m
[31m-            t //= 24[m
[31m-            if t > 0:[m
[31m-                return f"{t}d {hours:02}:{minutes:02}:{seconds:02}"[m
[31m-            else:[m
[31m-                return f"{hours:02}:{minutes:02}:{seconds:02}"[m
[31m-        return ""[m
[31m-[m
[31m-    def format_pos(self) -> str:[m
[31m-        pos = str(self.pos)[m
[31m-        if self.length is not None:[m
[31m-            pos += f"/{self.length}"[m
[31m-        return pos[m
[31m-[m
[31m-    def format_pct(self) -> str:[m
[31m-        return f"{int(self.pct * 100): 4}%"[1:][m
[31m-[m
[31m-    def format_bar(self) -> str:[m
[31m-        if self.length is not None:[m
[31m-            bar_length = int(self.pct * self.width)[m
[31m-            bar = self.fill_char * bar_length[m
[31m-            bar += self.empty_char * (self.width - bar_length)[m
[31m-        elif self.finished:[m
[31m-            bar = self.fill_char * self.width[m
[31m-        else:[m
[31m-            chars = list(self.empty_char * (self.width or 1))[m
[31m-            if self.time_per_iteration != 0:[m
[31m-                chars[[m
[31m-                    int([m
[31m-                        (math.cos(self.pos * self.time_per_iteration) / 2.0 + 0.5)[m
[31m-                        * self.width[m
[31m-                    )[m
[31m-                ] = self.fill_char[m
[31m-            bar = "".join(chars)[m
[31m-        return bar[m
[31m-[m
[31m-    def format_progress_line(self) -> str:[m
[31m-        show_percent = self.show_percent[m
[31m-[m
[31m-        info_bits = [][m
[31m-        if self.length is not None and show_percent is None:[m
[31m-            show_percent = not self.show_pos[m
[31m-[m
[31m-        if self.show_pos:[m
[31m-            info_bits.append(self.format_pos())[m
[31m-        if show_percent:[m
[31m-            info_bits.append(self.format_pct())[m
[31m-        if self.show_eta and self.eta_known and not self.finished:[m
[31m-            info_bits.append(self.format_eta())[m
[31m-        if self.item_show_func is not None:[m
[31m-            item_info = self.item_show_func(self.current_item)[m
[31m-            if item_info is not None:[m
[31m-                info_bits.append(item_info)[m
[31m-[m
[31m-        return ([m
[31m-            self.bar_template[m
[31m-            % {[m
[31m-                "label": self.label,[m
[31m-                "bar": self.format_bar(),[m
[31m-                "info": self.info_sep.join(info_bits),[m
[31m-            }[m
[31m-        ).rstrip()[m
[31m-[m
[31m-    def render_progress(self) -> None:[m
[31m-        import shutil[m
[31m-[m
[31m-        if self.hidden:[m
[31m-            return[m
[31m-[m
[31m-        if not self._is_atty:[m
[31m-            # Only output the label once if the output is not a TTY.[m
[31m-            if self._last_line != self.label:[m
[31m-                self._last_line = self.label[m
[31m-                echo(self.label, file=self.file, color=self.color)[m
[31m-            return[m
[31m-[m
[31m-        buf = [][m
[31m-        # Update width in case the terminal has been resized[m
[31m-        if self.autowidth:[m
[31m-            old_width = self.width[m
[31m-            self.width = 0[m
[31m-            clutter_length = term_len(self.format_progress_line())[m
[31m-            new_width = max(0, shutil.get_terminal_size().columns - clutter_length)[m
[31m-            if new_width < old_width and self.max_width is not None:[m
[31m-                buf.append(BEFORE_BAR)[m
[31m-                buf.append(" " * self.max_width)[m
[31m-                self.max_width = new_width[m
[31m-            self.width = new_width[m
[31m-[m
[31m-        clear_width = self.width[m
[31m-        if self.max_width is not None:[m
[31m-            clear_width = self.max_width[m
[31m-[m
[31m-        buf.append(BEFORE_BAR)[m
[31m-        line = self.format_progress_line()[m
[31m-        line_len = term_len(line)[m
[31m-        if self.max_width is None or self.max_width < line_len:[m
[31m-            self.max_width = line_len[m
[31m-[m
[31m-        buf.append(line)[m
[31m-        buf.append(" " * (clear_width - line_len))[m
[31m-        line = "".join(buf)[m
[31m-        # Render the line only if it changed.[m
[31m-[m
[31m-        if line != self._last_line:[m
[31m-            self._last_line = line[m
[31m-            echo(line, file=self.file, color=self.color, nl=False)[m
[31m-            self.file.flush()[m
[31m-[m
[31m-    def make_step(self, n_steps: int) -> None:[m
[31m-        self.pos += n_steps[m
[31m-        if self.length is not None and self.pos >= self.length:[m
[31m-            self.finished = True[m
[31m-[m
[31m-        if (time.time() - self.last_eta) < 1.0:[m
[31m-            return[m
[31m-[m
[31m-        self.last_eta = time.time()[m
[31m-[m
[31m-        # self.avg is a rolling list of length <= 7 of steps where steps are[m
[31m-        # defined as time elapsed divided by the total progress through[m
[31m-        # self.length.[m
[31m-        if self.pos:[m
[31m-            step = (time.time() - self.start) / self.pos[m
[31m-        else:[m
[31m-            step = time.time() - self.start[m
[31m-[m
[31m-        self.avg = self.avg[-6:] + [step][m
[31m-[m
[31m-        self.eta_known = self.length is not None[m
[31m-[m
[31m-    def update(self, n_steps: int, current_item: V | None = None) -> None:[m
[31m-        """Update the progress bar by advancing a specified number of[m
[31m-        steps, and optionally set the ``current_item`` for this new[m
[31m-        position.[m
[31m-[m
[31m-        :param n_steps: Number of steps to advance.[m
[31m-        :param current_item: Optional item to set as ``current_item``[m
[31m-            for the updated position.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Added the ``current_item`` optional parameter.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Only render when the number of steps meets the[m
[31m-            ``update_min_steps`` threshold.[m
[31m-        """[m
[31m-        if current_item is not None:[m
[31m-            self.current_item = current_item[m
[31m-[m
[31m-        self._completed_intervals += n_steps[m
[31m-[m
[31m-        if self._completed_intervals >= self.update_min_steps:[m
[31m-            self.make_step(self._completed_intervals)[m
[31m-            self.render_progress()[m
[31m-            self._completed_intervals = 0[m
[31m-[m
[31m-    def finish(self) -> None:[m
[31m-        self.eta_known = False[m
[31m-        self.current_item = None[m
[31m-        self.finished = True[m
[31m-[m
[31m-    def generator(self) -> cabc.Iterator[V]:[m
[31m-        """Return a generator which yields the items added to the bar[m
[31m-        during construction, and updates the progress bar *after* the[m
[31m-        yielded block returns.[m
[31m-        """[m
[31m-        # WARNING: the iterator interface for `ProgressBar` relies on[m
[31m-        # this and only works because this is a simple generator which[m
[31m-        # doesn't create or manage additional state. If this function[m
[31m-        # changes, the impact should be evaluated both against[m
[31m-        # `iter(bar)` and `next(bar)`. `next()` in particular may call[m
[31m-        # `self.generator()` repeatedly, and this must remain safe in[m
[31m-        # order for that interface to work.[m
[31m-        if not self.entered:[m
[31m-            raise RuntimeError("You need to use progress bars in a with block.")[m
[31m-[m
[31m-        if not self._is_atty:[m
[31m-            yield from self.iter[m
[31m-        else:[m
[31m-            for rv in self.iter:[m
[31m-                self.current_item = rv[m
[31m-[m
[31m-                # This allows show_item_func to be updated before the[m
[31m-                # item is processed. Only trigger at the beginning of[m
[31m-                # the update interval.[m
[31m-                if self._completed_intervals == 0:[m
[31m-                    self.render_progress()[m
[31m-[m
[31m-                yield rv[m
[31m-                self.update(1)[m
[31m-[m
[31m-            self.finish()[m
[31m-            self.render_progress()[m
[31m-[m
[31m-[m
[31m-def pager(generator: cabc.Iterable[str], color: bool | None = None) -> None:[m
[31m-    """Decide what method to use for paging through text."""[m
[31m-    stdout = _default_text_stdout()[m
[31m-[m
[31m-    # There are no standard streams attached to write to. For example,[m
[31m-    # pythonw on Windows.[m
[31m-    if stdout is None:[m
[31m-        stdout = StringIO()[m
[31m-[m
[31m-    if not isatty(sys.stdin) or not isatty(stdout):[m
[31m-        return _nullpager(stdout, generator, color)[m
[31m-[m
[31m-    # Split and normalize the pager command into parts.[m
[31m-    pager_cmd_parts = shlex.split(os.environ.get("PAGER", ""), posix=False)[m
[31m-    if pager_cmd_parts:[m
[31m-        if WIN:[m
[31m-            if _tempfilepager(generator, pager_cmd_parts, color):[m
[31m-                return[m
[31m-        elif _pipepager(generator, pager_cmd_parts, color):[m
[31m-            return[m
[31m-[m
[31m-    if os.environ.get("TERM") in ("dumb", "emacs"):[m
[31m-        return _nullpager(stdout, generator, color)[m
[31m-    if (WIN or sys.platform.startswith("os2")) and _tempfilepager([m
[31m-        generator, ["more"], color[m
[31m-    ):[m
[31m-        return[m
[31m-    if _pipepager(generator, ["less"], color):[m
[31m-        return[m
[31m-[m
[31m-    import tempfile[m
[31m-[m
[31m-    fd, filename = tempfile.mkstemp()[m
[31m-    os.close(fd)[m
[31m-    try:[m
[31m-        if _pipepager(generator, ["more"], color):[m
[31m-            return[m
[31m-        return _nullpager(stdout, generator, color)[m
[31m-    finally:[m
[31m-        os.unlink(filename)[m
[31m-[m
[31m-[m
[31m-def _pipepager([m
[31m-    generator: cabc.Iterable[str], cmd_parts: list[str], color: bool | None[m
[31m-) -> bool:[m
[31m-    """Page through text by feeding it to another program. Invoking a[m
[31m-    pager through this might support colors.[m
[31m-[m
[31m-    Returns `True` if the command was found, `False` otherwise and thus another[m
[31m-    pager should be attempted.[m
[31m-    """[m
[31m-    # Split the command into the invoked CLI and its parameters.[m
[31m-    if not cmd_parts:[m
[31m-        return False[m
[31m-    cmd = cmd_parts[0][m
[31m-    cmd_params = cmd_parts[1:][m
[31m-[m
[31m-    cmd_filepath = which(cmd)[m
[31m-    if not cmd_filepath:[m
[31m-        return False[m
[31m-    # Resolves symlinks and produces a normalized absolute path string.[m
[31m-    cmd_path = Path(cmd_filepath).resolve()[m
[31m-    cmd_name = cmd_path.name[m
[31m-[m
[31m-    import subprocess[m
[31m-[m
[31m-    # Make a local copy of the environment to not affect the global one.[m
[31m-    env = dict(os.environ)[m
[31m-[m
[31m-    # If we're piping to less and the user hasn't decided on colors, we enable[m
[31m-    # them by default we find the -R flag in the command line arguments.[m
[31m-    if color is None and cmd_name == "less":[m
[31m-        less_flags = f"{os.environ.get('LESS', '')}{' '.join(cmd_params)}"[m
[31m-        if not less_flags:[m
[31m-            env["LESS"] = "-R"[m
[31m-            color = True[m
[31m-        elif "r" in less_flags or "R" in less_flags:[m
[31m-            color = True[m
[31m-[m
[31m-    c = subprocess.Popen([m
[31m-        [str(cmd_path)] + cmd_params,[m
[31m-        shell=True,[m
[31m-        stdin=subprocess.PIPE,[m
[31m-        env=env,[m
[31m-        errors="replace",[m
[31m-        text=True,[m
[31m-    )[m
[31m-    assert c.stdin is not None[m
[31m-    try:[m
[31m-        for text in generator:[m
[31m-            if not color:[m
[31m-                text = strip_ansi(text)[m
[31m-[m
[31m-            c.stdin.write(text)[m
[31m-    except BrokenPipeError:[m
[31m-        # In case the pager exited unexpectedly, ignore the broken pipe error.[m
[31m-        pass[m
[31m-    except Exception as e:[m
[31m-        # In case there is an exception we want to close the pager immediately[m
[31m-        # and let the caller handle it.[m
[31m-        # Otherwise the pager will keep running, and the user may not notice[m
[31m-        # the error message, or worse yet it may leave the terminal in a broken state.[m
[31m-        c.terminate()[m
[31m-        raise e[m
[31m-    finally:[m
[31m-        # We must close stdin and wait for the pager to exit before we continue[m
[31m-        try:[m
[31m-            c.stdin.close()[m
[31m-        # Close implies flush, so it might throw a BrokenPipeError if the pager[m
[31m-        # process exited already.[m
[31m-        except BrokenPipeError:[m
[31m-            pass[m
[31m-[m
[31m-        # Less doesn't respect ^C, but catches it for its own UI purposes (aborting[m
[31m-        # search or other commands inside less).[m
[31m-        #[m
[31m-        # That means when the user hits ^C, the parent process (click) terminates,[m
[31m-        # but less is still alive, paging the output and messing up the terminal.[m
[31m-        #[m
[31m-        # If the user wants to make the pager exit on ^C, they should set[m
[31m-        # `LESS='-K'`. It's not our decision to make.[m
[31m-        while True:[m
[31m-            try:[m
[31m-                c.wait()[m
[31m-            except KeyboardInterrupt:[m
[31m-                pass[m
[31m-            else:[m
[31m-                break[m
[31m-[m
[31m-    return True[m
[31m-[m
[31m-[m
[31m-def _tempfilepager([m
[31m-    generator: cabc.Iterable[str], cmd_parts: list[str], color: bool | None[m
[31m-) -> bool:[m
[31m-    """Page through text by invoking a program on a temporary file.[m
[31m-[m
[31m-    Returns `True` if the command was found, `False` otherwise and thus another[m
[31m-    pager should be attempted.[m
[31m-    """[m
[31m-    # Split the command into the invoked CLI and its parameters.[m
[31m-    if not cmd_parts:[m
[31m-        return False[m
[31m-    cmd = cmd_parts[0][m
[31m-[m
[31m-    cmd_filepath = which(cmd)[m
[31m-    if not cmd_filepath:[m
[31m-        return False[m
[31m-    # Resolves symlinks and produces a normalized absolute path string.[m
[31m-    cmd_path = Path(cmd_filepath).resolve()[m
[31m-[m
[31m-    import subprocess[m
[31m-    import tempfile[m
[31m-[m
[31m-    fd, filename = tempfile.mkstemp()[m
[31m-    # TODO: This never terminates if the passed generator never terminates.[m
[31m-    text = "".join(generator)[m
[31m-    if not color:[m
[31m-        text = strip_ansi(text)[m
[31m-    encoding = get_best_encoding(sys.stdout)[m
[31m-    with open_stream(filename, "wb")[0] as f:[m
[31m-        f.write(text.encode(encoding))[m
[31m-    try:[m
[31m-        subprocess.call([str(cmd_path), filename])[m
[31m-    except OSError:[m
[31m-        # Command not found[m
[31m-        pass[m
[31m-    finally:[m
[31m-        os.close(fd)[m
[31m-        os.unlink(filename)[m
[31m-[m
[31m-    return True[m
[31m-[m
[31m-[m
[31m-def _nullpager([m
[31m-    stream: t.TextIO, generator: cabc.Iterable[str], color: bool | None[m
[31m-) -> None:[m
[31m-    """Simply print unformatted text.  This is the ultimate fallback."""[m
[31m-    for text in generator:[m
[31m-        if not color:[m
[31m-            text = strip_ansi(text)[m
[31m-        stream.write(text)[m
[31m-[m
[31m-[m
[31m-class Editor:[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        editor: str | None = None,[m
[31m-        env: cabc.Mapping[str, str] | None = None,[m
[31m-        require_save: bool = True,[m
[31m-        extension: str = ".txt",[m
[31m-    ) -> None:[m
[31m-        self.editor = editor[m
[31m-        self.env = env[m
[31m-        self.require_save = require_save[m
[31m-        self.extension = extension[m
[31m-[m
[31m-    def get_editor(self) -> str:[m
[31m-        if self.editor is not None:[m
[31m-            return self.editor[m
[31m-        for key in "VISUAL", "EDITOR":[m
[31m-            rv = os.environ.get(key)[m
[31m-            if rv:[m
[31m-                return rv[m
[31m-        if WIN:[m
[31m-            return "notepad"[m
[31m-        for editor in "sensible-editor", "vim", "nano":[m
[31m-            if which(editor) is not None:[m
[31m-                return editor[m
[31m-        return "vi"[m
[31m-[m
[31m-    def edit_files(self, filenames: cabc.Iterable[str]) -> None:[m
[31m-        import subprocess[m
[31m-[m
[31m-        editor = self.get_editor()[m
[31m-        environ: dict[str, str] | None = None[m
[31m-[m
[31m-        if self.env:[m
[31m-            environ = os.environ.copy()[m
[31m-            environ.update(self.env)[m
[31m-[m
[31m-        exc_filename = " ".join(f'"{filename}"' for filename in filenames)[m
[31m-[m
[31m-        try:[m
[31m-            c = subprocess.Popen([m
[31m-                args=f"{editor} {exc_filename}", env=environ, shell=True[m
[31m-            )[m
[31m-            exit_code = c.wait()[m
[31m-            if exit_code != 0:[m
[31m-                raise ClickException([m
[31m-                    _("{editor}: Editing failed").format(editor=editor)[m
[31m-                )[m
[31m-        except OSError as e:[m
[31m-            raise ClickException([m
[31m-                _("{editor}: Editing failed: {e}").format(editor=editor, e=e)[m
[31m-            ) from e[m
[31m-[m
[31m-    @t.overload[m
[31m-    def edit(self, text: bytes | bytearray) -> bytes | None: ...[m
[31m-[m
[31m-    # We cannot know whether or not the type expected is str or bytes when None[m
[31m-    # is passed, so str is returned as that was what was done before.[m
[31m-    @t.overload[m
[31m-    def edit(self, text: str | None) -> str | None: ...[m
[31m-[m
[31m-    def edit(self, text: str | bytes | bytearray | None) -> str | bytes | None:[m
[31m-        import tempfile[m
[31m-[m
[31m-        if text is None:[m
[31m-            data = b""[m
[31m-        elif isinstance(text, (bytes, bytearray)):[m
[31m-            data = text[m
[31m-        else:[m
[31m-            if text and not text.endswith("\n"):[m
[31m-                text += "\n"[m
[31m-[m
[31m-            if WIN:[m
[31m-                data = text.replace("\n", "\r\n").encode("utf-8-sig")[m
[31m-            else:[m
[31m-                data = text.encode("utf-8")[m
[31m-[m
[31m-        fd, name = tempfile.mkstemp(prefix="editor-", suffix=self.extension)[m
[31m-        f: t.BinaryIO[m
[31m-[m
[31m-        try:[m
[31m-            with os.fdopen(fd, "wb") as f:[m
[31m-                f.write(data)[m
[31m-[m
[31m-            # If the filesystem resolution is 1 second, like Mac OS[m
[31m-            # 10.12 Extended, or 2 seconds, like FAT32, and the editor[m
[31m-            # closes very fast, require_save can fail. Set the modified[m
[31m-            # time to be 2 seconds in the past to work around this.[m
[31m-            os.utime(name, (os.path.getatime(name), os.path.getmtime(name) - 2))[m
[31m-            # Depending on the resolution, the exact value might not be[m
[31m-            # recorded, so get the new recorded value.[m
[31m-            timestamp = os.path.getmtime(name)[m
[31m-[m
[31m-            self.edit_files((name,))[m
[31m-[m
[31m-            if self.require_save and os.path.getmtime(name) == timestamp:[m
[31m-                return None[m
[31m-[m
[31m-            with open(name, "rb") as f:[m
[31m-                rv = f.read()[m
[31m-[m
[31m-            if isinstance(text, (bytes, bytearray)):[m
[31m-                return rv[m
[31m-[m
[31m-            return rv.decode("utf-8-sig").replace("\r\n", "\n")[m
[31m-        finally:[m
[31m-            os.unlink(name)[m
[31m-[m
[31m-[m
[31m-def open_url(url: str, wait: bool = False, locate: bool = False) -> int:[m
[31m-    import subprocess[m
[31m-[m
[31m-    def _unquote_file(url: str) -> str:[m
[31m-        from urllib.parse import unquote[m
[31m-[m
[31m-        if url.startswith("file://"):[m
[31m-            url = unquote(url[7:])[m
[31m-[m
[31m-        return url[m
[31m-[m
[31m-    if sys.platform == "darwin":[m
[31m-        args = ["open"][m
[31m-        if wait:[m
[31m-            args.append("-W")[m
[31m-        if locate:[m
[31m-            args.append("-R")[m
[31m-        args.append(_unquote_file(url))[m
[31m-        null = open("/dev/null", "w")[m
[31m-        try:[m
[31m-            return subprocess.Popen(args, stderr=null).wait()[m
[31m-        finally:[m
[31m-            null.close()[m
[31m-    elif WIN:[m
[31m-        if locate:[m
[31m-            url = _unquote_file(url)[m
[31m-            args = ["explorer", f"/select,{url}"][m
[31m-        else:[m
[31m-            args = ["start"][m
[31m-            if wait:[m
[31m-                args.append("/WAIT")[m
[31m-            args.append("")[m
[31m-            args.append(url)[m
[31m-        try:[m
[31m-            return subprocess.call(args)[m
[31m-        except OSError:[m
[31m-            # Command not found[m
[31m-            return 127[m
[31m-    elif CYGWIN:[m
[31m-        if locate:[m
[31m-            url = _unquote_file(url)[m
[31m-            args = ["cygstart", os.path.dirname(url)][m
[31m-        else:[m
[31m-            args = ["cygstart"][m
[31m-            if wait:[m
[31m-                args.append("-w")[m
[31m-            args.append(url)[m
[31m-        try:[m
[31m-            return subprocess.call(args)[m
[31m-        except OSError:[m
[31m-            # Command not found[m
[31m-            return 127[m
[31m-[m
[31m-    try:[m
[31m-        if locate:[m
[31m-            url = os.path.dirname(_unquote_file(url)) or "."[m
[31m-        else:[m
[31m-            url = _unquote_file(url)[m
[31m-        c = subprocess.Popen(["xdg-open", url])[m
[31m-        if wait:[m
[31m-            return c.wait()[m
[31m-        return 0[m
[31m-    except OSError:[m
[31m-        if url.startswith(("http://", "https://")) and not locate and not wait:[m
[31m-            import webbrowser[m
[31m-[m
[31m-            webbrowser.open(url)[m
[31m-            return 0[m
[31m-        return 1[m
[31m-[m
[31m-[m
[31m-def _translate_ch_to_exc(ch: str) -> None:[m
[31m-    if ch == "\x03":[m
[31m-        raise KeyboardInterrupt()[m
[31m-[m
[31m-    if ch == "\x04" and not WIN:  # Unix-like, Ctrl+D[m
[31m-        raise EOFError()[m
[31m-[m
[31m-    if ch == "\x1a" and WIN:  # Windows, Ctrl+Z[m
[31m-        raise EOFError()[m
[31m-[m
[31m-    return None[m
[31m-[m
[31m-[m
[31m-if sys.platform == "win32":[m
[31m-    import msvcrt[m
[31m-[m
[31m-    @contextlib.contextmanager[m
[31m-    def raw_terminal() -> cabc.Iterator[int]:[m
[31m-        yield -1[m
[31m-[m
[31m-    def getchar(echo: bool) -> str:[m
[31m-        # The function `getch` will return a bytes object corresponding to[m
[31m-        # the pressed character. Since Windows 10 build 1803, it will also[m
[31m-        # return \x00 when called a second time after pressing a regular key.[m
[31m-        #[m
[31m-        # `getwch` does not share this probably-bugged behavior. Moreover, it[m
[31m-        # returns a Unicode object by default, which is what we want.[m
[31m-        #[m
[31m-        # Either of these functions will return \x00 or \xe0 to indicate[m
[31m-        # a special key, and you need to call the same function again to get[m
[31m-        # the "rest" of the code. The fun part is that \u00e0 is[m
[31m-        # "latin small letter a with grave", so if you type that on a French[m
[31m-        # keyboard, you _also_ get a \xe0.[m
[31m-        # E.g., consider the Up arrow. This returns \xe0 and then \x48. The[m
[31m-        # resulting Unicode string reads as "a with grave" + "capital H".[m
[31m-        # This is indistinguishable from when the user actually types[m
[31m-        # "a with grave" and then "capital H".[m
[31m-        #[m
[31m-        # When \xe0 is returned, we assume it's part of a special-key sequence[m
[31m-        # and call `getwch` again, but that means that when the user types[m
[31m-        # the \u00e0 character, `getchar` doesn't return until a second[m
[31m-        # character is typed.[m
[31m-        # The alternative is returning immediately, but that would mess up[m
[31m-        # cross-platform handling of arrow keys and others that start with[m
[31m-        # \xe0. Another option is using `getch`, but then we can't reliably[m
[31m-        # read non-ASCII characters, because return values of `getch` are[m
[31m-        # limited to the current 8-bit codepage.[m
[31m-        #[m
[31m-        # Anyway, Click doesn't claim to do this Right(tm), and using `getwch`[m
[31m-        # is doing the right thing in more situations than with `getch`.[m
[31m-[m
[31m-        if echo:[m
[31m-            func = t.cast(t.Callable[[], str], msvcrt.getwche)[m
[31m-        else:[m
[31m-            func = t.cast(t.Callable[[], str], msvcrt.getwch)[m
[31m-[m
[31m-        rv = func()[m
[31m-[m
[31m-        if rv in ("\x00", "\xe0"):[m
[31m-            # \x00 and \xe0 are control characters that indicate special key,[m
[31m-            # see above.[m
[31m-            rv += func()[m
[31m-[m
[31m-        _translate_ch_to_exc(rv)[m
[31m-        return rv[m
[31m-[m
[31m-else:[m
[31m-    import termios[m
[31m-    import tty[m
[31m-[m
[31m-    @contextlib.contextmanager[m
[31m-    def raw_terminal() -> cabc.Iterator[int]:[m
[31m-        f: t.TextIO | None[m
[31m-        fd: int[m
[31m-[m
[31m-        if not isatty(sys.stdin):[m
[31m-            f = open("/dev/tty")[m
[31m-            fd = f.fileno()[m
[31m-        else:[m
[31m-            fd = sys.stdin.fileno()[m
[31m-            f = None[m
[31m-[m
[31m-        try:[m
[31m-            old_settings = termios.tcgetattr(fd)[m
[31m-[m
[31m-            try:[m
[31m-                tty.setraw(fd)[m
[31m-                yield fd[m
[31m-            finally:[m
[31m-                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)[m
[31m-                sys.stdout.flush()[m
[31m-[m
[31m-                if f is not None:[m
[31m-                    f.close()[m
[31m-        except termios.error:[m
[31m-            pass[m
[31m-[m
[31m-    def getchar(echo: bool) -> str:[m
[31m-        with raw_terminal() as fd:[m
[31m-            ch = os.read(fd, 32).decode(get_best_encoding(sys.stdin), "replace")[m
[31m-[m
[31m-            if echo and isatty(sys.stdout):[m
[31m-                sys.stdout.write(ch)[m
[31m-[m
[31m-            _translate_ch_to_exc(ch)[m
[31m-            return ch[m
[1mdiff --git a/venv/Lib/site-packages/click/_textwrap.py b/venv/Lib/site-packages/click/_textwrap.py[m
[1mdeleted file mode 100644[m
[1mindex 97fbee3..0000000[m
[1m--- a/venv/Lib/site-packages/click/_textwrap.py[m
[1m+++ /dev/null[m
[36m@@ -1,51 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as cabc[m
[31m-import textwrap[m
[31m-from contextlib import contextmanager[m
[31m-[m
[31m-[m
[31m-class TextWrapper(textwrap.TextWrapper):[m
[31m-    def _handle_long_word([m
[31m-        self,[m
[31m-        reversed_chunks: list[str],[m
[31m-        cur_line: list[str],[m
[31m-        cur_len: int,[m
[31m-        width: int,[m
[31m-    ) -> None:[m
[31m-        space_left = max(width - cur_len, 1)[m
[31m-[m
[31m-        if self.break_long_words:[m
[31m-            last = reversed_chunks[-1][m
[31m-            cut = last[:space_left][m
[31m-            res = last[space_left:][m
[31m-            cur_line.append(cut)[m
[31m-            reversed_chunks[-1] = res[m
[31m-        elif not cur_line:[m
[31m-            cur_line.append(reversed_chunks.pop())[m
[31m-[m
[31m-    @contextmanager[m
[31m-    def extra_indent(self, indent: str) -> cabc.Iterator[None]:[m
[31m-        old_initial_indent = self.initial_indent[m
[31m-        old_subsequent_indent = self.subsequent_indent[m
[31m-        self.initial_indent += indent[m
[31m-        self.subsequent_indent += indent[m
[31m-[m
[31m-        try:[m
[31m-            yield[m
[31m-        finally:[m
[31m-            self.initial_indent = old_initial_indent[m
[31m-            self.subsequent_indent = old_subsequent_indent[m
[31m-[m
[31m-    def indent_only(self, text: str) -> str:[m
[31m-        rv = [][m
[31m-[m
[31m-        for idx, line in enumerate(text.splitlines()):[m
[31m-            indent = self.initial_indent[m
[31m-[m
[31m-            if idx > 0:[m
[31m-                indent = self.subsequent_indent[m
[31m-[m
[31m-            rv.append(f"{indent}{line}")[m
[31m-[m
[31m-        return "\n".join(rv)[m
[1mdiff --git a/venv/Lib/site-packages/click/_winconsole.py b/venv/Lib/site-packages/click/_winconsole.py[m
[1mdeleted file mode 100644[m
[1mindex 566dd9c..0000000[m
[1m--- a/venv/Lib/site-packages/click/_winconsole.py[m
[1m+++ /dev/null[m
[36m@@ -1,295 +0,0 @@[m
[31m-# This module is based on the excellent work by Adam Bartoš who[m
[31m-# provided a lot of what went into the implementation here in[m
[31m-# the discussion to issue1602 in the Python bug tracker.[m
[31m-#[m
[31m-# There are some general differences in regards to how this works[m
[31m-# compared to the original patches as we do not need to patch[m
[31m-# the entire interpreter but just work in our little world of[m
[31m-# echo and prompt.[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as cabc[m
[31m-import io[m
[31m-import sys[m
[31m-import time[m
[31m-import typing as t[m
[31m-from ctypes import Array[m
[31m-from ctypes import byref[m
[31m-from ctypes import c_char[m
[31m-from ctypes import c_char_p[m
[31m-from ctypes import c_int[m
[31m-from ctypes import c_ssize_t[m
[31m-from ctypes import c_ulong[m
[31m-from ctypes import c_void_p[m
[31m-from ctypes import POINTER[m
[31m-from ctypes import py_object[m
[31m-from ctypes import Structure[m
[31m-from ctypes.wintypes import DWORD[m
[31m-from ctypes.wintypes import HANDLE[m
[31m-from ctypes.wintypes import LPCWSTR[m
[31m-from ctypes.wintypes import LPWSTR[m
[31m-[m
[31m-from ._compat import _NonClosingTextIOWrapper[m
[31m-[m
[31m-assert sys.platform == "win32"[m
[31m-import msvcrt  # noqa: E402[m
[31m-from ctypes import windll  # noqa: E402[m
[31m-from ctypes import WINFUNCTYPE  # noqa: E402[m
[31m-[m
[31m-c_ssize_p = POINTER(c_ssize_t)[m
[31m-[m
[31m-kernel32 = windll.kernel32[m
[31m-GetStdHandle = kernel32.GetStdHandle[m
[31m-ReadConsoleW = kernel32.ReadConsoleW[m
[31m-WriteConsoleW = kernel32.WriteConsoleW[m
[31m-GetConsoleMode = kernel32.GetConsoleMode[m
[31m-GetLastError = kernel32.GetLastError[m
[31m-GetCommandLineW = WINFUNCTYPE(LPWSTR)(("GetCommandLineW", windll.kernel32))[m
[31m-CommandLineToArgvW = WINFUNCTYPE(POINTER(LPWSTR), LPCWSTR, POINTER(c_int))([m
[31m-    ("CommandLineToArgvW", windll.shell32)[m
[31m-)[m
[31m-LocalFree = WINFUNCTYPE(c_void_p, c_void_p)(("LocalFree", windll.kernel32))[m
[31m-[m
[31m-STDIN_HANDLE = GetStdHandle(-10)[m
[31m-STDOUT_HANDLE = GetStdHandle(-11)[m
[31m-STDERR_HANDLE = GetStdHandle(-12)[m
[31m-[m
[31m-PyBUF_SIMPLE = 0[m
[31m-PyBUF_WRITABLE = 1[m
[31m-[m
[31m-ERROR_SUCCESS = 0[m
[31m-ERROR_NOT_ENOUGH_MEMORY = 8[m
[31m-ERROR_OPERATION_ABORTED = 995[m
[31m-[m
[31m-STDIN_FILENO = 0[m
[31m-STDOUT_FILENO = 1[m
[31m-STDERR_FILENO = 2[m
[31m-[m
[31m-EOF = b"\x1a"[m
[31m-MAX_BYTES_WRITTEN = 32767[m
[31m-[m
[31m-if t.TYPE_CHECKING:[m
[31m-    try:[m
[31m-        # Using `typing_extensions.Buffer` instead of `collections.abc`[m
[31m-        # on Windows for some reason does not have `Sized` implemented.[m
[31m-        from collections.abc import Buffer  # type: ignore[m
[31m-    except ImportError:[m
[31m-        from typing_extensions import Buffer[m
[31m-[m
[31m-try:[m
[31m-    from ctypes import pythonapi[m
[31m-except ImportError:[m
[31m-    # On PyPy we cannot get buffers so our ability to operate here is[m
[31m-    # severely limited.[m
[31m-    get_buffer = None[m
[31m-else:[m
[31m-[m
[31m-    class Py_buffer(Structure):[m
[31m-        _fields_ = [  # noqa: RUF012[m
[31m-            ("buf", c_void_p),[m
[31m-            ("obj", py_object),[m
[31m-            ("len", c_ssize_t),[m
[31m-            ("itemsize", c_ssize_t),[m
[31m-            ("readonly", c_int),[m
[31m-            ("ndim", c_int),[m
[31m-            ("format", c_char_p),[m
[31m-            ("shape", c_ssize_p),[m
[31m-            ("strides", c_ssize_p),[m
[31m-            ("suboffsets", c_ssize_p),[m
[31m-            ("internal", c_void_p),[m
[31m-        ][m
[31m-[m
[31m-    PyObject_GetBuffer = pythonapi.PyObject_GetBuffer[m
[31m-    PyBuffer_Release = pythonapi.PyBuffer_Release[m
[31m-[m
[31m-    def get_buffer(obj: Buffer, writable: bool = False) -> Array[c_char]:[m
[31m-        buf = Py_buffer()[m
[31m-        flags: int = PyBUF_WRITABLE if writable else PyBUF_SIMPLE[m
[31m-        PyObject_GetBuffer(py_object(obj), byref(buf), flags)[m
[31m-[m
[31m-        try:[m
[31m-            buffer_type: Array[c_char] = c_char * buf.len[m
[31m-            return buffer_type.from_address(buf.buf)  # type: ignore[attr-defined, no-any-return][m
[31m-        finally:[m
[31m-            PyBuffer_Release(byref(buf))[m
[31m-[m
[31m-[m
[31m-class _WindowsConsoleRawIOBase(io.RawIOBase):[m
[31m-    def __init__(self, handle: int | None) -> None:[m
[31m-        self.handle = handle[m
[31m-[m
[31m-    def isatty(self) -> t.Literal[True]:[m
[31m-        super().isatty()[m
[31m-        return True[m
[31m-[m
[31m-[m
[31m-class _WindowsConsoleReader(_WindowsConsoleRawIOBase):[m
[31m-    def readable(self) -> t.Literal[True]:[m
[31m-        return True[m
[31m-[m
[31m-    def readinto(self, b: Buffer) -> int:[m
[31m-        bytes_to_be_read = len(b)[m
[31m-        if not bytes_to_be_read:[m
[31m-            return 0[m
[31m-        elif bytes_to_be_read % 2:[m
[31m-            raise ValueError([m
[31m-                "cannot read odd number of bytes from UTF-16-LE encoded console"[m
[31m-            )[m
[31m-[m
[31m-        buffer = get_buffer(b, writable=True)[m
[31m-        code_units_to_be_read = bytes_to_be_read // 2[m
[31m-        code_units_read = c_ulong()[m
[31m-[m
[31m-        rv = ReadConsoleW([m
[31m-            HANDLE(self.handle),[m
[31m-            buffer,[m
[31m-            code_units_to_be_read,[m
[31m-            byref(code_units_read),[m
[31m-            None,[m
[31m-        )[m
[31m-        if GetLastError() == ERROR_OPERATION_ABORTED:[m
[31m-            # wait for KeyboardInterrupt[m
[31m-            time.sleep(0.1)[m
[31m-        if not rv:[m
[31m-            raise OSError(f"Windows error: {GetLastError()}")[m
[31m-[m
[31m-        if buffer[0] == EOF:[m
[31m-            return 0[m
[31m-        return 2 * code_units_read.value[m
[31m-[m
[31m-[m
[31m-class _WindowsConsoleWriter(_WindowsConsoleRawIOBase):[m
[31m-    def writable(self) -> t.Literal[True]:[m
[31m-        return True[m
[31m-[m
[31m-    @staticmethod[m
[31m-    def _get_error_message(errno: int) -> str:[m
[31m-        if errno == ERROR_SUCCESS:[m
[31m-            return "ERROR_SUCCESS"[m
[31m-        elif errno == ERROR_NOT_ENOUGH_MEMORY:[m
[31m-            return "ERROR_NOT_ENOUGH_MEMORY"[m
[31m-        return f"Windows error {errno}"[m
[31m-[m
[31m-    def write(self, b: Buffer) -> int:[m
[31m-        bytes_to_be_written = len(b)[m
[31m-        buf = get_buffer(b)[m
[31m-        code_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2[m
[31m-        code_units_written = c_ulong()[m
[31m-[m
[31m-        WriteConsoleW([m
[31m-            HANDLE(self.handle),[m
[31m-            buf,[m
[31m-            code_units_to_be_written,[m
[31m-            byref(code_units_written),[m
[31m-            None,[m
[31m-        )[m
[31m-        bytes_written = 2 * code_units_written.value[m
[31m-[m
[31m-        if bytes_written == 0 and bytes_to_be_written > 0:[m
[31m-            raise OSError(self._get_error_message(GetLastError()))[m
[31m-        return bytes_written[m
[31m-[m
[31m-[m
[31m-class ConsoleStream:[m
[31m-    def __init__(self, text_stream: t.TextIO, byte_stream: t.BinaryIO) -> None:[m
[31m-        self._text_stream = text_stream[m
[31m-        self.buffer = byte_stream[m
[31m-[m
[31m-    @property[m
[31m-    def name(self) -> str:[m
[31m-        return self.buffer.name[m
[31m-[m
[31m-    def write(self, x: t.AnyStr) -> int:[m
[31m-        if isinstance(x, str):[m
[31m-            return self._text_stream.write(x)[m
[31m-        try:[m
[31m-            self.flush()[m
[31m-        except Exception:[m
[31m-            pass[m
[31m-        return self.buffer.write(x)[m
[31m-[m
[31m-    def writelines(self, lines: cabc.Iterable[t.AnyStr]) -> None:[m
[31m-        for line in lines:[m
[31m-            self.write(line)[m
[31m-[m
[31m-    def __getattr__(self, name: str) -> t.Any:[m
[31m-        return getattr(self._text_stream, name)[m
[31m-[m
[31m-    def isatty(self) -> bool:[m
[31m-        return self.buffer.isatty()[m
[31m-[m
[31m-    def __repr__(self) -> str:[m
[31m-        return f"<ConsoleStream name={self.name!r} encoding={self.encoding!r}>"[m
[31m-[m
[31m-[m
[31m-def _get_text_stdin(buffer_stream: t.BinaryIO) -> t.TextIO:[m
[31m-    text_stream = _NonClosingTextIOWrapper([m
[31m-        io.BufferedReader(_WindowsConsoleReader(STDIN_HANDLE)),[m
[31m-        "utf-16-le",[m
[31m-        "strict",[m
[31m-        line_buffering=True,[m
[31m-    )[m
[31m-    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))[m
[31m-[m
[31m-[m
[31m-def _get_text_stdout(buffer_stream: t.BinaryIO) -> t.TextIO:[m
[31m-    text_stream = _NonClosingTextIOWrapper([m
[31m-        io.BufferedWriter(_WindowsConsoleWriter(STDOUT_HANDLE)),[m
[31m-        "utf-16-le",[m
[31m-        "strict",[m
[31m-        line_buffering=True,[m
[31m-    )[m
[31m-    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))[m
[31m-[m
[31m-[m
[31m-def _get_text_stderr(buffer_stream: t.BinaryIO) -> t.TextIO:[m
[31m-    text_stream = _NonClosingTextIOWrapper([m
[31m-        io.BufferedWriter(_WindowsConsoleWriter(STDERR_HANDLE)),[m
[31m-        "utf-16-le",[m
[31m-        "strict",[m
[31m-        line_buffering=True,[m
[31m-    )[m
[31m-    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))[m
[31m-[m
[31m-[m
[31m-_stream_factories: cabc.Mapping[int, t.Callable[[t.BinaryIO], t.TextIO]] = {[m
[31m-    0: _get_text_stdin,[m
[31m-    1: _get_text_stdout,[m
[31m-    2: _get_text_stderr,[m
[31m-}[m
[31m-[m
[31m-[m
[31m-def _is_console(f: t.TextIO) -> bool:[m
[31m-    if not hasattr(f, "fileno"):[m
[31m-        return False[m
[31m-[m
[31m-    try:[m
[31m-        fileno = f.fileno()[m
[31m-    except (OSError, io.UnsupportedOperation):[m
[31m-        return False[m
[31m-[m
[31m-    handle = msvcrt.get_osfhandle(fileno)[m
[31m-    return bool(GetConsoleMode(handle, byref(DWORD())))[m
[31m-[m
[31m-[m
[31m-def _get_windows_console_stream([m
[31m-    f: t.TextIO, encoding: str | None, errors: str | None[m
[31m-) -> t.TextIO | None:[m
[31m-    if ([m
[31m-        get_buffer is None[m
[31m-        or encoding not in {"utf-16-le", None}[m
[31m-        or errors not in {"strict", None}[m
[31m-        or not _is_console(f)[m
[31m-    ):[m
[31m-        return None[m
[31m-[m
[31m-    func = _stream_factories.get(f.fileno())[m
[31m-    if func is None:[m
[31m-        return None[m
[31m-[m
[31m-    b = getattr(f, "buffer", None)[m
[31m-[m
[31m-    if b is None:[m
[31m-        return None[m
[31m-[m
[31m-    return func(b)[m
[1mdiff --git a/venv/Lib/site-packages/click/core.py b/venv/Lib/site-packages/click/core.py[m
[1mdeleted file mode 100644[m
[1mindex 4745b53..0000000[m
[1m--- a/venv/Lib/site-packages/click/core.py[m
[1m+++ /dev/null[m
[36m@@ -1,3134 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as cabc[m
[31m-import enum[m
[31m-import errno[m
[31m-import inspect[m
[31m-import os[m
[31m-import sys[m
[31m-import typing as t[m
[31m-from collections import abc[m
[31m-from collections import Counter[m
[31m-from contextlib import AbstractContextManager[m
[31m-from contextlib import contextmanager[m
[31m-from contextlib import ExitStack[m
[31m-from functools import update_wrapper[m
[31m-from gettext import gettext as _[m
[31m-from gettext import ngettext[m
[31m-from itertools import repeat[m
[31m-from types import TracebackType[m
[31m-[m
[31m-from . import types[m
[31m-from .exceptions import Abort[m
[31m-from .exceptions import BadParameter[m
[31m-from .exceptions import ClickException[m
[31m-from .exceptions import Exit[m
[31m-from .exceptions import MissingParameter[m
[31m-from .exceptions import NoArgsIsHelpError[m
[31m-from .exceptions import UsageError[m
[31m-from .formatting import HelpFormatter[m
[31m-from .formatting import join_options[m
[31m-from .globals import pop_context[m
[31m-from .globals import push_context[m
[31m-from .parser import _flag_needs_value[m
[31m-from .parser import _OptionParser[m
[31m-from .parser import _split_opt[m
[31m-from .termui import confirm[m
[31m-from .termui import prompt[m
[31m-from .termui import style[m
[31m-from .utils import _detect_program_name[m
[31m-from .utils import _expand_args[m
[31m-from .utils import echo[m
[31m-from .utils import make_default_short_help[m
[31m-from .utils import make_str[m
[31m-from .utils import PacifyFlushWrapper[m
[31m-[m
[31m-if t.TYPE_CHECKING:[m
[31m-    from .shell_completion import CompletionItem[m
[31m-[m
[31m-F = t.TypeVar("F", bound="t.Callable[..., t.Any]")[m
[31m-V = t.TypeVar("V")[m
[31m-[m
[31m-[m
[31m-def _complete_visible_commands([m
[31m-    ctx: Context, incomplete: str[m
[31m-) -> cabc.Iterator[tuple[str, Command]]:[m
[31m-    """List all the subcommands of a group that start with the[m
[31m-    incomplete value and aren't hidden.[m
[31m-[m
[31m-    :param ctx: Invocation context for the group.[m
[31m-    :param incomplete: Value being completed. May be empty.[m
[31m-    """[m
[31m-    multi = t.cast(Group, ctx.command)[m
[31m-[m
[31m-    for name in multi.list_commands(ctx):[m
[31m-        if name.startswith(incomplete):[m
[31m-            command = multi.get_command(ctx, name)[m
[31m-[m
[31m-            if command is not None and not command.hidden:[m
[31m-                yield name, command[m
[31m-[m
[31m-[m
[31m-def _check_nested_chain([m
[31m-    base_command: Group, cmd_name: str, cmd: Command, register: bool = False[m
[31m-) -> None:[m
[31m-    if not base_command.chain or not isinstance(cmd, Group):[m
[31m-        return[m
[31m-[m
[31m-    if register:[m
[31m-        message = ([m
[31m-            f"It is not possible to add the group {cmd_name!r} to another"[m
[31m-            f" group {base_command.name!r} that is in chain mode."[m
[31m-        )[m
[31m-    else:[m
[31m-        message = ([m
[31m-            f"Found the group {cmd_name!r} as subcommand to another group "[m
[31m-            f" {base_command.name!r} that is in chain mode. This is not supported."[m
[31m-        )[m
[31m-[m
[31m-    raise RuntimeError(message)[m
[31m-[m
[31m-[m
[31m-def batch(iterable: cabc.Iterable[V], batch_size: int) -> list[tuple[V, ...]]:[m
[31m-    return list(zip(*repeat(iter(iterable), batch_size), strict=False))[m
[31m-[m
[31m-[m
[31m-@contextmanager[m
[31m-def augment_usage_errors([m
[31m-    ctx: Context, param: Parameter | None = None[m
[31m-) -> cabc.Iterator[None]:[m
[31m-    """Context manager that attaches extra information to exceptions."""[m
[31m-    try:[m
[31m-        yield[m
[31m-    except BadParameter as e:[m
[31m-        if e.ctx is None:[m
[31m-            e.ctx = ctx[m
[31m-        if param is not None and e.param is None:[m
[31m-            e.param = param[m
[31m-        raise[m
[31m-    except UsageError as e:[m
[31m-        if e.ctx is None:[m
[31m-            e.ctx = ctx[m
[31m-        raise[m
[31m-[m
[31m-[m
[31m-def iter_params_for_processing([m
[31m-    invocation_order: cabc.Sequence[Parameter],[m
[31m-    declaration_order: cabc.Sequence[Parameter],[m
[31m-) -> list[Parameter]:[m
[31m-    """Returns all declared parameters in the order they should be processed.[m
[31m-[m
[31m-    The declared parameters are re-shuffled depending on the order in which[m
[31m-    they were invoked, as well as the eagerness of each parameters.[m
[31m-[m
[31m-    The invocation order takes precedence over the declaration order. I.e. the[m
[31m-    order in which the user provided them to the CLI is respected.[m
[31m-[m
[31m-    This behavior and its effect on callback evaluation is detailed at:[m
[31m-    https://click.palletsprojects.com/en/stable/advanced/#callback-evaluation-order[m
[31m-    """[m
[31m-[m
[31m-    def sort_key(item: Parameter) -> tuple[bool, float]:[m
[31m-        try:[m
[31m-            idx: float = invocation_order.index(item)[m
[31m-        except ValueError:[m
[31m-            idx = float("inf")[m
[31m-[m
[31m-        return not item.is_eager, idx[m
[31m-[m
[31m-    return sorted(declaration_order, key=sort_key)[m
[31m-[m
[31m-[m
[31m-class ParameterSource(enum.Enum):[m
[31m-    """This is an :class:`~enum.Enum` that indicates the source of a[m
[31m-    parameter's value.[m
[31m-[m
[31m-    Use :meth:`click.Context.get_parameter_source` to get the[m
[31m-    source for a parameter by name.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        Use :class:`~enum.Enum` and drop the ``validate`` method.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        Added the ``PROMPT`` value.[m
[31m-    """[m
[31m-[m
[31m-    COMMANDLINE = enum.auto()[m
[31m-    """The value was provided by the command line args."""[m
[31m-    ENVIRONMENT = enum.auto()[m
[31m-    """The value was provided with an environment variable."""[m
[31m-    DEFAULT = enum.auto()[m
[31m-    """Used the default specified by the parameter."""[m
[31m-    DEFAULT_MAP = enum.auto()[m
[31m-    """Used a default provided by :attr:`Context.default_map`."""[m
[31m-    PROMPT = enum.auto()[m
[31m-    """Used a prompt to confirm a default or provide a value."""[m
[31m-[m
[31m-[m
[31m-class Context:[m
[31m-    """The context is a special internal object that holds state relevant[m
[31m-    for the script execution at every single level.  It's normally invisible[m
[31m-    to commands unless they opt-in to getting access to it.[m
[31m-[m
[31m-    The context is useful as it can pass internal objects around and can[m
[31m-    control special execution features such as reading data from[m
[31m-    environment variables.[m
[31m-[m
[31m-    A context can be used as context manager in which case it will call[m
[31m-    :meth:`close` on teardown.[m
[31m-[m
[31m-    :param command: the command class for this context.[m
[31m-    :param parent: the parent context.[m
[31m-    :param info_name: the info name for this invocation.  Generally this[m
[31m-                      is the most descriptive name for the script or[m
[31m-                      command.  For the toplevel script it is usually[m
[31m-                      the name of the script, for commands below it it's[m
[31m-                      the name of the script.[m
[31m-    :param obj: an arbitrary object of user data.[m
[31m-    :param auto_envvar_prefix: the prefix to use for automatic environment[m
[31m-                               variables.  If this is `None` then reading[m
[31m-                               from environment variables is disabled.  This[m
[31m-                               does not affect manually set environment[m
[31m-                               variables which are always read.[m
[31m-    :param default_map: a dictionary (like object) with default values[m
[31m-                        for parameters.[m
[31m-    :param terminal_width: the width of the terminal.  The default is[m
[31m-                           inherit from parent context.  If no context[m
[31m-                           defines the terminal width then auto[m
[31m-                           detection will be applied.[m
[31m-    :param max_content_width: the maximum width for content rendered by[m
[31m-                              Click (this currently only affects help[m
[31m-                              pages).  This defaults to 80 characters if[m
[31m-                              not overridden.  In other words: even if the[m
[31m-                              terminal is larger than that, Click will not[m
[31m-                              format things wider than 80 characters by[m
[31m-                              default.  In addition to that, formatters might[m
[31m-                              add some safety mapping on the right.[m
[31m-    :param resilient_parsing: if this flag is enabled then Click will[m
[31m-                              parse without any interactivity or callback[m
[31m-                              invocation.  Default values will also be[m
[31m-                              ignored.  This is useful for implementing[m
[31m-                              things such as completion support.[m
[31m-    :param allow_extra_args: if this is set to `True` then extra arguments[m
[31m-                             at the end will not raise an error and will be[m
[31m-                             kept on the context.  The default is to inherit[m
[31m-                             from the command.[m
[31m-    :param allow_interspersed_args: if this is set to `False` then options[m
[31m-                                    and arguments cannot be mixed.  The[m
[31m-                                    default is to inherit from the command.[m
[31m-    :param ignore_unknown_options: instructs click to ignore options it does[m
[31m-                                   not know and keeps them for later[m
[31m-                                   processing.[m
[31m-    :param help_option_names: optionally a list of strings that define how[m
[31m-                              the default help parameter is named.  The[m
[31m-                              default is ``['--help']``.[m
[31m-    :param token_normalize_func: an optional function that is used to[m
[31m-                                 normalize tokens (options, choices,[m
[31m-                                 etc.).  This for instance can be used to[m
[31m-                                 implement case insensitive behavior.[m
[31m-    :param color: controls if the terminal supports ANSI colors or not.  The[m
[31m-                  default is autodetection.  This is only needed if ANSI[m
[31m-                  codes are used in texts that Click prints which is by[m
[31m-                  default not the case.  This for instance would affect[m
[31m-                  help output.[m
[31m-    :param show_default: Show the default value for commands. If this[m
[31m-        value is not set, it defaults to the value from the parent[m
[31m-        context. ``Command.show_default`` overrides this default for the[m
[31m-        specific command.[m
[31m-[m
[31m-    .. versionchanged:: 8.2[m
[31m-        The ``protected_args`` attribute is deprecated and will be removed in[m
[31m-        Click 9.0. ``args`` will contain remaining unparsed tokens.[m
[31m-[m
[31m-    .. versionchanged:: 8.1[m
[31m-        The ``show_default`` parameter is overridden by[m
[31m-        ``Command.show_default``, instead of the other way around.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        The ``show_default`` parameter defaults to the value from the[m
[31m-        parent context.[m
[31m-[m
[31m-    .. versionchanged:: 7.1[m
[31m-       Added the ``show_default`` parameter.[m
[31m-[m
[31m-    .. versionchanged:: 4.0[m
[31m-        Added the ``color``, ``ignore_unknown_options``, and[m
[31m-        ``max_content_width`` parameters.[m
[31m-[m
[31m-    .. versionchanged:: 3.0[m
[31m-        Added the ``allow_extra_args`` and ``allow_interspersed_args``[m
[31m-        parameters.[m
[31m-[m
[31m-    .. versionchanged:: 2.0[m
[31m-        Added the ``resilient_parsing``, ``help_option_names``, and[m
[31m-        ``token_normalize_func`` parameters.[m
[31m-    """[m
[31m-[m
[31m-    #: The formatter class to create with :meth:`make_formatter`.[m
[31m-    #:[m
[31m-    #: .. versionadded:: 8.0[m
[31m-    formatter_class: type[HelpFormatter] = HelpFormatter[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        command: Command,[m
[31m-        parent: Context | None = None,[m
[31m-        info_name: str | None = None,[m
[31m-        obj: t.Any | None = None,[m
[31m-        auto_envvar_prefix: str | None = None,[m
[31m-        default_map: cabc.MutableMapping[str, t.Any] | None = None,[m
[31m-        terminal_width: int | None = None,[m
[31m-        max_content_width: int | None = None,[m
[31m-        resilient_parsing: bool = False,[m
[31m-        allow_extra_args: bool | None = None,[m
[31m-        allow_interspersed_args: bool | None = None,[m
[31m-        ignore_unknown_options: bool | None = None,[m
[31m-        help_option_names: list[str] | None = None,[m
[31m-        token_normalize_func: t.Callable[[str], str] | None = None,[m
[31m-        color: bool | None = None,[m
[31m-        show_default: bool | None = None,[m
[31m-    ) -> None:[m
[31m-        #: the parent context or `None` if none exists.[m
[31m-        self.parent = parent[m
[31m-        #: the :class:`Command` for this context.[m
[31m-        self.command = command[m
[31m-        #: the descriptive information name[m
[31m-        self.info_name = info_name[m
[31m-        #: Map of parameter names to their parsed values. Parameters[m
[31m-        #: with ``expose_value=False`` are not stored.[m
[31m-        self.params: dict[str, t.Any] = {}[m
[31m-        #: the leftover arguments.[m
[31m-        self.args: list[str] = [][m
[31m-        #: protected arguments.  These are arguments that are prepended[m
[31m-        #: to `args` when certain parsing scenarios are encountered but[m
[31m-        #: must be never propagated to another arguments.  This is used[m
[31m-        #: to implement nested parsing.[m
[31m-        self._protected_args: list[str] = [][m
[31m-        #: the collected prefixes of the command's options.[m
[31m-        self._opt_prefixes: set[str] = set(parent._opt_prefixes) if parent else set()[m
[31m-[m
[31m-        if obj is None and parent is not None:[m
[31m-            obj = parent.obj[m
[31m-[m
[31m-        #: the user object stored.[m
[31m-        self.obj: t.Any = obj[m
[31m-        self._meta: dict[str, t.Any] = getattr(parent, "meta", {})[m
[31m-[m
[31m-        #: A dictionary (-like object) with defaults for parameters.[m
[31m-        if ([m
[31m-            default_map is None[m
[31m-            and info_name is not None[m
[31m-            and parent is not None[m
[31m-            and parent.default_map is not None[m
[31m-        ):[m
[31m-            default_map = parent.default_map.get(info_name)[m
[31m-[m
[31m-        self.default_map: cabc.MutableMapping[str, t.Any] | None = default_map[m
[31m-[m
[31m-        #: This flag indicates if a subcommand is going to be executed. A[m
[31m-        #: group callback can use this information to figure out if it's[m
[31m-        #: being executed directly or because the execution flow passes[m
[31m-        #: onwards to a subcommand. By default it's None, but it can be[m
[31m-        #: the name of the subcommand to execute.[m
[31m-        #:[m
[31m-        #: If chaining is enabled this will be set to ``'*'`` in case[m
[31m-        #: any commands are executed.  It is however not possible to[m
[31m-        #: figure out which ones.  If you require this knowledge you[m
[31m-        #: should use a :func:`result_callback`.[m
[31m-        self.invoked_subcommand: str | None = None[m
[31m-[m
[31m-        if terminal_width is None and parent is not None:[m
[31m-            terminal_width = parent.terminal_width[m
[31m-[m
[31m-        #: The width of the terminal (None is autodetection).[m
[31m-        self.terminal_width: int | None = terminal_width[m
[31m-[m
[31m-        if max_content_width is None and parent is not None:[m
[31m-            max_content_width = parent.max_content_width[m
[31m-[m
[31m-        #: The maximum width of formatted content (None implies a sensible[m
[31m-        #: default which is 80 for most things).[m
[31m-        self.max_content_width: int | None = max_content_width[m
[31m-[m
[31m-        if allow_extra_args is None:[m
[31m-            allow_extra_args = command.allow_extra_args[m
[31m-[m
[31m-        #: Indicates if the context allows extra args or if it should[m
[31m-        #: fail on parsing.[m
[31m-        #:[m
[31m-        #: .. versionadded:: 3.0[m
[31m-        self.allow_extra_args = allow_extra_args[m
[31m-[m
[31m-        if allow_interspersed_args is None:[m
[31m-            allow_interspersed_args = command.allow_interspersed_args[m
[31m-[m
[31m-        #: Indicates if the context allows mixing of arguments and[m
[31m-        #: options or not.[m
[31m-        #:[m
[31m-        #: .. versionadded:: 3.0[m
[31m-        self.allow_interspersed_args: bool = allow_interspersed_args[m
[31m-[m
[31m-        if ignore_unknown_options is None:[m
[31m-            ignore_unknown_options = command.ignore_unknown_options[m
[31m-[m
[31m-        #: Instructs click to ignore options that a command does not[m
[31m-        #: understand and will store it on the context for later[m
[31m-        #: processing.  This is primarily useful for situations where you[m
[31m-        #: want to call into external programs.  Generally this pattern is[m
[31m-        #: strongly discouraged because it's not possibly to losslessly[m
[31m-        #: forward all arguments.[m
[31m-        #:[m
[31m-        #: .. versionadded:: 4.0[m
[31m-        self.ignore_unknown_options: bool = ignore_unknown_options[m
[31m-[m
[31m-        if help_option_names is None:[m
[31m-            if parent is not None:[m
[31m-                help_option_names = parent.help_option_names[m
[31m-            else:[m
[31m-                help_option_names = ["--help"][m
[31m-[m
[31m-        #: The names for the help options.[m
[31m-        self.help_option_names: list[str] = help_option_names[m
[31m-[m
[31m-        if token_normalize_func is None and parent is not None:[m
[31m-            token_normalize_func = parent.token_normalize_func[m
[31m-[m
[31m-        #: An optional normalization function for tokens.  This is[m
[31m-        #: options, choices, commands etc.[m
[31m-        self.token_normalize_func: t.Callable[[str], str] | None = token_normalize_func[m
[31m-[m
[31m-        #: Indicates if resilient parsing is enabled.  In that case Click[m
[31m-        #: will do its best to not cause any failures and default values[m
[31m-        #: will be ignored. Useful for completion.[m
[31m-        self.resilient_parsing: bool = resilient_parsing[m
[31m-[m
[31m-        # If there is no envvar prefix yet, but the parent has one and[m
[31m-        # the command on this level has a name, we can expand the envvar[m
[31m-        # prefix automatically.[m
[31m-        if auto_envvar_prefix is None:[m
[31m-            if ([m
[31m-                parent is not None[m
[31m-                and parent.auto_envvar_prefix is not None[m
[31m-                and self.info_name is not None[m
[31m-            ):[m
[31m-                auto_envvar_prefix = ([m
[31m-                    f"{parent.auto_envvar_prefix}_{self.info_name.upper()}"[m
[31m-                )[m
[31m-        else:[m
[31m-            auto_envvar_prefix = auto_envvar_prefix.upper()[m
[31m-[m
[31m-        if auto_envvar_prefix is not None:[m
[31m-            auto_envvar_prefix = auto_envvar_prefix.replace("-", "_")[m
[31m-[m
[31m-        self.auto_envvar_prefix: str | None = auto_envvar_prefix[m
[31m-[m
[31m-        if color is None and parent is not None:[m
[31m-            color = parent.color[m
[31m-[m
[31m-        #: Controls if styling output is wanted or not.[m
[31m-        self.color: bool | None = color[m
[31m-[m
[31m-        if show_default is None and parent is not None:[m
[31m-            show_default = parent.show_default[m
[31m-[m
[31m-        #: Show option default values when formatting help text.[m
[31m-        self.show_default: bool | None = show_default[m
[31m-[m
[31m-        self._close_callbacks: list[t.Callable[[], t.Any]] = [][m
[31m-        self._depth = 0[m
[31m-        self._parameter_source: dict[str, ParameterSource] = {}[m
[31m-        self._exit_stack = ExitStack()[m
[31m-[m
[31m-    @property[m
[31m-    def protected_args(self) -> list[str]:[m
[31m-        import warnings[m
[31m-[m
[31m-        warnings.warn([m
[31m-            "'protected_args' is deprecated and will be removed in Click 9.0."[m
[31m-            " 'args' will contain remaining unparsed tokens.",[m
[31m-            DeprecationWarning,[m
[31m-            stacklevel=2,[m
[31m-        )[m
[31m-        return self._protected_args[m
[31m-[m
[31m-    def to_info_dict(self) -> dict[str, t.Any]:[m
[31m-        """Gather information that could be useful for a tool generating[m
[31m-        user-facing documentation. This traverses the entire CLI[m
[31m-        structure.[m
[31m-[m
[31m-        .. code-block:: python[m
[31m-[m
[31m-            with Context(cli) as ctx:[m
[31m-                info = ctx.to_info_dict()[m
[31m-[m
[31m-        .. versionadded:: 8.0[m
[31m-        """[m
[31m-        return {[m
[31m-            "command": self.command.to_info_dict(self),[m
[31m-            "info_name": self.info_name,[m
[31m-            "allow_extra_args": self.allow_extra_args,[m
[31m-            "allow_interspersed_args": self.allow_interspersed_args,[m
[31m-            "ignore_unknown_options": self.ignore_unknown_options,[m
[31m-            "auto_envvar_prefix": self.auto_envvar_prefix,[m
[31m-        }[m
[31m-[m
[31m-    def __enter__(self) -> Context:[m
[31m-        self._depth += 1[m
[31m-        push_context(self)[m
[31m-        return self[m
[31m-[m
[31m-    def __exit__([m
[31m-        self,[m
[31m-        exc_type: type[BaseException] | None,[m
[31m-        exc_value: BaseException | None,[m
[31m-        tb: TracebackType | None,[m
[31m-    ) -> None:[m
[31m-        self._depth -= 1[m
[31m-        if self._depth == 0:[m
[31m-            self.close()[m
[31m-        pop_context()[m
[31m-[m
[31m-    @contextmanager[m
[31m-    def scope(self, cleanup: bool = True) -> cabc.Iterator[Context]:[m
[31m-        """This helper method can be used with the context object to promote[m
[31m-        it to the current thread local (see :func:`get_current_context`).[m
[31m-        The default behavior of this is to invoke the cleanup functions which[m
[31m-        can be disabled by setting `cleanup` to `False`.  The cleanup[m
[31m-        functions are typically used for things such as closing file handles.[m
[31m-[m
[31m-        If the cleanup is intended the context object can also be directly[m
[31m-        used as a context manager.[m
[31m-[m
[31m-        Example usage::[m
[31m-[m
[31m-            with ctx.scope():[m
[31m-                assert get_current_context() is ctx[m
[31m-[m
[31m-        This is equivalent::[m
[31m-[m
[31m-            with ctx:[m
[31m-                assert get_current_context() is ctx[m
[31m-[m
[31m-        .. versionadded:: 5.0[m
[31m-[m
[31m-        :param cleanup: controls if the cleanup functions should be run or[m
[31m-                        not.  The default is to run these functions.  In[m
[31m-                        some situations the context only wants to be[m
[31m-                        temporarily pushed in which case this can be disabled.[m
[31m-                        Nested pushes automatically defer the cleanup.[m
[31m-        """[m
[31m-        if not cleanup:[m
[31m-            self._depth += 1[m
[31m-        try:[m
[31m-            with self as rv:[m
[31m-                yield rv[m
[31m-        finally:[m
[31m-            if not cleanup:[m
[31m-                self._depth -= 1[m
[31m-[m
[31m-    @property[m
[31m-    def meta(self) -> dict[str, t.Any]:[m
[31m-        """This is a dictionary which is shared with all the contexts[m
[31m-        that are nested.  It exists so that click utilities can store some[m
[31m-        state here if they need to.  It is however the responsibility of[m
[31m-        that code to manage this dictionary well.[m
[31m-[m
[31m-        The keys are supposed to be unique dotted strings.  For instance[m
[31m-        module paths are a good choice for it.  What is stored in there is[m
[31m-        irrelevant for the operation of click.  However what is important is[m
[31m-        that code that places data here adheres to the general semantics of[m
[31m-        the system.[m
[31m-[m
[31m-        Example usage::[m
[31m-[m
[31m-            LANG_KEY = f'{__name__}.lang'[m
[31m-[m
[31m-            def set_language(value):[m
[31m-                ctx = get_current_context()[m
[31m-                ctx.meta[LANG_KEY] = value[m
[31m-[m
[31m-            def get_language():[m
[31m-                return get_current_context().meta.get(LANG_KEY, 'en_US')[m
[31m-[m
[31m-        .. versionadded:: 5.0[m
[31m-        """[m
[31m-        return self._meta[m
[31m-[m
[31m-    def make_formatter(self) -> HelpFormatter:[m
[31m-        """Creates the :class:`~click.HelpFormatter` for the help and[m
[31m-        usage output.[m
[31m-[m
[31m-        To quickly customize the formatter class used without overriding[m
[31m-        this method, set the :attr:`formatter_class` attribute.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Added the :attr:`formatter_class` attribute.[m
[31m-        """[m
[31m-        return self.formatter_class([m
[31m-            width=self.terminal_width, max_width=self.max_content_width[m
[31m-        )[m
[31m-[m
[31m-    def with_resource(self, context_manager: AbstractContextManager[V]) -> V:[m
[31m-        """Register a resource as if it were used in a ``with``[m
[31m-        statement. The resource will be cleaned up when the context is[m
[31m-        popped.[m
[31m-[m
[31m-        Uses :meth:`contextlib.ExitStack.enter_context`. It calls the[m
[31m-        resource's ``__enter__()`` method and returns the result. When[m
[31m-        the context is popped, it closes the stack, which calls the[m
[31m-        resource's ``__exit__()`` method.[m
[31m-[m
[31m-        To register a cleanup function for something that isn't a[m
[31m-        context manager, use :meth:`call_on_close`. Or use something[m
[31m-        from :mod:`contextlib` to turn it into a context manager first.[m
[31m-[m
[31m-        .. code-block:: python[m
[31m-[m
[31m-            @click.group()[m
[31m-            @click.option("--name")[m
[31m-            @click.pass_context[m
[31m-            def cli(ctx):[m
[31m-                ctx.obj = ctx.with_resource(connect_db(name))[m
[31m-[m
[31m-        :param context_manager: The context manager to enter.[m
[31m-        :return: Whatever ``context_manager.__enter__()`` returns.[m
[31m-[m
[31m-        .. versionadded:: 8.0[m
[31m-        """[m
[31m-        return self._exit_stack.enter_context(context_manager)[m
[31m-[m
[31m-    def call_on_close(self, f: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:[m
[31m-        """Register a function to be called when the context tears down.[m
[31m-[m
[31m-        This can be used to close resources opened during the script[m
[31m-        execution. Resources that support Python's context manager[m
[31m-        protocol which would be used in a ``with`` statement should be[m
[31m-        registered with :meth:`with_resource` instead.[m
[31m-[m
[31m-        :param f: The function to execute on teardown.[m
[31m-        """[m
[31m-        return self._exit_stack.callback(f)[m
[31m-[m
[31m-    def close(self) -> None:[m
[31m-        """Invoke all close callbacks registered with[m
[31m-        :meth:`call_on_close`, and exit all context managers entered[m
[31m-        with :meth:`with_resource`.[m
[31m-        """[m
[31m-        self._exit_stack.close()[m
[31m-        # In case the context is reused, create a new exit stack.[m
[31m-        self._exit_stack = ExitStack()[m
[31m-[m
[31m-    @property[m
[31m-    def command_path(self) -> str:[m
[31m-        """The computed command path.  This is used for the ``usage``[m
[31m-        information on the help page.  It's automatically created by[m
[31m-        combining the info names of the chain of contexts to the root.[m
[31m-        """[m
[31m-        rv = ""[m
[31m-        if self.info_name is not None:[m
[31m-            rv = self.info_name[m
[31m-        if self.parent is not None:[m
[31m-            parent_command_path = [self.parent.command_path][m
[31m-[m
[31m-            if isinstance(self.parent.command, Command):[m
[31m-                for param in self.parent.command.get_params(self):[m
[31m-                    parent_command_path.extend(param.get_usage_pieces(self))[m
[31m-[m
[31m-            rv = f"{' '.join(parent_command_path)} {rv}"[m
[31m-        return rv.lstrip()[m
[31m-[m
[31m-    def find_root(self) -> Context:[m
[31m-        """Finds the outermost context."""[m
[31m-        node = self[m
[31m-        while node.parent is not None:[m
[31m-            node = node.parent[m
[31m-        return node[m
[31m-[m
[31m-    def find_object(self, object_type: type[V]) -> V | None:[m
[31m-        """Finds the closest object of a given type."""[m
[31m-        node: Context | None = self[m
[31m-[m
[31m-        while node is not None:[m
[31m-            if isinstance(node.obj, object_type):[m
[31m-                return node.obj[m
[31m-[m
[31m-            node = node.parent[m
[31m-[m
[31m-        return None[m
[31m-[m
[31m-    def ensure_object(self, object_type: type[V]) -> V:[m
[31m-        """Like :meth:`find_object` but sets the innermost object to a[m
[31m-        new instance of `object_type` if it does not exist.[m
[31m-        """[m
[31m-        rv = self.find_object(object_type)[m
[31m-        if rv is None:[m
[31m-            self.obj = rv = object_type()[m
[31m-        return rv[m
[31m-[m
[31m-    @t.overload[m
[31m-    def lookup_default([m
[31m-        self, name: str, call: t.Literal[True] = True[m
[31m-    ) -> t.Any | None: ...[m
[31m-[m
[31m-    @t.overload[m
[31m-    def lookup_default([m
[31m-        self, name: str, call: t.Literal[False] = ...[m
[31m-    ) -> t.Any | t.Callable[[], t.Any] | None: ...[m
[31m-[m
[31m-    def lookup_default(self, name: str, call: bool = True) -> t.Any | None:[m
[31m-        """Get the default for a parameter from :attr:`default_map`.[m
[31m-[m
[31m-        :param name: Name of the parameter.[m
[31m-        :param call: If the default is a callable, call it. Disable to[m
[31m-            return the callable instead.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Added the ``call`` parameter.[m
[31m-        """[m
[31m-        if self.default_map is not None:[m
[31m-            value = self.default_map.get(name)[m
[31m-[m
[31m-            if call and callable(value):[m
[31m-                return value()[m
[31m-[m
[31m-            return value[m
[31m-[m
[31m-        return None[m
[31m-[m
[31m-    def fail(self, message: str) -> t.NoReturn:[m
[31m-        """Aborts the execution of the program with a specific error[m
[31m-        message.[m
[31m-[m
[31m-        :param message: the error message to fail with.[m
[31m-        """[m
[31m-        raise UsageError(message, self)[m
[31m-[m
[31m-    def abort(self) -> t.NoReturn:[m
[31m-        """Aborts the script."""[m
[31m-        raise Abort()[m
[31m-[m
[31m-    def exit(self, code: int = 0) -> t.NoReturn:[m
[31m-        """Exits the application with a given exit code.[m
[31m-[m
[31m-        .. versionchanged:: 8.2[m
[31m-            Callbacks and context managers registered with :meth:`call_on_close`[m
[31m-            and :meth:`with_resource` are closed before exiting.[m
[31m-        """[m
[31m-        self.close()[m
[31m-        raise Exit(code)[m
[31m-[m
[31m-    def get_usage(self) -> str:[m
[31m-        """Helper method to get formatted usage string for the current[m
[31m-        context and command.[m
[31m-        """[m
[31m-        return self.command.get_usage(self)[m
[31m-[m
[31m-    def get_help(self) -> str:[m
[31m-        """Helper method to get formatted help page for the current[m
[31m-        context and command.[m
[31m-        """[m
[31m-        return self.command.get_help(self)[m
[31m-[m
[31m-    def _make_sub_context(self, command: Command) -> Context:[m
[31m-        """Create a new context of the same type as this context, but[m
[31m-        for a new command.[m
[31m-[m
[31m-        :meta private:[m
[31m-        """[m
[31m-        return type(self)(command, info_name=command.name, parent=self)[m
[31m-[m
[31m-    @t.overload[m
[31m-    def invoke([m
[31m-        self, callback: t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any[m
[31m-    ) -> V: ...[m
[31m-[m
[31m-    @t.overload[m
[31m-    def invoke(self, callback: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any: ...[m
[31m-[m
[31m-    def invoke([m
[31m-        self, callback: Command | t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any[m
[31m-    ) -> t.Any | V:[m
[31m-        """Invokes a command callback in exactly the way it expects.  There[m
[31m-        are two ways to invoke this method:[m
[31m-[m
[31m-        1.  the first argument can be a callback and all other arguments and[m
[31m-            keyword arguments are forwarded directly to the function.[m
[31m-        2.  the first argument is a click command object.  In that case all[m
[31m-            arguments are forwarded as well but proper click parameters[m
[31m-            (options and click arguments) must be keyword arguments and Click[m
[31m-            will fill in defaults.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            All ``kwargs`` are tracked in :attr:`params` so they will be[m
[31m-            passed if :meth:`forward` is called at multiple levels.[m
[31m-[m
[31m-        .. versionchanged:: 3.2[m
[31m-            A new context is created, and missing arguments use default values.[m
[31m-        """[m
[31m-        if isinstance(callback, Command):[m
[31m-            other_cmd = callback[m
[31m-[m
[31m-            if other_cmd.callback is None:[m
[31m-                raise TypeError([m
[31m-                    "The given command does not have a callback that can be invoked."[m
[31m-                )[m
[31m-            else:[m
[31m-                callback = t.cast("t.Callable[..., V]", other_cmd.callback)[m
[31m-[m
[31m-            ctx = self._make_sub_context(other_cmd)[m
[31m-[m
[31m-            for param in other_cmd.params:[m
[31m-                if param.name not in kwargs and param.expose_value:[m
[31m-                    kwargs[param.name] = param.type_cast_value(  # type: ignore[m
[31m-                        ctx, param.get_default(ctx)[m
[31m-                    )[m
[31m-[m
[31m-            # Track all kwargs as params, so that forward() will pass[m
[31m-            # them on in subsequent calls.[m
[31m-            ctx.params.update(kwargs)[m
[31m-        else:[m
[31m-            ctx = self[m
[31m-[m
[31m-        with augment_usage_errors(self):[m
[31m-            with ctx:[m
[31m-                return callback(*args, **kwargs)[m
[31m-[m
[31m-    def forward(self, cmd: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any:[m
[31m-        """Similar to :meth:`invoke` but fills in default keyword[m
[31m-        arguments from the current context if the other command expects[m
[31m-        it.  This cannot invoke callbacks directly, only other commands.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            All ``kwargs`` are tracked in :attr:`params` so they will be[m
[31m-            passed if ``forward`` is called at multiple levels.[m
[31m-        """[m
[31m-        # Can only forward to other commands, not direct callbacks.[m
[31m-        if not isinstance(cmd, Command):[m
[31m-            raise TypeError("Callback is not a command.")[m
[31m-[m
[31m-        for param in self.params:[m
[31m-            if param not in kwargs:[m
[31m-                kwargs[param] = self.params[param][m
[31m-[m
[31m-        return self.invoke(cmd, *args, **kwargs)[m
[31m-[m
[31m-    def set_parameter_source(self, name: str, source: ParameterSource) -> None:[m
[31m-        """Set the source of a parameter. This indicates the location[m
[31m-        from which the value of the parameter was obtained.[m
[31m-[m
[31m-        :param name: The name of the parameter.[m
[31m-        :param source: A member of :class:`~click.core.ParameterSource`.[m
[31m-        """[m
[31m-        self._parameter_source[name] = source[m
[31m-[m
[31m-    def get_parameter_source(self, name: str) -> ParameterSource | None:[m
[31m-        """Get the source of a parameter. This indicates the location[m
[31m-        from which the value of the parameter was obtained.[m
[31m-[m
[31m-        This can be useful for determining when a user specified a value[m
[31m-        on the command line that is the same as the default value. It[m
[31m-        will be :attr:`~click.core.ParameterSource.DEFAULT` only if the[m
[31m-        value was actually taken from the default.[m
[31m-[m
[31m-        :param name: The name of the parameter.[m
[31m-        :rtype: ParameterSource[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Returns ``None`` if the parameter was not provided from any[m
[31m-            source.[m
[31m-        """[m
[31m-        return self._parameter_source.get(name)[m
[31m-[m
[31m-[m
[31m-class Command:[m
[31m-    """Commands are the basic building block of command line interfaces in[m
[31m-    Click.  A basic command handles command line parsing and might dispatch[m
[31m-    more parsing to commands nested below it.[m
[31m-[m
[31m-    :param name: the name of the command to use unless a group overrides it.[m
[31m-    :param context_settings: an optional dictionary with defaults that are[m
[31m-                             passed to the context object.[m
[31m-    :param callback: the callback to invoke.  This is optional.[m
[31m-    :param params: the parameters to register with this command.  This can[m
[31m-                   be either :class:`Option` or :class:`Argument` objects.[m
[31m-    :param help: the help string to use for this command.[m
[31m-    :param epilog: like the help string but it's printed at the end of the[m
[31m-                   help page after everything else.[m
[31m-    :param short_help: the short help to use for this command.  This is[m
[31m-                       shown on the command listing of the parent command.[m
[31m-    :param add_help_option: by default each command registers a ``--help``[m
[31m-                            option.  This can be disabled by this parameter.[m
[31m-    :param no_args_is_help: this controls what happens if no arguments are[m
[31m-                            provided.  This option is disabled by default.[m
[31m-                            If enabled this will add ``--help`` as argument[m
[31m-                            if no arguments are passed[m
[31m-    :param hidden: hide this command from help outputs.[m
[31m-    :param deprecated: If ``True`` or non-empty string, issues a message[m
[31m-                        indicating that the command is deprecated and highlights[m
[31m-                        its deprecation in --help. The message can be customized[m
[31m-                        by using a string as the value.[m
[31m-[m
[31m-    .. versionchanged:: 8.2[m
[31m-        This is the base class for all commands, not ``BaseCommand``.[m
[31m-        ``deprecated`` can be set to a string as well to customize the[m
[31m-        deprecation message.[m
[31m-[m
[31m-    .. versionchanged:: 8.1[m
[31m-        ``help``, ``epilog``, and ``short_help`` are stored unprocessed,[m
[31m-        all formatting is done when outputting help text, not at init,[m
[31m-        and is done even if not using the ``@command`` decorator.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        Added a ``repr`` showing the command name.[m
[31m-[m
[31m-    .. versionchanged:: 7.1[m
[31m-        Added the ``no_args_is_help`` parameter.[m
[31m-[m
[31m-    .. versionchanged:: 2.0[m
[31m-        Added the ``context_settings`` parameter.[m
[31m-    """[m
[31m-[m
[31m-    #: The context class to create with :meth:`make_context`.[m
[31m-    #:[m
[31m-    #: .. versionadded:: 8.0[m
[31m-    context_class: type[Context] = Context[m
[31m-[m
[31m-    #: the default for the :attr:`Context.allow_extra_args` flag.[m
[31m-    allow_extra_args = False[m
[31m-[m
[31m-    #: the default for the :attr:`Context.allow_interspersed_args` flag.[m
[31m-    allow_interspersed_args = True[m
[31m-[m
[31m-    #: the default for the :attr:`Context.ignore_unknown_options` flag.[m
[31m-    ignore_unknown_options = False[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        name: str | None,[m
[31m-        context_settings: cabc.MutableMapping[str, t.Any] | None = None,[m
[31m-        callback: t.Callable[..., t.Any] | None = None,[m
[31m-        params: list[Parameter] | None = None,[m
[31m-        help: str | None = None,[m
[31m-        epilog: str | None = None,[m
[31m-        short_help: str | None = None,[m
[31m-        options_metavar: str | None = "[OPTIONS]",[m
[31m-        add_help_option: bool = True,[m
[31m-        no_args_is_help: bool = False,[m
[31m-        hidden: bool = False,[m
[31m-        deprecated: bool | str = False,[m
[31m-    ) -> None:[m
[31m-        #: the name the command thinks it has.  Upon registering a command[m
[31m-        #: on a :class:`Group` the group will default the command name[m
[31m-        #: with this information.  You should instead use the[m
[31m-        #: :class:`Context`\'s :attr:`~Context.info_name` attribute.[m
[31m-        self.name = name[m
[31m-[m
[31m-        if context_settings is None:[m
[31m-            context_settings = {}[m
[31m-[m
[31m-        #: an optional dictionary with defaults passed to the context.[m
[31m-        self.context_settings: cabc.MutableMapping[str, t.Any] = context_settings[m
[31m-[m
[31m-        #: the callback to execute when the command fires.  This might be[m
[31m-        #: `None` in which case nothing happens.[m
[31m-        self.callback = callback[m
[31m-        #: the list of parameters for this command in the order they[m
[31m-        #: should show up in the help page and execute.  Eager parameters[m
[31m-        #: will automatically be handled before non eager ones.[m
[31m-        self.params: list[Parameter] = params or [][m
[31m-        self.help = help[m
[31m-        self.epilog = epilog[m
[31m-        self.options_metavar = options_metavar[m
[31m-        self.short_help = short_help[m
[31m-        self.add_help_option = add_help_option[m
[31m-        self._help_option = None[m
[31m-        self.no_args_is_help = no_args_is_help[m
[31m-        self.hidden = hidden[m
[31m-        self.deprecated = deprecated[m
[31m-[m
[31m-    def to_info_dict(self, ctx: Context) -> dict[str, t.Any]:[m
[31m-        return {[m
[31m-            "name": self.name,[m
[31m-            "params": [param.to_info_dict() for param in self.get_params(ctx)],[m
[31m-            "help": self.help,[m
[31m-            "epilog": self.epilog,[m
[31m-            "short_help": self.short_help,[m
[31m-            "hidden": self.hidden,[m
[31m-            "deprecated": self.deprecated,[m
[31m-        }[m
[31m-[m
[31m-    def __repr__(self) -> str:[m
[31m-        return f"<{self.__class__.__name__} {self.name}>"[m
[31m-[m
[31m-    def get_usage(self, ctx: Context) -> str:[m
[31m-        """Formats the usage line into a string and returns it.[m
[31m-[m
[31m-        Calls :meth:`format_usage` internally.[m
[31m-        """[m
[31m-        formatter = ctx.make_formatter()[m
[31m-        self.format_usage(ctx, formatter)[m
[31m-        return formatter.getvalue().rstrip("\n")[m
[31m-[m
[31m-    def get_params(self, ctx: Context) -> list[Parameter]:[m
[31m-        params = self.params[m
[31m-        help_option = self.get_help_option(ctx)[m
[31m-[m
[31m-        if help_option is not None:[m
[31m-            params = [*params, help_option][m
[31m-[m
[31m-        if __debug__:[m
[31m-            import warnings[m
[31m-[m
[31m-            opts = [opt for param in params for opt in param.opts][m
[31m-            opts_counter = Counter(opts)[m
[31m-            duplicate_opts = (opt for opt, count in opts_counter.items() if count > 1)[m
[31m-[m
[31m-            for duplicate_opt in duplicate_opts:[m
[31m-                warnings.warn([m
[31m-                    ([m
[31m-                        f"The parameter {duplicate_opt} is used more than once. "[m
[31m-                        "Remove its duplicate as parameters should be unique."[m
[31m-                    ),[m
[31m-                    stacklevel=3,[m
[31m-                )[m
[31m-[m
[31m-        return params[m
[31m-[m
[31m-    def format_usage(self, ctx: Context, formatter: HelpFormatter) -> None:[m
[31m-        """Writes the usage line into the formatter.[m
[31m-[m
[31m-        This is a low-level method called by :meth:`get_usage`.[m
[31m-        """[m
[31m-        pieces = self.collect_usage_pieces(ctx)[m
[31m-        formatter.write_usage(ctx.command_path, " ".join(pieces))[m
[31m-[m
[31m-    def collect_usage_pieces(self, ctx: Context) -> list[str]:[m
[31m-        """Returns all the pieces that go into the usage line and returns[m
[31m-        it as a list of strings.[m
[31m-        """[m
[31m-        rv = [self.options_metavar] if self.options_metavar else [][m
[31m-[m
[31m-        for param in self.get_params(ctx):[m
[31m-            rv.extend(param.get_usage_pieces(ctx))[m
[31m-[m
[31m-        return rv[m
[31m-[m
[31m-    def get_help_option_names(self, ctx: Context) -> list[str]:[m
[31m-        """Returns the names for the help option."""[m
[31m-        all_names = set(ctx.help_option_names)[m
[31m-        for param in self.params:[m
[31m-            all_names.difference_update(param.opts)[m
[31m-            all_names.difference_update(param.secondary_opts)[m
[31m-        return list(all_names)[m
[31m-[m
[31m-    def get_help_option(self, ctx: Context) -> Option | None:[m
[31m-        """Returns the help option object.[m
[31m-[m
[31m-        Skipped if :attr:`add_help_option` is ``False``.[m
[31m-[m
[31m-        .. versionchanged:: 8.1.8[m
[31m-            The help option is now cached to avoid creating it multiple times.[m
[31m-        """[m
[31m-        help_option_names = self.get_help_option_names(ctx)[m
[31m-[m
[31m-        if not help_option_names or not self.add_help_option:[m
[31m-            return None[m
[31m-[m
[31m-        # Cache the help option object in private _help_option attribute to[m
[31m-        # avoid creating it multiple times. Not doing this will break the[m
[31m-        # callback odering by iter_params_for_processing(), which relies on[m
[31m-        # object comparison.[m
[31m-        if self._help_option is None:[m
[31m-            # Avoid circular import.[m
[31m-            from .decorators import help_option[m
[31m-[m
[31m-            # Apply help_option decorator and pop resulting option[m
[31m-            help_option(*help_option_names)(self)[m
[31m-            self._help_option = self.params.pop()  # type: ignore[assignment][m
[31m-[m
[31m-        return self._help_option[m
[31m-[m
[31m-    def make_parser(self, ctx: Context) -> _OptionParser:[m
[31m-        """Creates the underlying option parser for this command."""[m
[31m-        parser = _OptionParser(ctx)[m
[31m-        for param in self.get_params(ctx):[m
[31m-            param.add_to_parser(parser, ctx)[m
[31m-        return parser[m
[31m-[m
[31m-    def get_help(self, ctx: Context) -> str:[m
[31m-        """Formats the help into a string and returns it.[m
[31m-[m
[31m-        Calls :meth:`format_help` internally.[m
[31m-        """[m
[31m-        formatter = ctx.make_formatter()[m
[31m-        self.format_help(ctx, formatter)[m
[31m-        return formatter.getvalue().rstrip("\n")[m
[31m-[m
[31m-    def get_short_help_str(self, limit: int = 45) -> str:[m
[31m-        """Gets short help for the command or makes it by shortening the[m
[31m-        long help string.[m
[31m-        """[m
[31m-        if self.short_help:[m
[31m-            text = inspect.cleandoc(self.short_help)[m
[31m-        elif self.help:[m
[31m-            text = make_default_short_help(self.help, limit)[m
[31m-        else:[m
[31m-            text = ""[m
[31m-[m
[31m-        if self.deprecated:[m
[31m-            deprecated_message = ([m
[31m-                f"(DEPRECATED: {self.deprecated})"[m
[31m-                if isinstance(self.deprecated, str)[m
[31m-                else "(DEPRECATED)"[m
[31m-            )[m
[31m-            text = _("{text} {deprecated_message}").format([m
[31m-                text=text, deprecated_message=deprecated_message[m
[31m-            )[m
[31m-[m
[31m-        return text.strip()[m
[31m-[m
[31m-    def format_help(self, ctx: Context, formatter: HelpFormatter) -> None:[m
[31m-        """Writes the help into the formatter if it exists.[m
[31m-[m
[31m-        This is a low-level method called by :meth:`get_help`.[m
[31m-[m
[31m-        This calls the following methods:[m
[31m-[m
[31m-        -   :meth:`format_usage`[m
[31m-        -   :meth:`format_help_text`[m
[31m-        -   :meth:`format_options`[m
[31m-        -   :meth:`format_epilog`[m
[31m-        """[m
[31m-        self.format_usage(ctx, formatter)[m
[31m-        self.format_help_text(ctx, formatter)[m
[31m-        self.format_options(ctx, formatter)[m
[31m-        self.format_epilog(ctx, formatter)[m
[31m-[m
[31m-    def format_help_text(self, ctx: Context, formatter: HelpFormatter) -> None:[m
[31m-        """Writes the help text to the formatter if it exists."""[m
[31m-        if self.help is not None:[m
[31m-            # truncate the help text to the first form feed[m
[31m-            text = inspect.cleandoc(self.help).partition("\f")[0][m
[31m-        else:[m
[31m-            text = ""[m
[31m-[m
[31m-        if self.deprecated:[m
[31m-            deprecated_message = ([m
[31m-                f"(DEPRECATED: {self.deprecated})"[m
[31m-                if isinstance(self.deprecated, str)[m
[31m-                else "(DEPRECATED)"[m
[31m-            )[m
[31m-            text = _("{text} {deprecated_message}").format([m
[31m-                text=text, deprecated_message=deprecated_message[m
[31m-            )[m
[31m-[m
[31m-        if text:[m
[31m-            formatter.write_paragraph()[m
[31m-[m
[31m-            with formatter.indentation():[m
[31m-                formatter.write_text(text)[m
[31m-[m
[31m-    def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:[m
[31m-        """Writes all the options into the formatter if they exist."""[m
[31m-        opts = [][m
[31m-        for param in self.get_params(ctx):[m
[31m-            rv = param.get_help_record(ctx)[m
[31m-            if rv is not None:[m
[31m-                opts.append(rv)[m
[31m-[m
[31m-        if opts:[m
[31m-            with formatter.section(_("Options")):[m
[31m-                formatter.write_dl(opts)[m
[31m-[m
[31m-    def format_epilog(self, ctx: Context, formatter: HelpFormatter) -> None:[m
[31m-        """Writes the epilog into the formatter if it exists."""[m
[31m-        if self.epilog:[m
[31m-            epilog = inspect.cleandoc(self.epilog)[m
[31m-            formatter.write_paragraph()[m
[31m-[m
[31m-            with formatter.indentation():[m
[31m-                formatter.write_text(epilog)[m
[31m-[m
[31m-    def make_context([m
[31m-        self,[m
[31m-        info_name: str | None,[m
[31m-        args: list[str],[m
[31m-        parent: Context | None = None,[m
[31m-        **extra: t.Any,[m
[31m-    ) -> Context:[m
[31m-        """This function when given an info name and arguments will kick[m
[31m-        off the parsing and create a new :class:`Context`.  It does not[m
[31m-        invoke the actual command callback though.[m
[31m-[m
[31m-        To quickly customize the context class used without overriding[m
[31m-        this method, set the :attr:`context_class` attribute.[m
[31m-[m
[31m-        :param info_name: the info name for this invocation.  Generally this[m
[31m-                          is the most descriptive name for the script or[m
[31m-                          command.  For the toplevel script it's usually[m
[31m-                          the name of the script, for commands below it's[m
[31m-                          the name of the command.[m
[31m-        :param args: the arguments to parse as list of strings.[m
[31m-        :param parent: the parent context if available.[m
[31m-        :param extra: extra keyword arguments forwarded to the context[m
[31m-                      constructor.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Added the :attr:`context_class` attribute.[m
[31m-        """[m
[31m-        for key, value in self.context_settings.items():[m
[31m-            if key not in extra:[m
[31m-                extra[key] = value[m
[31m-[m
[31m-        ctx = self.context_class(self, info_name=info_name, parent=parent, **extra)[m
[31m-[m
[31m-        with ctx.scope(cleanup=False):[m
[31m-            self.parse_args(ctx, args)[m
[31m-        return ctx[m
[31m-[m
[31m-    def parse_args(self, ctx: Context, args: list[str]) -> list[str]:[m
[31m-        if not args and self.no_args_is_help and not ctx.resilient_parsing:[m
[31m-            raise NoArgsIsHelpError(ctx)[m
[31m-[m
[31m-        parser = self.make_parser(ctx)[m
[31m-        opts, args, param_order = parser.parse_args(args=args)[m
[31m-[m
[31m-        for param in iter_params_for_processing(param_order, self.get_params(ctx)):[m
[31m-            value, args = param.handle_parse_result(ctx, opts, args)[m
[31m-[m
[31m-        if args and not ctx.allow_extra_args and not ctx.resilient_parsing:[m
[31m-            ctx.fail([m
[31m-                ngettext([m
[31m-                    "Got unexpected extra argument ({args})",[m
[31m-                    "Got unexpected extra arguments ({args})",[m
[31m-                    len(args),[m
[31m-                ).format(args=" ".join(map(str, args)))[m
[31m-            )[m
[31m-[m
[31m-        ctx.args = args[m
[31m-        ctx._opt_prefixes.update(parser._opt_prefixes)[m
[31m-        return args[m
[31m-[m
[31m-    def invoke(self, ctx: Context) -> t.Any:[m
[31m-        """Given a context, this invokes the attached callback (if it exists)[m
[31m-        in the right way.[m
[31m-        """[m
[31m-        if self.deprecated:[m
[31m-            extra_message = ([m
[31m-                f" {self.deprecated}" if isinstance(self.deprecated, str) else ""[m
[31m-            )[m
[31m-            message = _([m
[31m-                "DeprecationWarning: The command {name!r} is deprecated.{extra_message}"[m
[31m-            ).format(name=self.name, extra_message=extra_message)[m
[31m-            echo(style(message, fg="red"), err=True)[m
[31m-[m
[31m-        if self.callback is not None:[m
[31m-            return ctx.invoke(self.callback, **ctx.params)[m
[31m-[m
[31m-    def shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:[m
[31m-        """Return a list of completions for the incomplete value. Looks[m
[31m-        at the names of options and chained multi-commands.[m
[31m-[m
[31m-        Any command could be part of a chained multi-command, so sibling[m
[31m-        commands are valid at any point during command completion.[m
[31m-[m
[31m-        :param ctx: Invocation context for this command.[m
[31m-        :param incomplete: Value being completed. May be empty.[m
[31m-[m
[31m-        .. versionadded:: 8.0[m
[31m-        """[m
[31m-        from click.shell_completion import CompletionItem[m
[31m-[m
[31m-        results: list[CompletionItem] = [][m
[31m-[m
[31m-        if incomplete and not incomplete[0].isalnum():[m
[31m-            for param in self.get_params(ctx):[m
[31m-                if ([m
[31m-                    not isinstance(param, Option)[m
[31m-                    or param.hidden[m
[31m-                    or ([m
[31m-                        not param.multiple[m
[31m-                        and ctx.get_parameter_source(param.name)  # type: ignore[m
[31m-                        is ParameterSource.COMMANDLINE[m
[31m-                    )[m
[31m-                ):[m
[31m-                    continue[m
[31m-[m
[31m-                results.extend([m
[31m-                    CompletionItem(name, help=param.help)[m
[31m-                    for name in [*param.opts, *param.secondary_opts][m
[31m-                    if name.startswith(incomplete)[m
[31m-                )[m
[31m-[m
[31m-        while ctx.parent is not None:[m
[31m-            ctx = ctx.parent[m
[31m-[m
[31m-            if isinstance(ctx.command, Group) and ctx.command.chain:[m
[31m-                results.extend([m
[31m-                    CompletionItem(name, help=command.get_short_help_str())[m
[31m-                    for name, command in _complete_visible_commands(ctx, incomplete)[m
[31m-                    if name not in ctx._protected_args[m
[31m-                )[m
[31m-[m
[31m-        return results[m
[31m-[m
[31m-    @t.overload[m
[31m-    def main([m
[31m-        self,[m
[31m-        args: cabc.Sequence[str] | None = None,[m
[31m-        prog_name: str | None = None,[m
[31m-        complete_var: str | None = None,[m
[31m-        standalone_mode: t.Literal[True] = True,[m
[31m-        **extra: t.Any,[m
[31m-    ) -> t.NoReturn: ...[m
[31m-[m
[31m-    @t.overload[m
[31m-    def main([m
[31m-        self,[m
[31m-        args: cabc.Sequence[str] | None = None,[m
[31m-        prog_name: str | None = None,[m
[31m-        complete_var: str | None = None,[m
[31m-        standalone_mode: bool = ...,[m
[31m-        **extra: t.Any,[m
[31m-    ) -> t.Any: ...[m
[31m-[m
[31m-    def main([m
[31m-        self,[m
[31m-        args: cabc.Sequence[str] | None = None,[m
[31m-        prog_name: str | None = None,[m
[31m-        complete_var: str | None = None,[m
[31m-        standalone_mode: bool = True,[m
[31m-        windows_expand_args: bool = True,[m
[31m-        **extra: t.Any,[m
[31m-    ) -> t.Any:[m
[31m-        """This is the way to invoke a script with all the bells and[m
[31m-        whistles as a command line application.  This will always terminate[m
[31m-        the application after a call.  If this is not wanted, ``SystemExit``[m
[31m-        needs to be caught.[m
[31m-[m
[31m-        This method is also available by directly calling the instance of[m
[31m-        a :class:`Command`.[m
[31m-[m
[31m-        :param args: the arguments that should be used for parsing.  If not[m
[31m-                     provided, ``sys.argv[1:]`` is used.[m
[31m-        :param prog_name: the program name that should be used.  By default[m
[31m-                          the program name is constructed by taking the file[m
[31m-                          name from ``sys.argv[0]``.[m
[31m-        :param complete_var: the environment variable that controls the[m
[31m-                             bash completion support.  The default is[m
[31m-                             ``"_<prog_name>_COMPLETE"`` with prog_name in[m
[31m-                             uppercase.[m
[31m-        :param standalone_mode: the default behavior is to invoke the script[m
[31m-                                in standalone mode.  Click will then[m
[31m-                                handle exceptions and convert them into[m
[31m-                                error messages and the function will never[m
[31m-                                return but shut down the interpreter.  If[m
[31m-                                this is set to `False` they will be[m
[31m-                                propagated to the caller and the return[m
[31m-                                value of this function is the return value[m
[31m-                                of :meth:`invoke`.[m
[31m-        :param windows_expand_args: Expand glob patterns, user dir, and[m
[31m-            env vars in command line args on Windows.[m
[31m-        :param extra: extra keyword arguments are forwarded to the context[m
[31m-                      constructor.  See :class:`Context` for more information.[m
[31m-[m
[31m-        .. versionchanged:: 8.0.1[m
[31m-            Added the ``windows_expand_args`` parameter to allow[m
[31m-            disabling command line arg expansion on Windows.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            When taking arguments from ``sys.argv`` on Windows, glob[m
[31m-            patterns, user dir, and env vars are expanded.[m
[31m-[m
[31m-        .. versionchanged:: 3.0[m
[31m-           Added the ``standalone_mode`` parameter.[m
[31m-        """[m
[31m-        if args is None:[m
[31m-            args = sys.argv[1:][m
[31m-[m
[31m-            if os.name == "nt" and windows_expand_args:[m
[31m-                args = _expand_args(args)[m
[31m-        else:[m
[31m-            args = list(args)[m
[31m-[m
[31m-        if prog_name is None:[m
[31m-            prog_name = _detect_program_name()[m
[31m-[m
[31m-        # Process shell completion requests and exit early.[m
[31m-        self._main_shell_completion(extra, prog_name, complete_var)[m
[31m-[m
[31m-        try:[m
[31m-            try:[m
[31m-                with self.make_context(prog_name, args, **extra) as ctx:[m
[31m-                    rv = self.invoke(ctx)[m
[31m-                    if not standalone_mode:[m
[31m-                        return rv[m
[31m-                    # it's not safe to `ctx.exit(rv)` here![m
[31m-                    # note that `rv` may actually contain data like "1" which[m
[31m-                    # has obvious effects[m
[31m-                    # more subtle case: `rv=[None, None]` can come out of[m
[31m-                    # chained commands which all returned `None` -- so it's not[m
[31m-                    # even always obvious that `rv` indicates success/failure[m
[31m-                    # by its truthiness/falsiness[m
[31m-                    ctx.exit()[m
[31m-            except (EOFError, KeyboardInterrupt) as e:[m
[31m-                echo(file=sys.stderr)[m
[31m-                raise Abort() from e[m
[31m-            except ClickException as e:[m
[31m-                if not standalone_mode:[m
[31m-                    raise[m
[31m-                e.show()[m
[31m-                sys.exit(e.exit_code)[m
[31m-            except OSError as e:[m
[31m-                if e.errno == errno.EPIPE:[m
[31m-                    sys.stdout = t.cast(t.TextIO, PacifyFlushWrapper(sys.stdout))[m
[31m-                    sys.stderr = t.cast(t.TextIO, PacifyFlushWrapper(sys.stderr))[m
[31m-                    sys.exit(1)[m
[31m-                else:[m
[31m-                    raise[m
[31m-        except Exit as e:[m
[31m-            if standalone_mode:[m
[31m-                sys.exit(e.exit_code)[m
[31m-            else:[m
[31m-                # in non-standalone mode, return the exit code[m
[31m-                # note that this is only reached if `self.invoke` above raises[m
[31m-                # an Exit explicitly -- thus bypassing the check there which[m
[31m-                # would return its result[m
[31m-                # the results of non-standalone execution may therefore be[m
[31m-                # somewhat ambiguous: if there are codepaths which lead to[m
[31m-                # `ctx.exit(1)` and to `return 1`, the caller won't be able to[m
[31m-                # tell the difference between the two[m
[31m-                return e.exit_code[m
[31m-        except Abort:[m
[31m-            if not standalone_mode:[m
[31m-                raise[m
[31m-            echo(_("Aborted!"), file=sys.stderr)[m
[31m-            sys.exit(1)[m
[31m-[m
[31m-    def _main_shell_completion([m
[31m-        self,[m
[31m-        ctx_args: cabc.MutableMapping[str, t.Any],[m
[31m-        prog_name: str,[m
[31m-        complete_var: str | None = None,[m
[31m-    ) -> None:[m
[31m-        """Check if the shell is asking for tab completion, process[m
[31m-        that, then exit early. Called from :meth:`main` before the[m
[31m-        program is invoked.[m
[31m-[m
[31m-        :param prog_name: Name of the executable in the shell.[m
[31m-        :param complete_var: Name of the environment variable that holds[m
[31m-            the completion instruction. Defaults to[m
[31m-            ``_{PROG_NAME}_COMPLETE``.[m
[31m-[m
[31m-        .. versionchanged:: 8.2.0[m
[31m-            Dots (``.``) in ``prog_name`` are replaced with underscores (``_``).[m
[31m-        """[m
[31m-        if complete_var is None:[m
[31m-            complete_name = prog_name.replace("-", "_").replace(".", "_")[m
[31m-            complete_var = f"_{complete_name}_COMPLETE".upper()[m
[31m-[m
[31m-        instruction = os.environ.get(complete_var)[m
[31m-[m
[31m-        if not instruction:[m
[31m-            return[m
[31m-[m
[31m-        from .shell_completion import shell_complete[m
[31m-[m
[31m-        rv = shell_complete(self, ctx_args, prog_name, complete_var, instruction)[m
[31m-        sys.exit(rv)[m
[31m-[m
[31m-    def __call__(self, *args: t.Any, **kwargs: t.Any) -> t.Any:[m
[31m-        """Alias for :meth:`main`."""[m
[31m-        return self.main(*args, **kwargs)[m
[31m-[m
[31m-[m
[31m-class _FakeSubclassCheck(type):[m
[31m-    def __subclasscheck__(cls, subclass: type) -> bool:[m
[31m-        return issubclass(subclass, cls.__bases__[0])[m
[31m-[m
[31m-    def __instancecheck__(cls, instance: t.Any) -> bool:[m
[31m-        return isinstance(instance, cls.__bases__[0])[m
[31m-[m
[31m-[m
[31m-class _BaseCommand(Command, metaclass=_FakeSubclassCheck):[m
[31m-    """[m
[31m-    .. deprecated:: 8.2[m
[31m-        Will be removed in Click 9.0. Use ``Command`` instead.[m
[31m-    """[m
[31m-[m
[31m-[m
[31m-class Group(Command):[m
[31m-    """A group is a command that nests other commands (or more groups).[m
[31m-[m
[31m-    :param name: The name of the group command.[m
[31m-    :param commands: Map names to :class:`Command` objects. Can be a list, which[m
[31m-        will use :attr:`Command.name` as the keys.[m
[31m-    :param invoke_without_command: Invoke the group's callback even if a[m
[31m-        subcommand is not given.[m
[31m-    :param no_args_is_help: If no arguments are given, show the group's help and[m
[31m-        exit. Defaults to the opposite of ``invoke_without_command``.[m
[31m-    :param subcommand_metavar: How to represent the subcommand argument in help.[m
[31m-        The default will represent whether ``chain`` is set or not.[m
[31m-    :param chain: Allow passing more than one subcommand argument. After parsing[m
[31m-        a command's arguments, if any arguments remain another command will be[m
[31m-        matched, and so on.[m
[31m-    :param result_callback: A function to call after the group's and[m
[31m-        subcommand's callbacks. The value returned by the subcommand is passed.[m
[31m-        If ``chain`` is enabled, the value will be a list of values returned by[m
[31m-        all the commands. If ``invoke_without_command`` is enabled, the value[m
[31m-        will be the value returned by the group's callback, or an empty list if[m
[31m-        ``chain`` is enabled.[m
[31m-    :param kwargs: Other arguments passed to :class:`Command`.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        The ``commands`` argument can be a list of command objects.[m
[31m-[m
[31m-    .. versionchanged:: 8.2[m
[31m-        Merged with and replaces the ``MultiCommand`` base class.[m
[31m-    """[m
[31m-[m
[31m-    allow_extra_args = True[m
[31m-    allow_interspersed_args = False[m
[31m-[m
[31m-    #: If set, this is used by the group's :meth:`command` decorator[m
[31m-    #: as the default :class:`Command` class. This is useful to make all[m
[31m-    #: subcommands use a custom command class.[m
[31m-    #:[m
[31m-    #: .. versionadded:: 8.0[m
[31m-    command_class: type[Command] | None = None[m
[31m-[m
[31m-    #: If set, this is used by the group's :meth:`group` decorator[m
[31m-    #: as the default :class:`Group` class. This is useful to make all[m
[31m-    #: subgroups use a custom group class.[m
[31m-    #:[m
[31m-    #: If set to the special value :class:`type` (literally[m
[31m-    #: ``group_class = type``), this group's class will be used as the[m
[31m-    #: default class. This makes a custom group class continue to make[m
[31m-    #: custom groups.[m
[31m-    #:[m
[31m-    #: .. versionadded:: 8.0[m
[31m-    group_class: type[Group] | type[type] | None = None[m
[31m-    # Literal[type] isn't valid, so use Type[type][m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        name: str | None = None,[m
[31m-        commands: cabc.MutableMapping[str, Command][m
[31m-        | cabc.Sequence[Command][m
[31m-        | None = None,[m
[31m-        invoke_without_command: bool = False,[m
[31m-        no_args_is_help: bool | None = None,[m
[31m-        subcommand_metavar: str | None = None,[m
[31m-        chain: bool = False,[m
[31m-        result_callback: t.Callable[..., t.Any] | None = None,[m
[31m-        **kwargs: t.Any,[m
[31m-    ) -> None:[m
[31m-        super().__init__(name, **kwargs)[m
[31m-[m
[31m-        if commands is None:[m
[31m-            commands = {}[m
[31m-        elif isinstance(commands, abc.Sequence):[m
[31m-            commands = {c.name: c for c in commands if c.name is not None}[m
[31m-[m
[31m-        #: The registered subcommands by their exported names.[m
[31m-        self.commands: cabc.MutableMapping[str, Command] = commands[m
[31m-[m
[31m-        if no_args_is_help is None:[m
[31m-            no_args_is_help = not invoke_without_command[m
[31m-[m
[31m-        self.no_args_is_help = no_args_is_help[m
[31m-        self.invoke_without_command = invoke_without_command[m
[31m-[m
[31m-        if subcommand_metavar is None:[m
[31m-            if chain:[m
[31m-                subcommand_metavar = "COMMAND1 [ARGS]... [COMMAND2 [ARGS]...]..."[m
[31m-            else:[m
[31m-                subcommand_metavar = "COMMAND [ARGS]..."[m
[31m-[m
[31m-        self.subcommand_metavar = subcommand_metavar[m
[31m-        self.chain = chain[m
[31m-        # The result callback that is stored. This can be set or[m
[31m-        # overridden with the :func:`result_callback` decorator.[m
[31m-        self._result_callback = result_callback[m
[31m-[m
[31m-        if self.chain:[m
[31m-            for param in self.params:[m
[31m-                if isinstance(param, Argument) and not param.required:[m
[31m-                    raise RuntimeError([m
[31m-                        "A group in chain mode cannot have optional arguments."[m
[31m-                    )[m
[31m-[m
[31m-    def to_info_dict(self, ctx: Context) -> dict[str, t.Any]:[m
[31m-        info_dict = super().to_info_dict(ctx)[m
[31m-        commands = {}[m
[31m-[m
[31m-        for name in self.list_commands(ctx):[m
[31m-            command = self.get_command(ctx, name)[m
[31m-[m
[31m-            if command is None:[m
[31m-                continue[m
[31m-[m
[31m-            sub_ctx = ctx._make_sub_context(command)[m
[31m-[m
[31m-            with sub_ctx.scope(cleanup=False):[m
[31m-                commands[name] = command.to_info_dict(sub_ctx)[m
[31m-[m
[31m-        info_dict.update(commands=commands, chain=self.chain)[m
[31m-        return info_dict[m
[31m-[m
[31m-    def add_command(self, cmd: Command, name: str | None = None) -> None:[m
[31m-        """Registers another :class:`Command` with this group.  If the name[m
[31m-        is not provided, the name of the command is used.[m
[31m-        """[m
[31m-        name = name or cmd.name[m
[31m-        if name is None:[m
[31m-            raise TypeError("Command has no name.")[m
[31m-        _check_nested_chain(self, name, cmd, register=True)[m
[31m-        self.commands[name] = cmd[m
[31m-[m
[31m-    @t.overload[m
[31m-    def command(self, __func: t.Callable[..., t.Any]) -> Command: ...[m
[31m-[m
[31m-    @t.overload[m
[31m-    def command([m
[31m-        self, *args: t.Any, **kwargs: t.Any[m
[31m-    ) -> t.Callable[[t.Callable[..., t.Any]], Command]: ...[m
[31m-[m
[31m-    def command([m
[31m-        self, *args: t.Any, **kwargs: t.Any[m
[31m-    ) -> t.Callable[[t.Callable[..., t.Any]], Command] | Command:[m
[31m-        """A shortcut decorator for declaring and attaching a command to[m
[31m-        the group. This takes the same arguments as :func:`command` and[m
[31m-        immediately registers the created command with this group by[m
[31m-        calling :meth:`add_command`.[m
[31m-[m
[31m-        To customize the command class used, set the[m
[31m-        :attr:`command_class` attribute.[m
[31m-[m
[31m-        .. versionchanged:: 8.1[m
[31m-            This decorator can be applied without parentheses.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Added the :attr:`command_class` attribute.[m
[31m-        """[m
[31m-        from .decorators import command[m
[31m-[m
[31m-        func: t.Callable[..., t.Any] | None = None[m
[31m-[m
[31m-        if args and callable(args[0]):[m
[31m-            assert len(args) == 1 and not kwargs, ([m
[31m-                "Use 'command(**kwargs)(callable)' to provide arguments."[m
[31m-            )[m
[31m-            (func,) = args[m
[31m-            args = ()[m
[31m-[m
[31m-        if self.command_class and kwargs.get("cls") is None:[m
[31m-            kwargs["cls"] = self.command_class[m
[31m-[m
[31m-        def decorator(f: t.Callable[..., t.Any]) -> Command:[m
[31m-            cmd: Command = command(*args, **kwargs)(f)[m
[31m-            self.add_command(cmd)[m
[31m-            return cmd[m
[31m-[m
[31m-        if func is not None:[m
[31m-            return decorator(func)[m
[31m-[m
[31m-        return decorator[m
[31m-[m
[31m-    @t.overload[m
[31m-    def group(self, __func: t.Callable[..., t.Any]) -> Group: ...[m
[31m-[m
[31m-    @t.overload[m
[31m-    def group([m
[31m-        self, *args: t.Any, **kwargs: t.Any[m
[31m-    ) -> t.Callable[[t.Callable[..., t.Any]], Group]: ...[m
[31m-[m
[31m-    def group([m
[31m-        self, *args: t.Any, **kwargs: t.Any[m
[31m-    ) -> t.Callable[[t.Callable[..., t.Any]], Group] | Group:[m
[31m-        """A shortcut decorator for declaring and attaching a group to[m
[31m-        the group. This takes the same arguments as :func:`group` and[m
[31m-        immediately registers the created group with this group by[m
[31m-        calling :meth:`add_command`.[m
[31m-[m
[31m-        To customize the group class used, set the :attr:`group_class`[m
[31m-        attribute.[m
[31m-[m
[31m-        .. versionchanged:: 8.1[m
[31m-            This decorator can be applied without parentheses.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Added the :attr:`group_class` attribute.[m
[31m-        """[m
[31m-        from .decorators import group[m
[31m-[m
[31m-        func: t.Callable[..., t.Any] | None = None[m
[31m-[m
[31m-        if args and callable(args[0]):[m
[31m-            assert len(args) == 1 and not kwargs, ([m
[31m-                "Use 'group(**kwargs)(callable)' to provide arguments."[m
[31m-            )[m
[31m-            (func,) = args[m
[31m-            args = ()[m
[31m-[m
[31m-        if self.group_class is not None and kwargs.get("cls") is None:[m
[31m-            if self.group_class is type:[m
[31m-                kwargs["cls"] = type(self)[m
[31m-            else:[m
[31m-                kwargs["cls"] = self.group_class[m
[31m-[m
[31m-        def decorator(f: t.Callable[..., t.Any]) -> Group:[m
[31m-            cmd: Group = group(*args, **kwargs)(f)[m
[31m-            self.add_command(cmd)[m
[31m-            return cmd[m
[31m-[m
[31m-        if func is not None:[m
[31m-            return decorator(func)[m
[31m-[m
[31m-        return decorator[m
[31m-[m
[31m-    def result_callback(self, replace: bool = False) -> t.Callable[[F], F]:[m
[31m-        """Adds a result callback to the command.  By default if a[m
[31m-        result callback is already registered this will chain them but[m
[31m-        this can be disabled with the `replace` parameter.  The result[m
[31m-        callback is invoked with the return value of the subcommand[m
[31m-        (or the list of return values from all subcommands if chaining[m
[31m-        is enabled) as well as the parameters as they would be passed[m
[31m-        to the main callback.[m
[31m-[m
[31m-        Example::[m
[31m-[m
[31m-            @click.group()[m
[31m-            @click.option('-i', '--input', default=23)[m
[31m-            def cli(input):[m
[31m-                return 42[m
[31m-[m
[31m-            @cli.result_callback()[m
[31m-            def process_result(result, input):[m
[31m-                return result + input[m
[31m-[m
[31m-        :param replace: if set to `True` an already existing result[m
[31m-                        callback will be removed.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Renamed from ``resultcallback``.[m
[31m-[m
[31m-        .. versionadded:: 3.0[m
[31m-        """[m
[31m-[m
[31m-        def decorator(f: F) -> F:[m
[31m-            old_callback = self._result_callback[m
[31m-[m
[31m-            if old_callback is None or replace:[m
[31m-                self._result_callback = f[m
[31m-                return f[m
[31m-[m
[31m-            def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:[m
[31m-                inner = old_callback(value, *args, **kwargs)[m
[31m-                return f(inner, *args, **kwargs)[m
[31m-[m
[31m-            self._result_callback = rv = update_wrapper(t.cast(F, function), f)[m
[31m-            return rv  # type: ignore[return-value][m
[31m-[m
[31m-        return decorator[m
[31m-[m
[31m-    def get_command(self, ctx: Context, cmd_name: str) -> Command | None:[m
[31m-        """Given a context and a command name, this returns a :class:`Command`[m
[31m-        object if it exists or returns ``None``.[m
[31m-        """[m
[31m-        return self.commands.get(cmd_name)[m
[31m-[m
[31m-    def list_commands(self, ctx: Context) -> list[str]:[m
[31m-        """Returns a list of subcommand names in the order they should appear."""[m
[31m-        return sorted(self.commands)[m
[31m-[m
[31m-    def collect_usage_pieces(self, ctx: Context) -> list[str]:[m
[31m-        rv = super().collect_usage_pieces(ctx)[m
[31m-        rv.append(self.subcommand_metavar)[m
[31m-        return rv[m
[31m-[m
[31m-    def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:[m
[31m-        super().format_options(ctx, formatter)[m
[31m-        self.format_commands(ctx, formatter)[m
[31m-[m
[31m-    def format_commands(self, ctx: Context, formatter: HelpFormatter) -> None:[m
[31m-        """Extra format methods for multi methods that adds all the commands[m
[31m-        after the options.[m
[31m-        """[m
[31m-        commands = [][m
[31m-        for subcommand in self.list_commands(ctx):[m
[31m-            cmd = self.get_command(ctx, subcommand)[m
[31m-            # What is this, the tool lied about a command.  Ignore it[m
[31m-            if cmd is None:[m
[31m-                continue[m
[31m-            if cmd.hidden:[m
[31m-                continue[m
[31m-[m
[31m-            commands.append((subcommand, cmd))[m
[31m-[m
[31m-        # allow for 3 times the default spacing[m
[31m-        if len(commands):[m
[31m-            limit = formatter.width - 6 - max(len(cmd[0]) for cmd in commands)[m
[31m-[m
[31m-            rows = [][m
[31m-            for subcommand, cmd in commands:[m
[31m-                help = cmd.get_short_help_str(limit)[m
[31m-                rows.append((subcommand, help))[m
[31m-[m
[31m-            if rows:[m
[31m-                with formatter.section(_("Commands")):[m
[31m-                    formatter.write_dl(rows)[m
[31m-[m
[31m-    def parse_args(self, ctx: Context, args: list[str]) -> list[str]:[m
[31m-        if not args and self.no_args_is_help and not ctx.resilient_parsing:[m
[31m-            raise NoArgsIsHelpError(ctx)[m
[31m-[m
[31m-        rest = super().parse_args(ctx, args)[m
[31m-[m
[31m-        if self.chain:[m
[31m-            ctx._protected_args = rest[m
[31m-            ctx.args = [][m
[31m-        elif rest:[m
[31m-            ctx._protected_args, ctx.args = rest[:1], rest[1:][m
[31m-[m
[31m-        return ctx.args[m
[31m-[m
[31m-    def invoke(self, ctx: Context) -> t.Any:[m
[31m-        def _process_result(value: t.Any) -> t.Any:[m
[31m-            if self._result_callback is not None:[m
[31m-                value = ctx.invoke(self._result_callback, value, **ctx.params)[m
[31m-            return value[m
[31m-[m
[31m-        if not ctx._protected_args:[m
[31m-            if self.invoke_without_command:[m
[31m-                # No subcommand was invoked, so the result callback is[m
[31m-                # invoked with the group return value for regular[m
[31m-                # groups, or an empty list for chained groups.[m
[31m-                with ctx:[m
[31m-                    rv = super().invoke(ctx)[m
[31m-                    return _process_result([] if self.chain else rv)[m
[31m-            ctx.fail(_("Missing command."))[m
[31m-[m
[31m-        # Fetch args back out[m
[31m-        args = [*ctx._protected_args, *ctx.args][m
[31m-        ctx.args = [][m
[31m-        ctx._protected_args = [][m
[31m-[m
[31m-        # If we're not in chain mode, we only allow the invocation of a[m
[31m-        # single command but we also inform the current context about the[m
[31m-        # name of the command to invoke.[m
[31m-        if not self.chain:[m
[31m-            # Make sure the context is entered so we do not clean up[m
[31m-            # resources until the result processor has worked.[m
[31m-            with ctx:[m
[31m-                cmd_name, cmd, args = self.resolve_command(ctx, args)[m
[31m-                assert cmd is not None[m
[31m-                ctx.invoked_subcommand = cmd_name[m
[31m-                super().invoke(ctx)[m
[31m-                sub_ctx = cmd.make_context(cmd_name, args, parent=ctx)[m
[31m-                with sub_ctx:[m
[31m-                    return _process_result(sub_ctx.command.invoke(sub_ctx))[m
[31m-[m
[31m-        # In chain mode we create the contexts step by step, but after the[m
[31m-        # base command has been invoked.  Because at that point we do not[m
[31m-        # know the subcommands yet, the invoked subcommand attribute is[m
[31m-        # set to ``*`` to inform the command that subcommands are executed[m
[31m-        # but nothing else.[m
[31m-        with ctx:[m
[31m-            ctx.invoked_subcommand = "*" if args else None[m
[31m-            super().invoke(ctx)[m
[31m-[m
[31m-            # Otherwise we make every single context and invoke them in a[m
[31m-            # chain.  In that case the return value to the result processor[m
[31m-            # is the list of all invoked subcommand's results.[m
[31m-            contexts = [][m
[31m-            while args:[m
[31m-                cmd_name, cmd, args = self.resolve_command(ctx, args)[m
[31m-                assert cmd is not None[m
[31m-                sub_ctx = cmd.make_context([m
[31m-                    cmd_name,[m
[31m-                    args,[m
[31m-                    parent=ctx,[m
[31m-                    allow_extra_args=True,[m
[31m-                    allow_interspersed_args=False,[m
[31m-                )[m
[31m-                contexts.append(sub_ctx)[m
[31m-                args, sub_ctx.args = sub_ctx.args, [][m
[31m-[m
[31m-            rv = [][m
[31m-            for sub_ctx in contexts:[m
[31m-                with sub_ctx:[m
[31m-                    rv.append(sub_ctx.command.invoke(sub_ctx))[m
[31m-            return _process_result(rv)[m
[31m-[m
[31m-    def resolve_command([m
[31m-        self, ctx: Context, args: list[str][m
[31m-    ) -> tuple[str | None, Command | None, list[str]]:[m
[31m-        cmd_name = make_str(args[0])[m
[31m-        original_cmd_name = cmd_name[m
[31m-[m
[31m-        # Get the command[m
[31m-        cmd = self.get_command(ctx, cmd_name)[m
[31m-[m
[31m-        # If we can't find the command but there is a normalization[m
[31m-        # function available, we try with that one.[m
[31m-        if cmd is None and ctx.token_normalize_func is not None:[m
[31m-            cmd_name = ctx.token_normalize_func(cmd_name)[m
[31m-            cmd = self.get_command(ctx, cmd_name)[m
[31m-[m
[31m-        # If we don't find the command we want to show an error message[m
[31m-        # to the user that it was not provided.  However, there is[m
[31m-        # something else we should do: if the first argument looks like[m
[31m-        # an option we want to kick off parsing again for arguments to[m
[31m-        # resolve things like --help which now should go to the main[m
[31m-        # place.[m
[31m-        if cmd is None and not ctx.resilient_parsing:[m
[31m-            if _split_opt(cmd_name)[0]:[m
[31m-                self.parse_args(ctx, args)[m
[31m-            ctx.fail(_("No such command {name!r}.").format(name=original_cmd_name))[m
[31m-        return cmd_name if cmd else None, cmd, args[1:][m
[31m-[m
[31m-    def shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:[m
[31m-        """Return a list of completions for the incomplete value. Looks[m
[31m-        at the names of options, subcommands, and chained[m
[31m-        multi-commands.[m
[31m-[m
[31m-        :param ctx: Invocation context for this command.[m
[31m-        :param incomplete: Value being completed. May be empty.[m
[31m-[m
[31m-        .. versionadded:: 8.0[m
[31m-        """[m
[31m-        from click.shell_completion import CompletionItem[m
[31m-[m
[31m-        results = [[m
[31m-            CompletionItem(name, help=command.get_short_help_str())[m
[31m-            for name, command in _complete_visible_commands(ctx, incomplete)[m
[31m-        ][m
[31m-        results.extend(super().shell_complete(ctx, incomplete))[m
[31m-        return results[m
[31m-[m
[31m-[m
[31m-class _MultiCommand(Group, metaclass=_FakeSubclassCheck):[m
[31m-    """[m
[31m-    .. deprecated:: 8.2[m
[31m-        Will be removed in Click 9.0. Use ``Group`` instead.[m
[31m-    """[m
[31m-[m
[31m-[m
[31m-class CommandCollection(Group):[m
[31m-    """A :class:`Group` that looks up subcommands on other groups. If a command[m
[31m-    is not found on this group, each registered source is checked in order.[m
[31m-    Parameters on a source are not added to this group, and a source's callback[m
[31m-    is not invoked when invoking its commands. In other words, this "flattens"[m
[31m-    commands in many groups into this one group.[m
[31m-[m
[31m-    :param name: The name of the group command.[m
[31m-    :param sources: A list of :class:`Group` objects to look up commands from.[m
[31m-    :param kwargs: Other arguments passed to :class:`Group`.[m
[31m-[m
[31m-    .. versionchanged:: 8.2[m
[31m-        This is a subclass of ``Group``. Commands are looked up first on this[m
[31m-        group, then each of its sources.[m
[31m-    """[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        name: str | None = None,[m
[31m-        sources: list[Group] | None = None,[m
[31m-        **kwargs: t.Any,[m
[31m-    ) -> None:[m
[31m-        super().__init__(name, **kwargs)[m
[31m-        #: The list of registered groups.[m
[31m-        self.sources: list[Group] = sources or [][m
[31m-[m
[31m-    def add_source(self, group: Group) -> None:[m
[31m-        """Add a group as a source of commands."""[m
[31m-        self.sources.append(group)[m
[31m-[m
[31m-    def get_command(self, ctx: Context, cmd_name: str) -> Command | None:[m
[31m-        rv = super().get_command(ctx, cmd_name)[m
[31m-[m
[31m-        if rv is not None:[m
[31m-            return rv[m
[31m-[m
[31m-        for source in self.sources:[m
[31m-            rv = source.get_command(ctx, cmd_name)[m
[31m-[m
[31m-            if rv is not None:[m
[31m-                if self.chain:[m
[31m-                    _check_nested_chain(self, cmd_name, rv)[m
[31m-[m
[31m-                return rv[m
[31m-[m
[31m-        return None[m
[31m-[m
[31m-    def list_commands(self, ctx: Context) -> list[str]:[m
[31m-        rv: set[str] = set(super().list_commands(ctx))[m
[31m-[m
[31m-        for source in self.sources:[m
[31m-            rv.update(source.list_commands(ctx))[m
[31m-[m
[31m-        return sorted(rv)[m
[31m-[m
[31m-[m
[31m-def _check_iter(value: t.Any) -> cabc.Iterator[t.Any]:[m
[31m-    """Check if the value is iterable but not a string. Raises a type[m
[31m-    error, or return an iterator over the value.[m
[31m-    """[m
[31m-    if isinstance(value, str):[m
[31m-        raise TypeError[m
[31m-[m
[31m-    return iter(value)[m
[31m-[m
[31m-[m
[31m-class Parameter:[m
[31m-    r"""A parameter to a command comes in two versions: they are either[m
[31m-    :class:`Option`\s or :class:`Argument`\s.  Other subclasses are currently[m
[31m-    not supported by design as some of the internals for parsing are[m
[31m-    intentionally not finalized.[m
[31m-[m
[31m-    Some settings are supported by both options and arguments.[m
[31m-[m
[31m-    :param param_decls: the parameter declarations for this option or[m
[31m-                        argument.  This is a list of flags or argument[m
[31m-                        names.[m
[31m-    :param type: the type that should be used.  Either a :class:`ParamType`[m
[31m-                 or a Python type.  The latter is converted into the former[m
[31m-                 automatically if supported.[m
[31m-    :param required: controls if this is optional or not.[m
[31m-    :param default: the default value if omitted.  This can also be a callable,[m
[31m-                    in which case it's invoked when the default is needed[m
[31m-                    without any arguments.[m
[31m-    :param callback: A function to further process or validate the value[m
[31m-        after type conversion. It is called as ``f(ctx, param, value)``[m
[31m-        and must return the value. It is called for all sources,[m
[31m-        including prompts.[m
[31m-    :param nargs: the number of arguments to match.  If not ``1`` the return[m
[31m-                  value is a tuple instead of single value.  The default for[m
[31m-                  nargs is ``1`` (except if the type is a tuple, then it's[m
[31m-                  the arity of the tuple). If ``nargs=-1``, all remaining[m
[31m-                  parameters are collected.[m
[31m-    :param metavar: how the value is represented in the help page.[m
[31m-    :param expose_value: if this is `True` then the value is passed onwards[m
[31m-                         to the command callback and stored on the context,[m
[31m-                         otherwise it's skipped.[m
[31m-    :param is_eager: eager values are processed before non eager ones.  This[m
[31m-                     should not be set for arguments or it will inverse the[m
[31m-                     order of processing.[m
[31m-    :param envvar: a string or list of strings that are environment variables[m
[31m-                   that should be checked.[m
[31m-    :param shell_complete: A function that returns custom shell[m
[31m-        completions. Used instead of the param's type completion if[m
[31m-        given. Takes ``ctx, param, incomplete`` and must return a list[m
[31m-        of :class:`~click.shell_completion.CompletionItem` or a list of[m
[31m-        strings.[m
[31m-    :param deprecated: If ``True`` or non-empty string, issues a message[m
[31m-                        indicating that the argument is deprecated and highlights[m
[31m-                        its deprecation in --help. The message can be customized[m
[31m-                        by using a string as the value. A deprecated parameter[m
[31m-                        cannot be required, a ValueError will be raised otherwise.[m
[31m-[m
[31m-    .. versionchanged:: 8.2.0[m
[31m-        Introduction of ``deprecated``.[m
[31m-[m
[31m-    .. versionchanged:: 8.2[m
[31m-        Adding duplicate parameter names to a :class:`~click.core.Command` will[m
[31m-        result in a ``UserWarning`` being shown.[m
[31m-[m
[31m-    .. versionchanged:: 8.2[m
[31m-        Adding duplicate parameter names to a :class:`~click.core.Command` will[m
[31m-        result in a ``UserWarning`` being shown.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        ``process_value`` validates required parameters and bounded[m
[31m-        ``nargs``, and invokes the parameter callback before returning[m
[31m-        the value. This allows the callback to validate prompts.[m
[31m-        ``full_process_value`` is removed.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        ``autocompletion`` is renamed to ``shell_complete`` and has new[m
[31m-        semantics described above. The old name is deprecated and will[m
[31m-        be removed in 8.1, until then it will be wrapped to match the[m
[31m-        new requirements.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        For ``multiple=True, nargs>1``, the default must be a list of[m
[31m-        tuples.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        Setting a default is no longer required for ``nargs>1``, it will[m
[31m-        default to ``None``. ``multiple=True`` or ``nargs=-1`` will[m
[31m-        default to ``()``.[m
[31m-[m
[31m-    .. versionchanged:: 7.1[m
[31m-        Empty environment variables are ignored rather than taking the[m
[31m-        empty string value. This makes it possible for scripts to clear[m
[31m-        variables if they can't unset them.[m
[31m-[m
[31m-    .. versionchanged:: 2.0[m
[31m-        Changed signature for parameter callback to also be passed the[m
[31m-        parameter. The old callback format will still work, but it will[m
[31m-        raise a warning to give you a chance to migrate the code easier.[m
[31m-    """[m
[31m-[m
[31m-    param_type_name = "parameter"[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        param_decls: cabc.Sequence[str] | None = None,[m
[31m-        type: types.ParamType | t.Any | None = None,[m
[31m-        required: bool = False,[m
[31m-        default: t.Any | t.Callable[[], t.Any] | None = None,[m
[31m-        callback: t.Callable[[Context, Parameter, t.Any], t.Any] | None = None,[m
[31m-        nargs: int | None = None,[m
[31m-        multiple: bool = False,[m
[31m-        metavar: str | None = None,[m
[31m-        expose_value: bool = True,[m
[31m-        is_eager: bool = False,[m
[31m-        envvar: str | cabc.Sequence[str] | None = None,[m
[31m-        shell_complete: t.Callable[[m
[31m-            [Context, Parameter, str], list[CompletionItem] | list[str][m
[31m-        ][m
[31m-        | None = None,[m
[31m-        deprecated: bool | str = False,[m
[31m-    ) -> None:[m
[31m-        self.name: str | None[m
[31m-        self.opts: list[str][m
[31m-        self.secondary_opts: list[str][m
[31m-        self.name, self.opts, self.secondary_opts = self._parse_decls([m
[31m-            param_decls or (), expose_value[m
[31m-        )[m
[31m-        self.type: types.ParamType = types.convert_type(type, default)[m
[31m-[m
[31m-        # Default nargs to what the type tells us if we have that[m
[31m-        # information available.[m
[31m-        if nargs is None:[m
[31m-            if self.type.is_composite:[m
[31m-                nargs = self.type.arity[m
[31m-            else:[m
[31m-                nargs = 1[m
[31m-[m
[31m-        self.required = required[m
[31m-        self.callback = callback[m
[31m-        self.nargs = nargs[m
[31m-        self.multiple = multiple[m
[31m-        self.expose_value = expose_value[m
[31m-        self.default = default[m
[31m-        self.is_eager = is_eager[m
[31m-        self.metavar = metavar[m
[31m-        self.envvar = envvar[m
[31m-        self._custom_shell_complete = shell_complete[m
[31m-        self.deprecated = deprecated[m
[31m-[m
[31m-        if __debug__:[m
[31m-            if self.type.is_composite and nargs != self.type.arity:[m
[31m-                raise ValueError([m
[31m-                    f"'nargs' must be {self.type.arity} (or None) for"[m
[31m-                    f" type {self.type!r}, but it was {nargs}."[m
[31m-                )[m
[31m-[m
[31m-            # Skip no default or callable default.[m
[31m-            check_default = default if not callable(default) else None[m
[31m-[m
[31m-            if check_default is not None:[m
[31m-                if multiple:[m
[31m-                    try:[m
[31m-                        # Only check the first value against nargs.[m
[31m-                        check_default = next(_check_iter(check_default), None)[m
[31m-                    except TypeError:[m
[31m-                        raise ValueError([m
[31m-                            "'default' must be a list when 'multiple' is true."[m
[31m-                        ) from None[m
[31m-[m
[31m-                # Can be None for multiple with empty default.[m
[31m-                if nargs != 1 and check_default is not None:[m
[31m-                    try:[m
[31m-                        _check_iter(check_default)[m
[31m-                    except TypeError:[m
[31m-                        if multiple:[m
[31m-                            message = ([m
[31m-                                "'default' must be a list of lists when 'multiple' is"[m
[31m-                                " true and 'nargs' != 1."[m
[31m-                            )[m
[31m-                        else:[m
[31m-                            message = "'default' must be a list when 'nargs' != 1."[m
[31m-[m
[31m-                        raise ValueError(message) from None[m
[31m-[m
[31m-                    if nargs > 1 and len(check_default) != nargs:[m
[31m-                        subject = "item length" if multiple else "length"[m
[31m-                        raise ValueError([m
[31m-                            f"'default' {subject} must match nargs={nargs}."[m
[31m-                        )[m
[31m-[m
[31m-            if required and deprecated:[m
[31m-                raise ValueError([m
[31m-                    f"The {self.param_type_name} '{self.human_readable_name}' "[m
[31m-                    "is deprecated and still required. A deprecated "[m
[31m-                    f"{self.param_type_name} cannot be required."[m
[31m-                )[m
[31m-[m
[31m-    def to_info_dict(self) -> dict[str, t.Any]:[m
[31m-        """Gather information that could be useful for a tool generating[m
[31m-        user-facing documentation.[m
[31m-[m
[31m-        Use :meth:`click.Context.to_info_dict` to traverse the entire[m
[31m-        CLI structure.[m
[31m-[m
[31m-        .. versionadded:: 8.0[m
[31m-        """[m
[31m-        return {[m
[31m-            "name": self.name,[m
[31m-            "param_type_name": self.param_type_name,[m
[31m-            "opts": self.opts,[m
[31m-            "secondary_opts": self.secondary_opts,[m
[31m-            "type": self.type.to_info_dict(),[m
[31m-            "required": self.required,[m
[31m-            "nargs": self.nargs,[m
[31m-            "multiple": self.multiple,[m
[31m-            "default": self.default,[m
[31m-            "envvar": self.envvar,[m
[31m-        }[m
[31m-[m
[31m-    def __repr__(self) -> str:[m
[31m-        return f"<{self.__class__.__name__} {self.name}>"[m
[31m-[m
[31m-    def _parse_decls([m
[31m-        self, decls: cabc.Sequence[str], expose_value: bool[m
[31m-    ) -> tuple[str | None, list[str], list[str]]:[m
[31m-        raise NotImplementedError()[m
[31m-[m
[31m-    @property[m
[31m-    def human_readable_name(self) -> str:[m
[31m-        """Returns the human readable name of this parameter.  This is the[m
[31m-        same as the name for options, but the metavar for arguments.[m
[31m-        """[m
[31m-        return self.name  # type: ignore[m
[31m-[m
[31m-    def make_metavar(self, ctx: Context) -> str:[m
[31m-        if self.metavar is not None:[m
[31m-            return self.metavar[m
[31m-[m
[31m-        metavar = self.type.get_metavar(param=self, ctx=ctx)[m
[31m-[m
[31m-        if metavar is None:[m
[31m-            metavar = self.type.name.upper()[m
[31m-[m
[31m-        if self.nargs != 1:[m
[31m-            metavar += "..."[m
[31m-[m
[31m-        return metavar[m
[31m-[m
[31m-    @t.overload[m
[31m-    def get_default([m
[31m-        self, ctx: Context, call: t.Literal[True] = True[m
[31m-    ) -> t.Any | None: ...[m
[31m-[m
[31m-    @t.overload[m
[31m-    def get_default([m
[31m-        self, ctx: Context, call: bool = ...[m
[31m-    ) -> t.Any | t.Callable[[], t.Any] | None: ...[m
[31m-[m
[31m-    def get_default([m
[31m-        self, ctx: Context, call: bool = True[m
[31m-    ) -> t.Any | t.Callable[[], t.Any] | None:[m
[31m-        """Get the default for the parameter. Tries[m
[31m-        :meth:`Context.lookup_default` first, then the local default.[m
[31m-[m
[31m-        :param ctx: Current context.[m
[31m-        :param call: If the default is a callable, call it. Disable to[m
[31m-            return the callable instead.[m
[31m-[m
[31m-        .. versionchanged:: 8.0.2[m
[31m-            Type casting is no longer performed when getting a default.[m
[31m-[m
[31m-        .. versionchanged:: 8.0.1[m
[31m-            Type casting can fail in resilient parsing mode. Invalid[m
[31m-            defaults will not prevent showing help text.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Looks at ``ctx.default_map`` first.[m
[31m-[m
[31m-        .. versionchanged:: 8.0[m
[31m-            Added the ``call`` parameter.[m
[31m-        """[m
[31m-        value = ctx.lookup_default(self.name, call=False)  # type: ignore[m
[31m-[m
[31m-        if value is None:[m
[31m-            value = self.default[m
[31m-[m
[31m-        if call and callable(value):[m
[31m-            value = value()[m
[31m-[m
[31m-        return value[m
[31m-[m
[31m-    def add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:[m
[31m-        raise NotImplementedError()[m
[31m-[m
[31m-    def consume_value([m
[31m-        self, ctx: Context, opts: cabc.Mapping[str, t.Any][m
[31m-    ) -> tuple[t.Any, ParameterSource]:[m
[31m-        value = opts.get(self.name)  # type: ignore[m
[31m-        source = ParameterSource.COMMANDLINE[m
[31m-[m
[31m-        if value is None:[m
[31m-            value = self.value_from_envvar(ctx)[m
[31m-            source = ParameterSource.ENVIRONMENT[m
[31m-[m
[31m-        if value is None:[m
[31m-            value = ctx.lookup_default(self.name)  # type: ignore[m
[31m-            source = ParameterSource.DEFAULT_MAP[m
[31m-[m
[31m-        if value is None:[m
[31m-            value = self.get_default(ctx)[m
[31m-            source = ParameterSource.DEFAULT[m
[31m-[m
[31m-        return value, source[m
[31m-[m
[31m-    def type_cast_value(self, ctx: Context, value: t.Any) -> t.Any:[m
[31m-        """Convert and validate a value against the option's[m
[31m-        :attr:`type`, :attr:`multiple`, and :attr:`nargs`.[m
[31m-        """[m
[31m-        if value is None:[m
[31m-            return () if self.multiple or self.nargs == -1 else None[m
[31m-[m
[31m-        def check_iter(value: t.Any) -> cabc.Iterator[t.Any]:[m
[31m-            try:[m
[31m-                return _check_iter(value)[m
[31m-            except TypeError:[m
[31m-                # This should only happen when passing in args manually,[m
[31m-                # the parser should construct an iterable when parsing[m
[31m-                # the command line.[m
[31m-                raise BadParameter([m
[31m-                    _("Value must be an iterable."), ctx=ctx, param=self[m
[31m-                ) from None[m
[31m-[m
[31m-        if self.nargs == 1 or self.type.is_composite:[m
[31m-[m
[31m-            def convert(value: t.Any) -> t.Any:[m
[31m-                return self.type(value, param=self, ctx=ctx)[m
[31m-[m
[31m-        elif self.nargs == -1:[m
[31m-[m
[31m-            def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...][m
[31m-                return tuple(self.type(x, self, ctx) for x in check_iter(value))[m
[31m-[m
[31m-        else:  # nargs > 1[m
[31m-[m
[31m-            def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...][m
[31m-                value = tuple(check_iter(value))[m
[31m-[m
[31m-                if len(value) != self.nargs:[m
[31m-                    raise BadParameter([m
[31m-                        ngettext([m
[31m-                            "Takes {nargs} values but 1 was given.",[m
[31m-                            "Takes {nargs} values but {len} were given.",[m
[31m-                            len(value),[m
[31m-                        ).format(nargs=self.nargs, len=len(value)),[m
[31m-                        ctx=ctx,[m
[31m-                        param=self,[m
[31m-                    )[m
[31m-[m
[31m-                return tuple(self.type(x, self, ctx) for x in value)[m
[31m-[m
[31m-        if self.multiple:[m
[31m-            return tuple(convert(x) for x in check_iter(value))[m
[31m-[m
[31m-        return convert(value)[m
[31m-[m
[31m-    def value_is_missing(self, value: t.Any) -> bool:[m
[31m-        if value is None:[m
[31m-            return True[m
[31m-[m
[31m-        if (self.nargs != 1 or self.multiple) and value == ():[m
[31m-            return True[m
[31m-[m
[31m-        return False[m
[31m-[m
[31m-    def process_value(self, ctx: Context, value: t.Any) -> t.Any:[m
[31m-        value = self.type_cast_value(ctx, value)[m
[31m-[m
[31m-        if self.required and self.value_is_missing(value):[m
[31m-            raise MissingParameter(ctx=ctx, param=self)[m
[31m-[m
[31m-        if self.callback is not None:[m
[31m-            value = self.callback(ctx, self, value)[m
[31m-[m
[31m-        return value[m
[31m-[m
[31m-    def resolve_envvar_value(self, ctx: Context) -> str | None:[m
[31m-        if self.envvar is None:[m
[31m-            return None[m
[31m-[m
[31m-        if isinstance(self.envvar, str):[m
[31m-            rv = os.environ.get(self.envvar)[m
[31m-[m
[31m-            if rv:[m
[31m-                return rv[m
[31m-        else:[m
[31m-            for envvar in self.envvar:[m
[31m-                rv = os.environ.get(envvar)[m
[31m-[m
[31m-                if rv:[m
[31m-                    return rv[m
[31m-[m
[31m-        return None[m
[31m-[m
[31m-    def value_from_envvar(self, ctx: Context) -> t.Any | None:[m
[31m-        rv: t.Any | None = self.resolve_envvar_value(ctx)[m
[31m-[m
[31m-        if rv is not None and self.nargs != 1:[m
[31m-            rv = self.type.split_envvar_value(rv)[m
[31m-[m
[31m-        return rv[m
[31m-[m
[31m-    def handle_parse_result([m
[31m-        self, ctx: Context, opts: cabc.Mapping[str, t.Any], args: list[str][m
[31m-    ) -> tuple[t.Any, list[str]]:[m
[31m-        with augment_usage_errors(ctx, param=self):[m
[31m-            value, source = self.consume_value(ctx, opts)[m
[31m-[m
[31m-            if ([m
[31m-                self.deprecated[m
[31m-                and value is not None[m
[31m-                and source[m
[31m-                not in ([m
[31m-                    ParameterSource.DEFAULT,[m
[31m-                    ParameterSource.DEFAULT_MAP,[m
[31m-                )[m
[31m-            ):[m
[31m-                extra_message = ([m
[31m-                    f" {self.deprecated}" if isinstance(self.deprecated, str) else ""[m
[31m-                )[m
[31m-                message = _([m
[31m-                    "DeprecationWarning: The {param_type} {name!r} is deprecated."[m
[31m-                    "{extra_message}"[m
[31m-                ).format([m
[31m-                    param_type=self.param_type_name,[m
[31m-                    name=self.human_readable_name,[m
[31m-                    extra_message=extra_message,[m
[31m-                )[m
[31m-                echo(style(message, fg="red"), err=True)[m
[31m-[m
[31m-            ctx.set_parameter_source(self.name, source)  # type: ignore[m
[31m-[m
[31m-            try:[m
[31m-                value = self.process_value(ctx, value)[m
[31m-            except Exception:[m
[31m-                if not ctx.resilient_parsing:[m
[31m-                    raise[m
[31m-[m
[31m-                value = None[m
[31m-[m
[31m-        if self.expose_value:[m
[31m-            ctx.params[self.name] = value  # type: ignore[m
[31m-[m
[31m-        return value, args[m
[31m-[m
[31m-    def get_help_record(self, ctx: Context) -> tuple[str, str] | None:[m
[31m-        pass[m
[31m-[m
[31m-    def get_usage_pieces(self, ctx: Context) -> list[str]:[m
[31m-        return [][m
[31m-[m
[31m-    def get_error_hint(self, ctx: Context) -> str:[m
[31m-        """Get a stringified version of the param for use in error messages to[m
[31m-        indicate which param caused the error.[m
[31m-        """[m
[31m-        hint_list = self.opts or [self.human_readable_name][m
[31m-        return " / ".join(f"'{x}'" for x in hint_list)[m
[31m-[m
[31m-    def shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:[m
[31m-        """Return a list of completions for the incomplete value. If a[m
[31m-        ``shell_complete`` function was given during init, it is used.[m
[31m-        Otherwise, the :attr:`type`[m
[31m-        :meth:`~click.types.ParamType.shell_complete` function is used.[m
[31m-[m
[31m-        :param ctx: Invocation context for this command.[m
[31m-        :param incomplete: Value being completed. May be empty.[m
[31m-[m
[31m-        .. versionadded:: 8.0[m
[31m-        """[m
[31m-        if self._custom_shell_complete is not None:[m
[31m-            results = self._custom_shell_complete(ctx, self, incomplete)[m
[31m-[m
[31m-            if results and isinstance(results[0], str):[m
[31m-                from click.shell_completion import CompletionItem[m
[31m-[m
[31m-                results = [CompletionItem(c) for c in results][m
[31m-[m
[31m-            return t.cast("list[CompletionItem]", results)[m
[31m-[m
[31m-        return self.type.shell_complete(ctx, self, incomplete)[m
[31m-[m
[31m-[m
[31m-class Option(Parameter):[m
[31m-    """Options are usually optional values on the command line and[m
[31m-    have some extra features that arguments don't have.[m
[31m-[m
[31m-    All other parameters are passed onwards to the parameter constructor.[m
[31m-[m
[31m-    :param show_default: Show the default value for this option in its[m
[31m-        help text. Values are not shown by default, unless[m
[31m-        :attr:`Context.show_default` is ``True``. If this value is a[m
[31m-        string, it shows that string in parentheses instead of the[m
[31m-        actual value. This is particularly useful for dynamic options.[m
[31m-        For single option boolean flags, the default remains hidden if[m
[31m-        its value is ``False``.[m
[31m-    :param show_envvar: Controls if an environment variable should be[m
[31m-        shown on the help page and error messages.[m
[31m-        Normally, environment variables are not shown.[m
[31m-    :param prompt: If set to ``True`` or a non empty string then the[m
[31m-        user will be prompted for input. If set to ``True`` the prompt[m
[31m-        will be the option name capitalized. A deprecated option cannot be[m
[31m-        prompted.[m
[31m-    :param confirmation_prompt: Prompt a second time to confirm the[m
[31m-        value if it was prompted for. Can be set to a string instead of[m
[31m-        ``True`` to customize the message.[m
[31m-    :param prompt_required: If set to ``False``, the user will be[m
[31m-        prompted for input only when the option was specified as a flag[m
[31m-        without a value.[m
[31m-    :param hide_input: If this is ``True`` then the input on the prompt[m
[31m-        will be hidden from the user. This is useful for password input.[m
[31m-    :param is_flag: forces this option to act as a flag.  The default is[m
[31m-                    auto detection.[m
[31m-    :param flag_value: which value should be used for this flag if it's[m
[31m-                       enabled.  This is set to a boolean automatically if[m
[31m-                       the option string contains a slash to mark two options.[m
[31m-    :param multiple: if this is set to `True` then the argument is accepted[m
[31m-                     multiple times and recorded.  This is similar to ``nargs``[m
[31m-                     in how it works but supports arbitrary number of[m
[31m-                     arguments.[m
[31m-    :param count: this flag makes an option increment an integer.[m
[31m-    :param allow_from_autoenv: if this is enabled then the value of this[m
[31m-                               parameter will be pulled from an environment[m
[31m-                               variable in case a prefix is defined on the[m
[31m-                               context.[m
[31m-    :param help: the help string.[m
[31m-    :param hidden: hide this option from help outputs.[m
[31m-    :param attrs: Other command arguments described in :class:`Parameter`.[m
[31m-[m
[31m-    .. versionchanged:: 8.2[m
[31m-        ``envvar`` used with ``flag_value`` will always use the ``flag_value``,[m
[31m-        previously it would use the value of the environment variable.[m
[31m-[m
[31m-    .. versionchanged:: 8.1[m
[31m-        Help text indentation is cleaned here instead of only in the[m
[31m-        ``@option`` decorator.[m
[31m-[m
[31m-    .. versionchanged:: 8.1[m
[31m-        The ``show_default`` parameter overrides[m
[31m-        ``Context.show_default``.[m
[31m-[m
[31m-    .. versionchanged:: 8.1[m
[31m-        The default of a single option boolean flag is not shown if the[m
[31m-        default value is ``False``.[m
[31m-[m
[31m-    .. versionchanged:: 8.0.1[m
[31m-        ``type`` is detected from ``flag_value`` if given.[m
[31m-    """[m
[31m-[m
[31m-    param_type_name = "option"[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        param_decls: cabc.Sequence[str] | None = None,[m
[31m-        show_default: bool | str | None = None,[m
[31m-        prompt: bool | str = False,[m
[31m-        confirmation_prompt: bool | str = False,[m
[31m-        prompt_required: bool = True,[m
[31m-        hide_input: bool = False,[m
[31m-        is_flag: bool | None = None,[m
[31m-        flag_value: t.Any | None = None,[m
[31m-        multiple: bool = False,[m
[31m-        count: bool = False,[m
[31m-        allow_from_autoenv: bool = True,[m
[31m-        type: types.ParamType | t.Any | None = None,[m
[31m-        help: str | None = None,[m
[31m-        hidden: bool = False,[m
[31m-        show_choices: bool = True,[m
[31m-        show_envvar: bool = False,[m
[31m-        deprecated: bool | str = False,[m
[31m-        **attrs: t.Any,[m
[31m-    ) -> None:[m
[31m-        if help:[m
[31m-            help = inspect.cleandoc(help)[m
[31m-[m
[31m-        default_is_missing = "default" not in attrs[m
[31m-        super().__init__([m
[31m-            param_decls, type=type, multiple=multiple, deprecated=deprecated, **attrs[m
[31m-        )[m
[31m-[m
[31m-        if prompt is True:[m
[31m-            if self.name is None:[m
[31m-                raise TypeError("'name' is required with 'prompt=True'.")[m
[31m-[m
[31m-            prompt_text: str | None = self.name.replace("_", " ").capitalize()[m
[31m-        elif prompt is False:[m
[31m-            prompt_text = None[m
[31m-        else:[m
[31m-            prompt_text = prompt[m
[31m-[m
[31m-        if deprecated:[m
[31m-            deprecated_message = ([m
[31m-                f"(DEPRECATED: {deprecated})"[m
[31m-                if isinstance(deprecated, str)[m
[31m-                else "(DEPRECATED)"[m
[31m-            )[m
[31m-            help = help + deprecated_message if help is not None else deprecated_message[m
[31m-[m
[31m-        self.prompt = prompt_text[m
[31m-        self.confirmation_prompt = confirmation_prompt[m
[31m-        self.prompt_required = prompt_required[m
[31m-        self.hide_input = hide_input[m
[31m-        self.hidden = hidden[m
[31m-[m
[31m-        # If prompt is enabled but not required, then the option can be[m
[31m-        # used as a flag to indicate using prompt or flag_value.[m
[31m-        self._flag_needs_value = self.prompt is not None and not self.prompt_required[m
[31m-[m
[31m-        if is_flag is None:[m
[31m-            if flag_value is not None:[m
[31m-                # Implicitly a flag because flag_value was set.[m
[31m-                is_flag = True[m
[31m-            elif self._flag_needs_value:[m
[31m-                # Not a flag, but when used as a flag it shows a prompt.[m
[31m-                is_flag = False[m
[31m-            else:[m
[31m-                # Implicitly a flag because flag options were given.[m
[31m-                is_flag = bool(self.secondary_opts)[m
[31m-        elif is_flag is False and not self._flag_needs_value:[m
[31m-            # Not a flag, and prompt is not enabled, can be used as a[m
[31m-            # flag if flag_value is set.[m
[31m-            self._flag_needs_value = flag_value is not None[m
[31m-[m
[31m-        self.default: t.Any | t.Callable[[], t.Any][m
[31m-[m
[31m-        if is_flag and default_is_missing and not self.required:[m
[31m-            if multiple:[m
[31m-                self.default = ()[m
[31m-            else:[m
[31m-                self.default = False[m
[31m-[m
[31m-        self.type: types.ParamType[m
[31m-        if is_flag and type is None:[m
[31m-            if flag_value is None:[m
[31m-                flag_value = not self.default[m
[31m-            # Re-guess the type from the flag value instead of the[m
[31m-            # default.[m
[31m-            self.type = types.convert_type(None, flag_value)[m
[31m-[m
[31m-        self.is_flag: bool = is_flag[m
[31m-        self.is_bool_flag: bool = is_flag and isinstance(self.type, types.BoolParamType)[m
[31m-        self.flag_value: t.Any = flag_value[m
[31m-[m
[31m-        # Counting[m
[31m-        self.count = count[m
[31m-        if count:[m
[31m-            if type is None:[m
[31m-                self.type = types.IntRange(min=0)[m
[31m-            if default_is_missing:[m
[31m-                self.default = 0[m
[31m-[m
[31m-        self.allow_from_autoenv = allow_from_autoenv[m
[31m-        self.help = help[m
[31m-        self.show_default = show_default[m
[31m-        self.show_choices = show_choices[m
[31m-        self.show_envvar = show_envvar[m
[31m-[m
[31m-        if __debug__:[m
[31m-            if deprecated and prompt:[m
[31m-                raise ValueError("`deprecated` options cannot use `prompt`.")[m
[31m-[m
[31m-            if self.nargs == -1:[m
[31m-                raise TypeError("nargs=-1 is not supported for options.")[m
[31m-[m
[31m-            if self.prompt and self.is_flag and not self.is_bool_flag:[m
[31m-                raise TypeError("'prompt' is not valid for non-boolean flag.")[m
[31m-[m
[31m-            if not self.is_bool_flag and self.secondary_opts:[m
[31m-                raise TypeError("Secondary flag is not valid for non-boolean flag.")[m
[31m-[m
[31m-            if self.is_bool_flag and self.hide_input and self.prompt is not None:[m
[31m-                raise TypeError([m
[31m-                    "'prompt' with 'hide_input' is not valid for boolean flag."[m
[31m-                )[m
[31m-[m
[31m-            if self.count:[m
[31m-                if self.multiple:[m
[31m-                    raise TypeError("'count' is not valid with 'multiple'.")[m
[31m-[m
[31m-                if self.is_flag:[m
[31m-                    raise TypeError("'count' is not valid with 'is_flag'.")[m
[31m-[m
[31m-    def to_info_dict(self) -> dict[str, t.Any]:[m
[31m-        info_dict = super().to_info_dict()[m
[31m-        info_dict.update([m
[31m-            help=self.help,[m
[31m-            prompt=self.prompt,[m
[31m-            is_flag=self.is_flag,[m
[31m-            flag_value=self.flag_value,[m
[31m-            count=self.count,[m
[31m-            hidden=self.hidden,[m
[31m-        )[m
[31m-        return info_dict[m
[31m-[m
[31m-    def get_error_hint(self, ctx: Context) -> str:[m
[31m-        result = super().get_error_hint(ctx)[m
[31m-        if self.show_envvar:[m
[31m-            result += f" (env var: '{self.envvar}')"[m
[31m-        return result[m
[31m-[m
[31m-    def _parse_decls([m
[31m-        self, decls: cabc.Sequence[str], expose_value: bool[m
[31m-    ) -> tuple[str | None, list[str], list[str]]:[m
[31m-        opts = [][m
[31m-        secondary_opts = [][m
[31m-        name = None[m
[31m-        possible_names = [][m
[31m-[m
[31m-        for decl in decls:[m
[31m-            if decl.isidentifier():[m
[31m-                if name is not None:[m
[31m-                    raise TypeError(f"Name '{name}' defined twice")[m
[31m-                name = decl[m
[31m-            else:[m
[31m-                split_char = ";" if decl[:1] == "/" else "/"[m
[31m-                if split_char in decl:[m
[31m-                    first, second = decl.split(split_char, 1)[m
[31m-                    first = first.rstrip()[m
[31m-                    if first:[m
[31m-                        possible_names.append(_split_opt(first))[m
[31m-                        opts.append(first)[m
[31m-                    second = second.lstrip()[m
[31m-                    if second:[m
[31m-                        secondary_opts.append(second.lstrip())[m
[31m-                    if first == second:[m
[31m-                        raise ValueError([m
[31m-                            f"Boolean option {decl!r} cannot use the"[m
[31m-                            " same flag for true/false."[m
[31m-                        )[m
[31m-                else:[m
[31m-                    possible_names.append(_split_opt(decl))[m
[31m-                    opts.append(decl)[m
[31m-[m
[31m-        if name is None and possible_names:[m
[31m-            possible_names.sort(key=lambda x: -len(x[0]))  # group long options first[m
[31m-            name = possible_names[0][1].replace("-", "_").lower()[m
[31m-            if not name.isidentifier():[m
[31m-                name = None[m
[31m-[m
[31m-        if name is None:[m
[31m-            if not expose_value:[m
[31m-                return None, opts, secondary_opts[m
[31m-            raise TypeError([m
[31m-                f"Could not determine name for option with declarations {decls!r}"[m
[31m-            )[m
[31m-[m
[31m-        if not opts and not secondary_opts:[m
[31m-            raise TypeError([m
[31m-                f"No options defined but a name was passed ({name})."[m
[31m-                " Did you mean to declare an argument instead? Did"[m
[31m-                f" you mean to pass '--{name}'?"[m
[31m-            )[m
[31m-[m
[31m-        return name, opts, secondary_opts[m
[31m-[m
[31m-    def add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:[m
[31m-        if self.multiple:[m
[31m-            action = "append"[m
[31m-        elif self.count:[m
[31m-            action = "count"[m
[31m-        else:[m
[31m-            action = "store"[m
[31m-[m
[31m-        if self.is_flag:[m
[31m-            action = f"{action}_const"[m
[31m-[m
[31m-            if self.is_bool_flag and self.secondary_opts:[m
[31m-                parser.add_option([m
[31m-                    obj=self, opts=self.opts, dest=self.name, action=action, const=True[m
[31m-                )[m
[31m-                parser.add_option([m
[31m-                    obj=self,[m
[31m-                    opts=self.secondary_opts,[m
[31m-                    dest=self.name,[m
[31m-                    action=action,[m
[31m-                    const=False,[m
[31m-                )[m
[31m-            else:[m
[31m-                parser.add_option([m
[31m-                    obj=self,[m
[31m-                    opts=self.opts,[m
[31m-                    dest=self.name,[m
[31m-                    action=action,[m
[31m-                    const=self.flag_value,[m
[31m-                )[m
[31m-        else:[m
[31m-            parser.add_option([m
[31m-                obj=self,[m
[31m-                opts=self.opts,[m
[31m-                dest=self.name,[m
[31m-                action=action,[m
[31m-                nargs=self.nargs,[m
[31m-            )[m
[31m-[m
[31m-    def get_help_record(self, ctx: Context) -> tuple[str, str] | None:[m
[31m-        if self.hidden:[m
[31m-            return None[m
[31m-[m
[31m-        any_prefix_is_slash = False[m
[31m-[m
[31m-        def _write_opts(opts: cabc.Sequence[str]) -> str:[m
[31m-            nonlocal any_prefix_is_slash[m
[31m-[m
[31m-            rv, any_slashes = join_options(opts)[m
[31m-[m
[31m-            if any_slashes:[m
[31m-                any_prefix_is_slash = True[m
[31m-[m
[31m-            if not self.is_flag and not self.count:[m
[31m-                rv += f" {self.make_metavar(ctx=ctx)}"[m
[31m-[m
[31m-            return rv[m
[31m-[m
[31m-        rv = [_write_opts(self.opts)][m
[31m-[m
[31m-        if self.secondary_opts:[m
[31m-            rv.append(_write_opts(self.secondary_opts))[m
[31m-[m
[31m-        help = self.help or ""[m
[31m-[m
[31m-        extra = self.get_help_extra(ctx)[m
[31m-        extra_items = [][m
[31m-        if "envvars" in extra:[m
[31m-            extra_items.append([m
[31m-                _("env var: {var}").format(var=", ".join(extra["envvars"]))[m
[31m-            )[m
[31m-        if "default" in extra:[m
[31m-            extra_items.append(_("default: {default}").format(default=extra["default"]))[m
[31m-        if "range" in extra:[m
[31m-            extra_items.append(extra["range"])[m
[31m-        if "required" in extra:[m
[31m-            extra_items.append(_(extra["required"]))[m
[31m-[m
[31m-        if extra_items:[m
[31m-            extra_str = "; ".join(extra_items)[m
[31m-            help = f"{help}  [{extra_str}]" if help else f"[{extra_str}]"[m
[31m-[m
[31m-        return ("; " if any_prefix_is_slash else " / ").join(rv), help[m
[31m-[m
[31m-    def get_help_extra(self, ctx: Context) -> types.OptionHelpExtra:[m
[31m-        extra: types.OptionHelpExtra = {}[m
[31m-[m
[31m-        if self.show_envvar:[m
[31m-            envvar = self.envvar[m
[31m-[m
[31m-            if envvar is None:[m
[31m-                if ([m
[31m-                    self.allow_from_autoenv[m
[31m-                    and ctx.auto_envvar_prefix is not None[m
[31m-                    and self.name is not None[m
[31m-                ):[m
[31m-                    envvar = f"{ctx.auto_envvar_prefix}_{self.name.upper()}"[m
[31m-[m
[31m-            if envvar is not None:[m
[31m-                if isinstance(envvar, str):[m
[31m-                    extra["envvars"] = (envvar,)[m
[31m-                else:[m
[31m-                    extra["envvars"] = tuple(str(d) for d in envvar)[m
[31m-[m
[31m-        # Temporarily enable resilient parsing to avoid type casting[m
[31m-        # failing for the default. Might be possible to extend this to[m
[31m-        # help formatting in general.[m
[31m-        resilient = ctx.resilient_parsing[m
[31m-        ctx.resilient_parsing = True[m
[31m-[m
[31m-        try:[m
[31m-            default_value = self.get_default(ctx, call=False)[m
[31m-        finally:[m
[31m-            ctx.resilient_parsing = resilient[m
[31m-[m
[31m-        show_default = False[m
[31m-        show_default_is_str = False[m
[31m-[m
[31m-        if self.show_default is not None:[m
[31m-            if isinstance(self.show_default, str):[m
[31m-                show_default_is_str = show_default = True[m
[31m-            else:[m
[31m-                show_default = self.show_default[m
[31m-        elif ctx.show_default is not None:[m
[31m-            show_default = ctx.show_default[m
[31m-[m
[31m-        if show_default_is_str or (show_default and (default_value is not None)):[m
[31m-            if show_default_is_str:[m
[31m-                default_string = f"({self.show_default})"[m
[31m-            elif isinstance(default_value, (list, tuple)):[m
[31m-                default_string = ", ".join(str(d) for d in default_value)[m
[31m-            elif inspect.isfunction(default_value):[m
[31m-                default_string = _("(dynamic)")[m
[31m-            elif self.is_bool_flag and self.secondary_opts:[m
[31m-                # For boolean flags that have distinct True/False opts,[m
[31m-                # use the opt without prefix instead of the value.[m
[31m-                default_string = _split_opt([m
[31m-                    (self.opts if default_value else self.secondary_opts)[0][m
[31m-                )[1][m
[31m-            elif self.is_bool_flag and not self.secondary_opts and not default_value:[m
[31m-                default_string = ""[m
[31m-            elif default_value == "":[m
[31m-                default_string = '""'[m
[31m-            else:[m
[31m-                default_string = str(default_value)[m
[31m-[m
[31m-            if default_string:[m
[31m-                extra["default"] = default_string[m
[31m-[m
[31m-        if ([m
[31m-            isinstance(self.type, types._NumberRangeBase)[m
[31m-            # skip count with default range type[m
[31m-            and not (self.count and self.type.min == 0 and self.type.max is None)[m
[31m-        ):[m
[31m-            range_str = self.type._describe_range()[m
[31m-[m
[31m-            if range_str:[m
[31m-                extra["range"] = range_str[m
[31m-[m
[31m-        if self.required:[m
[31m-            extra["required"] = "required"[m
[31m-[m
[31m-        return extra[m
[31m-[m
[31m-    @t.overload[m
[31m-    def get_default([m
[31m-        self, ctx: Context, call: t.Literal[True] = True[m
[31m-    ) -> t.Any | None: ...[m
[31m-[m
[31m-    @t.overload[m
[31m-    def get_default([m
[31m-        self, ctx: Context, call: bool = ...[m
[31m-    ) -> t.Any | t.Callable[[], t.Any] | None: ...[m
[31m-[m
[31m-    def get_default([m
[31m-        self, ctx: Context, call: bool = True[m
[31m-    ) -> t.Any | t.Callable[[], t.Any] | None:[m
[31m-        # If we're a non boolean flag our default is more complex because[m
[31m-        # we need to look at all flags in the same group to figure out[m
[31m-        # if we're the default one in which case we return the flag[m
[31m-        # value as default.[m
[31m-        if self.is_flag and not self.is_bool_flag:[m
[31m-            for param in ctx.command.params:[m
[31m-                if param.name == self.name and param.default:[m
[31m-                    return t.cast(Option, param).flag_value[m
[31m-[m
[31m-            return None[m
[31m-[m
[31m-        return super().get_default(ctx, call=call)[m
[31m-[m
[31m-    def prompt_for_value(self, ctx: Context) -> t.Any:[m
[31m-        """This is an alternative flow that can be activated in the full[m
[31m-        value processing if a value does not exist.  It will prompt the[m
[31m-        user until a valid value exists and then returns the processed[m
[31m-        value as result.[m
[31m-        """[m
[31m-        assert self.prompt is not None[m
[31m-[m
[31m-        # Calculate the default before prompting anything to be stable.[m
[31m-        default = self.get_default(ctx)[m
[31m-[m
[31m-        # If this is a prompt for a flag we need to handle this[m
[31m-        # differently.[m
[31m-        if self.is_bool_flag:[m
[31m-            return confirm(self.prompt, default)[m
[31m-[m
[31m-        # If show_default is set to True/False, provide this to `prompt` as well. For[m
[31m-        # non-bool values of `show_default`, we use `prompt`'s default behavior[m
[31m-        prompt_kwargs: t.Any = {}[m
[31m-        if isinstance(self.show_default, bool):[m
[31m-            prompt_kwargs["show_default"] = self.show_default[m
[31m-[m
[31m-        return prompt([m
[31m-            self.prompt,[m
[31m-            default=default,[m
[31m-            type=self.type,[m
[31m-            hide_input=self.hide_input,[m
[31m-            show_choices=self.show_choices,[m
[31m-            confirmation_prompt=self.confirmation_prompt,[m
[31m-            value_proc=lambda x: self.process_value(ctx, x),[m
[31m-            **prompt_kwargs,[m
[31m-        )[m
[31m-[m
[31m-    def resolve_envvar_value(self, ctx: Context) -> str | None:[m
[31m-        rv = super().resolve_envvar_value(ctx)[m
[31m-[m
[31m-        if rv is not None:[m
[31m-            if self.is_flag and self.flag_value:[m
[31m-                return str(self.flag_value)[m
[31m-            return rv[m
[31m-[m
[31m-        if ([m
[31m-            self.allow_from_autoenv[m
[31m-            and ctx.auto_envvar_prefix is not None[m
[31m-            and self.name is not None[m
[31m-        ):[m
[31m-            envvar = f"{ctx.auto_envvar_prefix}_{self.name.upper()}"[m
[31m-            rv = os.environ.get(envvar)[m
[31m-[m
[31m-            if rv:[m
[31m-                return rv[m
[31m-[m
[31m-        return None[m
[31m-[m
[31m-    def value_from_envvar(self, ctx: Context) -> t.Any | None:[m
[31m-        rv: t.Any | None = self.resolve_envvar_value(ctx)[m
[31m-[m
[31m-        if rv is None:[m
[31m-            return None[m
[31m-[m
[31m-        value_depth = (self.nargs != 1) + bool(self.multiple)[m
[31m-[m
[31m-        if value_depth > 0:[m
[31m-            rv = self.type.split_envvar_value(rv)[m
[31m-[m
[31m-            if self.multiple and self.nargs != 1:[m
[31m-                rv = batch(rv, self.nargs)[m
[31m-[m
[31m-        return rv[m
[31m-[m
[31m-    def consume_value([m
[31m-        self, ctx: Context, opts: cabc.Mapping[str, Parameter][m
[31m-    ) -> tuple[t.Any, ParameterSource]:[m
[31m-        value, source = super().consume_value(ctx, opts)[m
[31m-[m
[31m-        # The parser will emit a sentinel value if the option can be[m
[31m-        # given as a flag without a value. This is different from None[m
[31m-        # to distinguish from the flag not being given at all.[m
[31m-        if value is _flag_needs_value:[m
[31m-            if self.prompt is not None and not ctx.resilient_parsing:[m
[31m-                value = self.prompt_for_value(ctx)[m
[31m-                source = ParameterSource.PROMPT[m
[31m-            else:[m
[31m-                value = self.flag_value[m
[31m-                source = ParameterSource.COMMANDLINE[m
[31m-[m
[31m-        elif ([m
[31m-            self.multiple[m
[31m-            and value is not None[m
[31m-            and any(v is _flag_needs_value for v in value)[m
[31m-        ):[m
[31m-            value = [self.flag_value if v is _flag_needs_value else v for v in value][m
[31m-            source = ParameterSource.COMMANDLINE[m
[31m-[m
[31m-        # The value wasn't set, or used the param's default, prompt if[m
[31m-        # prompting is enabled.[m
[31m-        elif ([m
[31m-            source in {None, ParameterSource.DEFAULT}[m
[31m-            and self.prompt is not None[m
[31m-            and (self.required or self.prompt_required)[m
[31m-            and not ctx.resilient_parsing[m
[31m-        ):[m
[31m-            value = self.prompt_for_value(ctx)[m
[31m-            source = ParameterSource.PROMPT[m
[31m-[m
[31m-        return value, source[m
[31m-[m
[31m-[m
[31m-class Argument(Parameter):[m
[31m-    """Arguments are positional parameters to a command.  They generally[m
[31m-    provide fewer features than options but can have infinite ``nargs``[m
[31m-    and are required by default.[m
[31m-[m
[31m-    All parameters are passed onwards to the constructor of :class:`Parameter`.[m
[31m-    """[m
[31m-[m
[31m-    param_type_name = "argument"[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        param_decls: cabc.Sequence[str],[m
[31m-        required: bool | None = None,[m
[31m-        **attrs: t.Any,[m
[31m-    ) -> None:[m
[31m-        if required is None:[m
[31m-            if attrs.get("default") is not None:[m
[31m-                required = False[m
[31m-            else:[m
[31m-                required = attrs.get("nargs", 1) > 0[m
[31m-[m
[31m-        if "multiple" in attrs:[m
[31m-            raise TypeError("__init__() got an unexpected keyword argument 'multiple'.")[m
[31m-[m
[31m-        super().__init__(param_decls, required=required, **attrs)[m
[31m-[m
[31m-        if __debug__:[m
[31m-            if self.default is not None and self.nargs == -1:[m
[31m-                raise TypeError("'default' is not supported for nargs=-1.")[m
[31m-[m
[31m-    @property[m
[31m-    def human_readable_name(self) -> str:[m
[31m-        if self.metavar is not None:[m
[31m-            return self.metavar[m
[31m-        return self.name.upper()  # type: ignore[m
[31m-[m
[31m-    def make_metavar(self, ctx: Context) -> str:[m
[31m-        if self.metavar is not None:[m
[31m-            return self.metavar[m
[31m-        var = self.type.get_metavar(param=self, ctx=ctx)[m
[31m-        if not var:[m
[31m-            var = self.name.upper()  # type: ignore[m
[31m-        if self.deprecated:[m
[31m-            var += "!"[m
[31m-        if not self.required:[m
[31m-            var = f"[{var}]"[m
[31m-        if self.nargs != 1:[m
[31m-            var += "..."[m
[31m-        return var[m
[31m-[m
[31m-    def _parse_decls([m
[31m-        self, decls: cabc.Sequence[str], expose_value: bool[m
[31m-    ) -> tuple[str | None, list[str], list[str]]:[m
[31m-        if not decls:[m
[31m-            if not expose_value:[m
[31m-                return None, [], [][m
[31m-            raise TypeError("Argument is marked as exposed, but does not have a name.")[m
[31m-        if len(decls) == 1:[m
[31m-            name = arg = decls[0][m
[31m-            name = name.replace("-", "_").lower()[m
[31m-        else:[m
[31m-            raise TypeError([m
[31m-                "Arguments take exactly one parameter declaration, got"[m
[31m-                f" {len(decls)}: {decls}."[m
[31m-            )[m
[31m-        return name, [arg], [][m
[31m-[m
[31m-    def get_usage_pieces(self, ctx: Context) -> list[str]:[m
[31m-        return [self.make_metavar(ctx)][m
[31m-[m
[31m-    def get_error_hint(self, ctx: Context) -> str:[m
[31m-        return f"'{self.make_metavar(ctx)}'"[m
[31m-[m
[31m-    def add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:[m
[31m-        parser.add_argument(dest=self.name, nargs=self.nargs, obj=self)[m
[31m-[m
[31m-[m
[31m-def __getattr__(name: str) -> object:[m
[31m-    import warnings[m
[31m-[m
[31m-    if name == "BaseCommand":[m
[31m-        warnings.warn([m
[31m-            "'BaseCommand' is deprecated and will be removed in Click 9.0. Use"[m
[31m-            " 'Command' instead.",[m
[31m-            DeprecationWarning,[m
[31m-            stacklevel=2,[m
[31m-        )[m
[31m-        return _BaseCommand[m
[31m-[m
[31m-    if name == "MultiCommand":[m
[31m-        warnings.warn([m
[31m-            "'MultiCommand' is deprecated and will be removed in Click 9.0. Use"[m
[31m-            " 'Group' instead.",[m
[31m-            DeprecationWarning,[m
[31m-            stacklevel=2,[m
[31m-        )[m
[31m-        return _MultiCommand[m
[31m-[m
[31m-    raise AttributeError(name)[m
[1mdiff --git a/venv/Lib/site-packages/click/decorators.py b/venv/Lib/site-packages/click/decorators.py[m
[1mdeleted file mode 100644[m
[1mindex 21f4c34..0000000[m
[1m--- a/venv/Lib/site-packages/click/decorators.py[m
[1m+++ /dev/null[m
[36m@@ -1,551 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import inspect[m
[31m-import typing as t[m
[31m-from functools import update_wrapper[m
[31m-from gettext import gettext as _[m
[31m-[m
[31m-from .core import Argument[m
[31m-from .core import Command[m
[31m-from .core import Context[m
[31m-from .core import Group[m
[31m-from .core import Option[m
[31m-from .core import Parameter[m
[31m-from .globals import get_current_context[m
[31m-from .utils import echo[m
[31m-[m
[31m-if t.TYPE_CHECKING:[m
[31m-    import typing_extensions as te[m
[31m-[m
[31m-    P = te.ParamSpec("P")[m
[31m-[m
[31m-R = t.TypeVar("R")[m
[31m-T = t.TypeVar("T")[m
[31m-_AnyCallable = t.Callable[..., t.Any][m
[31m-FC = t.TypeVar("FC", bound="_AnyCallable | Command")[m
[31m-[m
[31m-[m
[31m-def pass_context(f: t.Callable[te.Concatenate[Context, P], R]) -> t.Callable[P, R]:[m
[31m-    """Marks a callback as wanting to receive the current context[m
[31m-    object as first argument.[m
[31m-    """[m
[31m-[m
[31m-    def new_func(*args: P.args, **kwargs: P.kwargs) -> R:[m
[31m-        return f(get_current_context(), *args, **kwargs)[m
[31m-[m
[31m-    return update_wrapper(new_func, f)[m
[31m-[m
[31m-[m
[31m-def pass_obj(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:[m
[31m-    """Similar to :func:`pass_context`, but only pass the object on the[m
[31m-    context onwards (:attr:`Context.obj`).  This is useful if that object[m
[31m-    represents the state of a nested system.[m
[31m-    """[m
[31m-[m
[31m-    def new_func(*args: P.args, **kwargs: P.kwargs) -> R:[m
[31m-        return f(get_current_context().obj, *args, **kwargs)[m
[31m-[m
[31m-    return update_wrapper(new_func, f)[m
[31m-[m
[31m-[m
[31m-def make_pass_decorator([m
[31m-    object_type: type[T], ensure: bool = False[m
[31m-) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:[m
[31m-    """Given an object type this creates a decorator that will work[m
[31m-    similar to :func:`pass_obj` but instead of passing the object of the[m
[31m-    current context, it will find the innermost context of type[m
[31m-    :func:`object_type`.[m
[31m-[m
[31m-    This generates a decorator that works roughly like this::[m
[31m-[m
[31m-        from functools import update_wrapper[m
[31m-[m
[31m-        def decorator(f):[m
[31m-            @pass_context[m
[31m-            def new_func(ctx, *args, **kwargs):[m
[31m-                obj = ctx.find_object(object_type)[m
[31m-                return ctx.invoke(f, obj, *args, **kwargs)[m
[31m-            return update_wrapper(new_func, f)[m
[31m-        return decorator[m
[31m-[m
[31m-    :param object_type: the type of the object to pass.[m
[31m-    :param ensure: if set to `True`, a new object will be created and[m
[31m-                   remembered on the context if it's not there yet.[m
[31m-    """[m
[31m-[m
[31m-    def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:[m
[31m-        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:[m
[31m-            ctx = get_current_context()[m
[31m-[m
[31m-            obj: T | None[m
[31m-            if ensure:[m
[31m-                obj = ctx.ensure_object(object_type)[m
[31m-            else:[m
[31m-                obj = ctx.find_object(object_type)[m
[31m-[m
[31m-            if obj is None:[m
[31m-                raise RuntimeError([m
[31m-                    "Managed to invoke callback without a context"[m
[31m-                    f" object of type {object_type.__name__!r}"[m
[31m-                    " existing."[m
[31m-                )[m
[31m-[m
[31m-            return ctx.invoke(f, obj, *args, **kwargs)[m
[31m-[m
[31m-        return update_wrapper(new_func, f)[m
[31m-[m
[31m-    return decorator[m
[31m-[m
[31m-[m
[31m-def pass_meta_key([m
[31m-    key: str, *, doc_description: str | None = None[m
[31m-) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:[m
[31m-    """Create a decorator that passes a key from[m
[31m-    :attr:`click.Context.meta` as the first argument to the decorated[m
[31m-    function.[m
[31m-[m
[31m-    :param key: Key in ``Context.meta`` to pass.[m
[31m-    :param doc_description: Description of the object being passed,[m
[31m-        inserted into the decorator's docstring. Defaults to "the 'key'[m
[31m-        key from Context.meta".[m
[31m-[m
[31m-    .. versionadded:: 8.0[m
[31m-    """[m
[31m-[m
[31m-    def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:[m
[31m-        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:[m
[31m-            ctx = get_current_context()[m
[31m-            obj = ctx.meta[key][m
[31m-            return ctx.invoke(f, obj, *args, **kwargs)[m
[31m-[m
[31m-        return update_wrapper(new_func, f)[m
[31m-[m
[31m-    if doc_description is None:[m
[31m-        doc_description = f"the {key!r} key from :attr:`click.Context.meta`"[m
[31m-[m
[31m-    decorator.__doc__ = ([m
[31m-        f"Decorator that passes {doc_description} as the first argument"[m
[31m-        " to the decorated function."[m
[31m-    )[m
[31m-    return decorator[m
[31m-[m
[31m-[m
[31m-CmdType = t.TypeVar("CmdType", bound=Command)[m
[31m-[m
[31m-[m
[31m-# variant: no call, directly as decorator for a function.[m
[31m-@t.overload[m
[31m-def command(name: _AnyCallable) -> Command: ...[m
[31m-[m
[31m-[m
[31m-# variant: with positional name and with positional or keyword cls argument:[m
[31m-# @command(namearg, CommandCls, ...) or @command(namearg, cls=CommandCls, ...)[m
[31m-@t.overload[m
[31m-def command([m
[31m-    name: str | None,[m
[31m-    cls: type[CmdType],[m
[31m-    **attrs: t.Any,[m
[31m-) -> t.Callable[[_AnyCallable], CmdType]: ...[m
[31m-[m
[31m-[m
[31m-# variant: name omitted, cls _must_ be a keyword argument, @command(cls=CommandCls, ...)[m
[31m-@t.overload[m
[31m-def command([m
[31m-    name: None = None,[m
[31m-    *,[m
[31m-    cls: type[CmdType],[m
[31m-    **attrs: t.Any,[m
[31m-) -> t.Callable[[_AnyCallable], CmdType]: ...[m
[31m-[m
[31m-[m
[31m-# variant: with optional string name, no cls argument provided.[m
[31m-@t.overload[m
[31m-def command([m
[31m-    name: str | None = ..., cls: None = None, **attrs: t.Any[m
[31m-) -> t.Callable[[_AnyCallable], Command]: ...[m
[31m-[m
[31m-[m
[31m-def command([m
[31m-    name: str | _AnyCallable | None = None,[m
[31m-    cls: type[CmdType] | None = None,[m
[31m-    **attrs: t.Any,[m
[31m-) -> Command | t.Callable[[_AnyCallable], Command | CmdType]:[m
[31m-    r"""Creates a new :class:`Command` and uses the decorated function as[m
[31m-    callback.  This will also automatically attach all decorated[m
[31m-    :func:`option`\s and :func:`argument`\s as parameters to the command.[m
[31m-[m
[31m-    The name of the command defaults to the name of the function, converted to[m
[31m-    lowercase, with underscores ``_`` replaced by dashes ``-``, and the suffixes[m
[31m-    ``_command``, ``_cmd``, ``_group``, and ``_grp`` are removed. For example,[m
[31m-    ``init_data_command`` becomes ``init-data``.[m
[31m-[m
[31m-    All keyword arguments are forwarded to the underlying command class.[m
[31m-    For the ``params`` argument, any decorated params are appended to[m
[31m-    the end of the list.[m
[31m-[m
[31m-    Once decorated the function turns into a :class:`Command` instance[m
[31m-    that can be invoked as a command line utility or be attached to a[m
[31m-    command :class:`Group`.[m
[31m-[m
[31m-    :param name: The name of the command. Defaults to modifying the function's[m
[31m-        name as described above.[m
[31m-    :param cls: The command class to create. Defaults to :class:`Command`.[m
[31m-[m
[31m-    .. versionchanged:: 8.2[m
[31m-        The suffixes ``_command``, ``_cmd``, ``_group``, and ``_grp`` are[m
[31m-        removed when generating the name.[m
[31m-[m
[31m-    .. versionchanged:: 8.1[m
[31m-        This decorator can be applied without parentheses.[m
[31m-[m
[31m-    .. versionchanged:: 8.1[m
[31m-        The ``params`` argument can be used. Decorated params are[m
[31m-        appended to the end of the list.[m
[31m-    """[m
[31m-[m
[31m-    func: t.Callable[[_AnyCallable], t.Any] | None = None[m
[31m-[m
[31m-    if callable(name):[m
[31m-        func = name[m
[31m-        name = None[m
[31m-        assert cls is None, "Use 'command(cls=cls)(callable)' to specify a class."[m
[31m-        assert not attrs, "Use 'command(**kwargs)(callable)' to provide arguments."[m
[31m-[m
[31m-    if cls is None:[m
[31m-        cls = t.cast("type[CmdType]", Command)[m
[31m-[m
[31m-    def decorator(f: _AnyCallable) -> CmdType:[m
[31m-        if isinstance(f, Command):[m
[31m-            raise TypeError("Attempted to convert a callback into a command twice.")[m
[31m-[m
[31m-        attr_params = attrs.pop("params", None)[m
[31m-        params = attr_params if attr_params is not None else [][m
[31m-[m
[31m-        try:[m
[31m-            decorator_params = f.__click_params__  # type: ignore[m
[31m-        except AttributeError:[m
[31m-            pass[m
[31m-        else:[m
[31m-            del f.__click_params__  # type: ignore[m
[31m-            params.extend(reversed(decorator_params))[m
[31m-[m
[31m-        if attrs.get("help") is None:[m
[31m-            attrs["help"] = f.__doc__[m
[31m-[m
[31m-        if t.TYPE_CHECKING:[m
[31m-            assert cls is not None[m
[31m-            assert not callable(name)[m
[31m-[m
[31m-        if name is not None:[m
[31m-            cmd_name = name[m
[31m-        else:[m
[31m-            cmd_name = f.__name__.lower().replace("_", "-")[m
[31m-            cmd_left, sep, suffix = cmd_name.rpartition("-")[m
[31m-[m
[31m-            if sep and suffix in {"command", "cmd", "group", "grp"}:[m
[31m-                cmd_name = cmd_left[m
[31m-[m
[31m-        cmd = cls(name=cmd_name, callback=f, params=params, **attrs)[m
[31m-        cmd.__doc__ = f.__doc__[m
[31m-        return cmd[m
[31m-[m
[31m-    if func is not None:[m
[31m-        return decorator(func)[m
[31m-[m
[31m-    return decorator[m
[31m-[m
[31m-[m
[31m-GrpType = t.TypeVar("GrpType", bound=Group)[m
[31m-[m
[31m-[m
[31m-# variant: no call, directly as decorator for a function.[m
[31m-@t.overload[m
[31m-def group(name: _AnyCallable) -> Group: ...[m
[31m-[m
[31m-[m
[31m-# variant: with positional name and with positional or keyword cls argument:[m
[31m-# @group(namearg, GroupCls, ...) or @group(namearg, cls=GroupCls, ...)[m
[31m-@t.overload[m
[31m-def group([m
[31m-    name: str | None,[m
[31m-    cls: type[GrpType],[m
[31m-    **attrs: t.Any,[m
[31m-) -> t.Callable[[_AnyCallable], GrpType]: ...[m
[31m-[m
[31m-[m
[31m-# variant: name omitted, cls _must_ be a keyword argument, @group(cmd=GroupCls, ...)[m
[31m-@t.overload[m
[31m-def group([m
[31m-    name: None = None,[m
[31m-    *,[m
[31m-    cls: type[GrpType],[m
[31m-    **attrs: t.Any,[m
[31m-) -> t.Callable[[_AnyCallable], GrpType]: ...[m
[31m-[m
[31m-[m
[31m-# variant: with optional string name, no cls argument provided.[m
[31m-@t.overload[m
[31m-def group([m
[31m-    name: str | None = ..., cls: None = None, **attrs: t.Any[m
[31m-) -> t.Callable[[_AnyCallable], Group]: ...[m
[31m-[m
[31m-[m
[31m-def group([m
[31m-    name: str | _AnyCallable | None = None,[m
[31m-    cls: type[GrpType] | None = None,[m
[31m-    **attrs: t.Any,[m
[31m-) -> Group | t.Callable[[_AnyCallable], Group | GrpType]:[m
[31m-    """Creates a new :class:`Group` with a function as callback.  This[m
[31m-    works otherwise the same as :func:`command` just that the `cls`[m
[31m-    parameter is set to :class:`Group`.[m
[31m-[m
[31m-    .. versionchanged:: 8.1[m
[31m-        This decorator can be applied without parentheses.[m
[31m-    """[m
[31m-    if cls is None:[m
[31m-        cls = t.cast("type[GrpType]", Group)[m
[31m-[m
[31m-    if callable(name):[m
[31m-        return command(cls=cls, **attrs)(name)[m
[31m-[m
[31m-    return command(name, cls, **attrs)[m
[31m-[m
[31m-[m
[31m-def _param_memo(f: t.Callable[..., t.Any], param: Parameter) -> None:[m
[31m-    if isinstance(f, Command):[m
[31m-        f.params.append(param)[m
[31m-    else:[m
[31m-        if not hasattr(f, "__click_params__"):[m
[31m-            f.__click_params__ = []  # type: ignore[m
[31m-[m
[31m-        f.__click_params__.append(param)  # type: ignore[m
[31m-[m
[31m-[m
[31m-def argument([m
[31m-    *param_decls: str, cls: type[Argument] | None = None, **attrs: t.Any[m
[31m-) -> t.Callable[[FC], FC]:[m
[31m-    """Attaches an argument to the command.  All positional arguments are[m
[31m-    passed as parameter declarations to :class:`Argument`; all keyword[m
[31m-    arguments are forwarded unchanged (except ``cls``).[m
[31m-    This is equivalent to creating an :class:`Argument` instance manually[m
[31m-    and attaching it to the :attr:`Command.params` list.[m
[31m-[m
[31m-    For the default argument class, refer to :class:`Argument` and[m
[31m-    :class:`Parameter` for descriptions of parameters.[m
[31m-[m
[31m-    :param cls: the argument class to instantiate.  This defaults to[m
[31m-                :class:`Argument`.[m
[31m-    :param param_decls: Passed as positional arguments to the constructor of[m
[31m-        ``cls``.[m
[31m-    :param attrs: Passed as keyword arguments to the constructor of ``cls``.[m
[31m-    """[m
[31m-    if cls is None:[m
[31m-        cls = Argument[m
[31m-[m
[31m-    def decorator(f: FC) -> FC:[m
[31m-        _param_memo(f, cls(param_decls, **attrs))[m
[31m-        return f[m
[31m-[m
[31m-    return decorator[m
[31m-[m
[31m-[m
[31m-def option([m
[31m-    *param_decls: str, cls: type[Option] | None = None, **attrs: t.Any[m
[31m-) -> t.Callable[[FC], FC]:[m
[31m-    """Attaches an option to the command.  All positional arguments are[m
[31m-    passed as parameter declarations to :class:`Option`; all keyword[m
[31m-    arguments are forwarded unchanged (except ``cls``).[m
[31m-    This is equivalent to creating an :class:`Option` instance manually[m
[31m-    and attaching it to the :attr:`Command.params` list.[m
[31m-[m
[31m-    For the default option class, refer to :class:`Option` and[m
[31m-    :class:`Parameter` for descriptions of parameters.[m
[31m-[m
[31m-    :param cls: the option class to instantiate.  This defaults to[m
[31m-                :class:`Option`.[m
[31m-    :param param_decls: Passed as positional arguments to the constructor of[m
[31m-        ``cls``.[m
[31m-    :param attrs: Passed as keyword arguments to the constructor of ``cls``.[m
[31m-    """[m
[31m-    if cls is None:[m
[31m-        cls = Option[m
[31m-[m
[31m-    def decorator(f: FC) -> FC:[m
[31m-        _param_memo(f, cls(param_decls, **attrs))[m
[31m-        return f[m
[31m-[m
[31m-    return decorator[m
[31m-[m
[31m-[m
[31m-def confirmation_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:[m
[31m-    """Add a ``--yes`` option which shows a prompt before continuing if[m
[31m-    not passed. If the prompt is declined, the program will exit.[m
[31m-[m
[31m-    :param param_decls: One or more option names. Defaults to the single[m
[31m-        value ``"--yes"``.[m
[31m-    :param kwargs: Extra arguments are passed to :func:`option`.[m
[31m-    """[m
[31m-[m
[31m-    def callback(ctx: Context, param: Parameter, value: bool) -> None:[m
[31m-        if not value:[m
[31m-            ctx.abort()[m
[31m-[m
[31m-    if not param_decls:[m
[31m-        param_decls = ("--yes",)[m
[31m-[m
[31m-    kwargs.setdefault("is_flag", True)[m
[31m-    kwargs.setdefault("callback", callback)[m
[31m-    kwargs.setdefault("expose_value", False)[m
[31m-    kwargs.setdefault("prompt", "Do you want to continue?")[m
[31m-    kwargs.setdefault("help", "Confirm the action without prompting.")[m
[31m-    return option(*param_decls, **kwargs)[m
[31m-[m
[31m-[m
[31m-def password_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:[m
[31m-    """Add a ``--password`` option which prompts for a password, hiding[m
[31m-    input and asking to enter the value again for confirmation.[m
[31m-[m
[31m-    :param param_decls: One or more option names. Defaults to the single[m
[31m-        value ``"--password"``.[m
[31m-    :param kwargs: Extra arguments are passed to :func:`option`.[m
[31m-    """[m
[31m-    if not param_decls:[m
[31m-        param_decls = ("--password",)[m
[31m-[m
[31m-    kwargs.setdefault("prompt", True)[m
[31m-    kwargs.setdefault("confirmation_prompt", True)[m
[31m-    kwargs.setdefault("hide_input", True)[m
[31m-    return option(*param_decls, **kwargs)[m
[31m-[m
[31m-[m
[31m-def version_option([m
[31m-    version: str | None = None,[m
[31m-    *param_decls: str,[m
[31m-    package_name: str | None = None,[m
[31m-    prog_name: str | None = None,[m
[31m-    message: str | None = None,[m
[31m-    **kwargs: t.Any,[m
[31m-) -> t.Callable[[FC], FC]:[m
[31m-    """Add a ``--version`` option which immediately prints the version[m
[31m-    number and exits the program.[m
[31m-[m
[31m-    If ``version`` is not provided, Click will try to detect it using[m
[31m-    :func:`importlib.metadata.version` to get the version for the[m
[31m-    ``package_name``.[m
[31m-[m
[31m-    If ``package_name`` is not provided, Click will try to detect it by[m
[31m-    inspecting the stack frames. This will be used to detect the[m
[31m-    version, so it must match the name of the installed package.[m
[31m-[m
[31m-    :param version: The version number to show. If not provided, Click[m
[31m-        will try to detect it.[m
[31m-    :param param_decls: One or more option names. Defaults to the single[m
[31m-        value ``"--version"``.[m
[31m-    :param package_name: The package name to detect the version from. If[m
[31m-        not provided, Click will try to detect it.[m
[31m-    :param prog_name: The name of the CLI to show in the message. If not[m
[31m-        provided, it will be detected from the command.[m
[31m-    :param message: The message to show. The values ``%(prog)s``,[m
[31m-        ``%(package)s``, and ``%(version)s`` are available. Defaults to[m
[31m-        ``"%(prog)s, version %(version)s"``.[m
[31m-    :param kwargs: Extra arguments are passed to :func:`option`.[m
[31m-    :raise RuntimeError: ``version`` could not be detected.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        Add the ``package_name`` parameter, and the ``%(package)s``[m
[31m-        value for messages.[m
[31m-[m
[31m-    .. versionchanged:: 8.0[m
[31m-        Use :mod:`importlib.metadata` instead of ``pkg_resources``. The[m
[31m-        version is detected based on the package name, not the entry[m
[31m-        point name. The Python package name must match the installed[m
[31m-        package name, or be passed with ``package_name=``.[m
[31m-    """[m
[31m-    if message is None:[m
[31m-        message = _("%(prog)s, version %(version)s")[m
[31m-[m
[31m-    if version is None and package_name is None:[m
[31m-        frame = inspect.currentframe()[m
[31m-        f_back = frame.f_back if frame is not None else None[m
[31m-        f_globals = f_back.f_globals if f_back is not None else None[m
[31m-        # break reference cycle[m
[31m-        # https://docs.python.org/3/library/inspect.html#the-interpreter-stack[m
[31m-        del frame[m
[31m-[m
[31m-        if f_globals is not None:[m
[31m-            package_name = f_globals.get("__name__")[m
[31m-[m
[31m-            if package_name == "__main__":[m
[31m-                package_name = f_globals.get("__package__")[m
[31m-[m
[31m-            if package_name:[m
[31m-                package_name = package_name.partition(".")[0][m
[31m-[m
[31m-    def callback(ctx: Context, param: Parameter, value: bool) -> None:[m
[31m-        if not value or ctx.resilient_parsing:[m
[31m-            return[m
[31m-[m
[31m-        nonlocal prog_name[m
[31m-        nonlocal version[m
[31m-[m
[31m-        if prog_name is None:[m
[31m-            prog_name = ctx.find_root().info_name[m
[31m-[m
[31m-        if version is None and package_name is not None:[m
[31m-            import importlib.metadata[m
[31m-[m
[31m-            try:[m
[31m-                version = importlib.metadata.version(package_name)[m
[31m-            except importlib.metadata.PackageNotFoundError:[m
[31m-                raise RuntimeError([m
[31m-                    f"{package_name!r} is not installed. Try passing"[m
[31m-                    " 'package_name' instead."[m
[31m-                ) from None[m
[31m-[m
[31m-        if version is None:[m
[31m-            raise RuntimeError([m
[31m-                f"Could not determine the version for {package_name!r} automatically."[m
[31m-            )[m
[31m-[m
[31m-        echo([m
[31m-            message % {"prog": prog_name, "package": package_name, "version": version},[m
[31m-            color=ctx.color,[m
[31m-        )[m
[31m-        ctx.exit()[m
[31m-[m
[31m-    if not param_decls:[m
[31m-        param_decls = ("--version",)[m
[31m-[m
[31m-    kwargs.setdefault("is_flag", True)[m
[31m-    kwargs.setdefault("expose_value", False)[m
[31m-    kwargs.setdefault("is_eager", True)[m
[31m-    kwargs.setdefault("help", _("Show the version and exit."))[m
[31m-    kwargs["callback"] = callback[m
[31m-    return option(*param_decls, **kwargs)[m
[31m-[m
[31m-[m
[31m-def help_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:[m
[31m-    """Pre-configured ``--help`` option which immediately prints the help page[m
[31m-    and exits the program.[m
[31m-[m
[31m-    :param param_decls: One or more option names. Defaults to the single[m
[31m-        value ``"--help"``.[m
[31m-    :param kwargs: Extra arguments are passed to :func:`option`.[m
[31m-    """[m
[31m-[m
[31m-    def show_help(ctx: Context, param: Parameter, value: bool) -> None:[m
[31m-        """Callback that print the help page on ``<stdout>`` and exits."""[m
[31m-        if value and not ctx.resilient_parsing:[m
[31m-            echo(ctx.get_help(), color=ctx.color)[m
[31m-            ctx.exit()[m
[31m-[m
[31m-    if not param_decls:[m
[31m-        param_decls = ("--help",)[m
[31m-[m
[31m-    kwargs.setdefault("is_flag", True)[m
[31m-    kwargs.setdefault("expose_value", False)[m
[31m-    kwargs.setdefault("is_eager", True)[m
[31m-    kwargs.setdefault("help", _("Show this message and exit."))[m
[31m-    kwargs.setdefault("callback", show_help)[m
[31m-[m
[31m-    return option(*param_decls, **kwargs)[m
[1mdiff --git a/venv/Lib/site-packages/click/exceptions.py b/venv/Lib/site-packages/click/exceptions.py[m
[1mdeleted file mode 100644[m
[1mindex f141a83..0000000[m
[1m--- a/venv/Lib/site-packages/click/exceptions.py[m
[1m+++ /dev/null[m
[36m@@ -1,308 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as cabc[m
[31m-import typing as t[m
[31m-from gettext import gettext as _[m
[31m-from gettext import ngettext[m
[31m-[m
[31m-from ._compat import get_text_stderr[m
[31m-from .globals import resolve_color_default[m
[31m-from .utils import echo[m
[31m-from .utils import format_filename[m
[31m-[m
[31m-if t.TYPE_CHECKING:[m
[31m-    from .core import Command[m
[31m-    from .core import Context[m
[31m-    from .core import Parameter[m
[31m-[m
[31m-[m
[31m-def _join_param_hints(param_hint: cabc.Sequence[str] | str | None) -> str | None:[m
[31m-    if param_hint is not None and not isinstance(param_hint, str):[m
[31m-        return " / ".join(repr(x) for x in param_hint)[m
[31m-[m
[31m-    return param_hint[m
[31m-[m
[31m-[m
[31m-class ClickException(Exception):[m
[31m-    """An exception that Click can handle and show to the user."""[m
[31m-[m
[31m-    #: The exit code for this exception.[m
[31m-    exit_code = 1[m
[31m-[m
[31m-    def __init__(self, message: str) -> None:[m
[31m-        super().__init__(message)[m
[31m-        # The context will be removed by the time we print the message, so cache[m
[31m-        # the color settings here to be used later on (in `show`)[m
[31m-        self.show_color: bool | None = resolve_color_default()[m
[31m-        self.message = message[m
[31m-[m
[31m-    def format_message(self) -> str:[m
[31m-        return self.message[m
[31m-[m
[31m-    def __str__(self) -> str:[m
[31m-        return self.message[m
[31m-[m
[31m-    def show(self, file: t.IO[t.Any] | None = None) -> None:[m
[31m-        if file is None:[m
[31m-            file = get_text_stderr()[m
[31m-[m
[31m-        echo([m
[31m-            _("Error: {message}").format(message=self.format_message()),[m
[31m-            file=file,[m
[31m-            color=self.show_color,[m
[31m-        )[m
[31m-[m
[31m-[m
[31m-class UsageError(ClickException):[m
[31m-    """An internal exception that signals a usage error.  This typically[m
[31m-    aborts any further handling.[m
[31m-[m
[31m-    :param message: the error message to display.[m
[31m-    :param ctx: optionally the context that caused this error.  Click will[m
[31m-                fill in the context automatically in some situations.[m
[31m-    """[m
[31m-[m
[31m-    exit_code = 2[m
[31m-[m
[31m-    def __init__(self, message: str, ctx: Context | None = None) -> None:[m
[31m-        super().__init__(message)[m
[31m-        self.ctx = ctx[m
[31m-        self.cmd: Command | None = self.ctx.command if self.ctx else None[m
[31m-[m
[31m-    def show(self, file: t.IO[t.Any] | None = None) -> None:[m
[31m-        if file is None:[m
[31m-            file = get_text_stderr()[m
[31m-        color = None[m
[31m-        hint = ""[m
[31m-        if ([m
[31m-            self.ctx is not None[m
[31m-            and self.ctx.command.get_help_option(self.ctx) is not None[m
[31m-        ):[m
[31m-            hint = _("Try '{command} {option}' for help.").format([m
[31m-                command=self.ctx.command_path, option=self.ctx.help_option_names[0][m
[31m-            )[m
[31m-            hint = f"{hint}\n"[m
[31m-        if self.ctx is not None:[m
[31m-            color = self.ctx.color[m
[31m-            echo(f"{self.ctx.get_usage()}\n{hint}", file=file, color=color)[m
[31m-        echo([m
[31m-            _("Error: {message}").format(message=self.format_message()),[m
[31m-            file=file,[m
[31m-            color=color,[m
[31m-        )[m
[31m-[m
[31m-[m
[31m-class BadParameter(UsageError):[m
[31m-    """An exception that formats out a standardized error message for a[m
[31m-    bad parameter.  This is useful when thrown from a callback or type as[m
[31m-    Click will attach contextual information to it (for instance, which[m
[31m-    parameter it is).[m
[31m-[m
[31m-    .. versionadded:: 2.0[m
[31m-[m
[31m-    :param param: the parameter object that caused this error.  This can[m
[31m-                  be left out, and Click will attach this info itself[m
[31m-                  if possible.[m
[31m-    :param param_hint: a string that shows up as parameter name.  This[m
[31m-                       can be used as alternative to `param` in cases[m
[31m-                       where custom validation should happen.  If it is[m
[31m-                       a string it's used as such, if it's a list then[m
[31m-                       each item is quoted and separated.[m
[31m-    """[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        message: str,[m
[31m-        ctx: Context | None = None,[m
[31m-        param: Parameter | None = None,[m
[31m-        param_hint: str | None = None,[m
[31m-    ) -> None:[m
[31m-        super().__init__(message, ctx)[m
[31m-        self.param = param[m
[31m-        self.param_hint = param_hint[m
[31m-[m
[31m-    def format_message(self) -> str:[m
[31m-        if self.param_hint is not None:[m
[31m-            param_hint = self.param_hint[m
[31m-        elif self.param is not None:[m
[31m-            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore[m
[31m-        else:[m
[31m-            return _("Invalid value: {message}").format(message=self.message)[m
[31m-[m
[31m-        return _("Invalid value for {param_hint}: {message}").format([m
[31m-            param_hint=_join_param_hints(param_hint), message=self.message[m
[31m-        )[m
[31m-[m
[31m-[m
[31m-class MissingParameter(BadParameter):[m
[31m-    """Raised if click required an option or argument but it was not[m
[31m-    provided when invoking the script.[m
[31m-[m
[31m-    .. versionadded:: 4.0[m
[31m-[m
[31m-    :param param_type: a string that indicates the type of the parameter.[m
[31m-                       The default is to inherit the parameter type from[m
[31m-                       the given `param`.  Valid values are ``'parameter'``,[m
[31m-                       ``'option'`` or ``'argument'``.[m
[31m-    """[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        message: str | None = None,[m
[31m-        ctx: Context | None = None,[m
[31m-        param: Parameter | None = None,[m
[31m-        param_hint: str | None = None,[m
[31m-        param_type: str | None = None,[m
[31m-    ) -> None:[m
[31m-        super().__init__(message or "", ctx, param, param_hint)[m
[31m-        self.param_type = param_type[m
[31m-[m
[31m-    def format_message(self) -> str:[m
[31m-        if self.param_hint is not None:[m
[31m-            param_hint: str | None = self.param_hint[m
[31m-        elif self.param is not None:[m
[31m-            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore[m
[31m-        else:[m
[31m-            param_hint = None[m
[31m-[m
[31m-        param_hint = _join_param_hints(param_hint)[m
[31m-        param_hint = f" {param_hint}" if param_hint else ""[m
[31m-[m
[31m-        param_type = self.param_type[m
[31m-        if param_type is None and self.param is not None:[m
[31m-            param_type = self.param.param_type_name[m
[31m-[m
[31m-        msg = self.message[m
[31m-        if self.param is not None:[m
[31m-            msg_extra = self.param.type.get_missing_message([m
[31m-                param=self.param, ctx=self.ctx[m
[31m-            )[m
[31m-            if msg_extra:[m
[31m-                if msg:[m
[31m-                    msg += f". {msg_extra}"[m
[31m-                else:[m
[31m-                    msg = msg_extra[m
[31m-[m
[31m-        msg = f" {msg}" if msg else ""[m
[31m-[m
[31m-        # Translate param_type for known types.[m
[31m-        if param_type == "argument":[m
[31m-            missing = _("Missing argument")[m
[31m-        elif param_type == "option":[m
[31m-            missing = _("Missing option")[m
[31m-        elif param_type == "parameter":[m
[31m-            missing = _("Missing parameter")[m
[31m-        else:[m
[31m-            missing = _("Missing {param_type}").format(param_type=param_type)[m
[31m-[m
[31m-        return f"{missing}{param_hint}.{msg}"[m
[31m-[m
[31m-    def __str__(self) -> str:[m
[31m-        if not self.message:[m
[31m-            param_name = self.param.name if self.param else None[m
[31m-            return _("Missing parameter: {param_name}").format(param_name=param_name)[m
[31m-        else:[m
[31m-            return self.message[m
[31m-[m
[31m-[m
[31m-class NoSuchOption(UsageError):[m
[31m-    """Raised if click attempted to handle an option that does not[m
[31m-    exist.[m
[31m-[m
[31m-    .. versionadded:: 4.0[m
[31m-    """[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        option_name: str,[m
[31m-        message: str | None = None,[m
[31m-        possibilities: cabc.Sequence[str] | None = None,[m
[31m-        ctx: Context | None = None,[m
[31m-    ) -> None:[m
[31m-        if message is None:[m
[31m-            message = _("No such option: {name}").format(name=option_name)[m
[31m-[m
[31m-        super().__init__(message, ctx)[m
[31m-        self.option_name = option_name[m
[31m-        self.possibilities = possibilities[m
[31m-[m
[31m-    def format_message(self) -> str:[m
[31m-        if not self.possibilities:[m
[31m-            return self.message[m
[31m-[m
[31m-        possibility_str = ", ".join(sorted(self.possibilities))[m
[31m-        suggest = ngettext([m
[31m-            "Did you mean {possibility}?",[m
[31m-            "(Possible options: {possibilities})",[m
[31m-            len(self.possibilities),[m
[31m-        ).format(possibility=possibility_str, possibilities=possibility_str)[m
[31m-        return f"{self.message} {suggest}"[m
[31m-[m
[31m-[m
[31m-class BadOptionUsage(UsageError):[m
[31m-    """Raised if an option is generally supplied but the use of the option[m
[31m-    was incorrect.  This is for instance raised if the number of arguments[m
[31m-    for an option is not correct.[m
[31m-[m
[31m-    .. versionadded:: 4.0[m
[31m-[m
[31m-    :param option_name: the name of the option being used incorrectly.[m
[31m-    """[m
[31m-[m
[31m-    def __init__([m
[31m-        self, option_name: str, message: str, ctx: Context | None = None[m
[31m-    ) -> None:[m
[31m-        super().__init__(message, ctx)[m
[31m-        self.option_name = option_name[m
[31m-[m
[31m-[m
[31m-class BadArgumentUsage(UsageError):[m
[31m-    """Raised if an argument is generally supplied but the use of the argument[m
[31m-    was incorrect.  This is for instance raised if the number of values[m
[31m-    for an argument is not correct.[m
[31m-[m
[31m-    .. versionadded:: 6.0[m
[31m-    """[m
[31m-[m
[31m-[m
[31m-class NoArgsIsHelpError(UsageError):[m
[31m-    def __init__(self, ctx: Context) -> None:[m
[31m-        self.ctx: Context[m
[31m-        super().__init__(ctx.get_help(), ctx=ctx)[m
[31m-[m
[31m-    def show(self, file: t.IO[t.Any] | None = None) -> None:[m
[31m-        echo(self.format_message(), file=file, err=True, color=self.ctx.color)[m
[31m-[m
[31m-[m
[31m-class FileError(ClickException):[m
[31m-    """Raised if a file cannot be opened."""[m
[31m-[m
[31m-    def __init__(self, filename: str, hint: str | None = None) -> None:[m
[31m-        if hint is None:[m
[31m-            hint = _("unknown error")[m
[31m-[m
[31m-        super().__init__(hint)[m
[31m-        self.ui_filename: str = format_filename(filename)[m
[31m-        self.filename = filename[m
[31m-[m
[31m-    def format_message(self) -> str:[m
[31m-        return _("Could not open file {filename!r}: {message}").format([m
[31m-            filename=self.ui_filename, message=self.message[m
[31m-        )[m
[31m-[m
[31m-[m
[31m-class Abort(RuntimeError):[m
[31m-    """An internal signalling exception that signals Click to abort."""[m
[31m-[m
[31m-[m
[31m-class Exit(RuntimeError):[m
[31m-    """An exception that indicates that the application should exit with some[m
[31m-    status code.[m
[31m-[m
[31m-    :param code: the status code to exit with.[m
[31m-    """[m
[31m-[m
[31m-    __slots__ = ("exit_code",)[m
[31m-[m
[31m-    def __init__(self, code: int = 0) -> None:[m
[31m-        self.exit_code: int = code[m
[1mdiff --git a/venv/Lib/site-packages/click/formatting.py b/venv/Lib/site-packages/click/formatting.py[m
[1mdeleted file mode 100644[m
[1mindex 9891f88..0000000[m
[1m--- a/venv/Lib/site-packages/click/formatting.py[m
[1m+++ /dev/null[m
[36m@@ -1,301 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as cabc[m
[31m-from contextlib import contextmanager[m
[31m-from gettext import gettext as _[m
[31m-[m
[31m-from ._compat import term_len[m
[31m-from .parser import _split_opt[m
[31m-[m
[31m-# Can force a width.  This is used by the test system[m
[31m-FORCED_WIDTH: int | None = None[m
[31m-[m
[31m-[m
[31m-def measure_table(rows: cabc.Iterable[tuple[str, str]]) -> tuple[int, ...]:[m
[31m-    widths: dict[int, int] = {}[m
[31m-[m
[31m-    for row in rows:[m
[31m-        for idx, col in enumerate(row):[m
[31m-            widths[idx] = max(widths.get(idx, 0), term_len(col))[m
[31m-[m
[31m-    return tuple(y for x, y in sorted(widths.items()))[m
[31m-[m
[31m-[m
[31m-def iter_rows([m
[31m-    rows: cabc.Iterable[tuple[str, str]], col_count: int[m
[31m-) -> cabc.Iterator[tuple[str, ...]]:[m
[31m-    for row in rows:[m
[31m-        yield row + ("",) * (col_count - len(row))[m
[31m-[m
[31m-[m
[31m-def wrap_text([m
[31m-    text: str,[m
[31m-    width: int = 78,[m
[31m-    initial_indent: str = "",[m
[31m-    subsequent_indent: str = "",[m
[31m-    preserve_paragraphs: bool = False,[m
[31m-) -> str:[m
[31m-    """A helper function that intelligently wraps text.  By default, it[m
[31m-    assumes that it operates on a single paragraph of text but if the[m
[31m-    `preserve_paragraphs` parameter is provided it will intelligently[m
[31m-    handle paragraphs (defined by two empty lines).[m
[31m-[m
[31m-    If paragraphs are handled, a paragraph can be prefixed with an empty[m
[31m-    line containing the ``\\b`` character (``\\x08``) to indicate that[m
[31m-    no rewrapping should happen in that block.[m
[31m-[m
[31m-    :param text: the text that should be rewrapped.[m
[31m-    :param width: the maximum width for the text.[m
[31m-    :param initial_indent: the initial indent that should be placed on the[m
[31m-                           first line as a string.[m
[31m-    :param subsequent_indent: the indent string that should be placed on[m
[31m-                              each consecutive line.[m
[31m-    :param preserve_paragraphs: if this flag is set then the wrapping will[m
[31m-                                intelligently handle paragraphs.[m
[31m-    """[m
[31m-    from ._textwrap import TextWrapper[m
[31m-[m
[31m-    text = text.expandtabs()[m
[31m-    wrapper = TextWrapper([m
[31m-        width,[m
[31m-        initial_indent=initial_indent,[m
[31m-        subsequent_indent=subsequent_indent,[m
[31m-        replace_whitespace=False,[m
[31m-    )[m
[31m-    if not preserve_paragraphs:[m
[31m-        return wrapper.fill(text)[m
[31m-[m
[31m-    p: list[tuple[int, bool, str]] = [][m
[31m-    buf: list[str] = [][m
[31m-    indent = None[m
[31m-[m
[31m-    def _flush_par() -> None:[m
[31m-        if not buf:[m
[31m-            return[m
[31m-        if buf[0].strip() == "\b":[m
[31m-            p.append((indent or 0, True, "\n".join(buf[1:])))[m
[31m-        else:[m
[31m-            p.append((indent or 0, False, " ".join(buf)))[m
[31m-        del buf[:][m
[31m-[m
[31m-    for line in text.splitlines():[m
[31m-        if not line:[m
[31m-            _flush_par()[m
[31m-            indent = None[m
[31m-        else:[m
[31m-            if indent is None:[m
[31m-                orig_len = term_len(line)[m
[31m-                line = line.lstrip()[m
[31m-                indent = orig_len - term_len(line)[m
[31m-            buf.append(line)[m
[31m-    _flush_par()[m
[31m-[m
[31m-    rv = [][m
[31m-    for indent, raw, text in p:[m
[31m-        with wrapper.extra_indent(" " * indent):[m
[31m-            if raw:[m
[31m-                rv.append(wrapper.indent_only(text))[m
[31m-            else:[m
[31m-                rv.append(wrapper.fill(text))[m
[31m-[m
[31m-    return "\n\n".join(rv)[m
[31m-[m
[31m-[m
[31m-class HelpFormatter:[m
[31m-    """This class helps with formatting text-based help pages.  It's[m
[31m-    usually just needed for very special internal cases, but it's also[m
[31m-    exposed so that developers can write their own fancy outputs.[m
[31m-[m
[31m-    At present, it always writes into memory.[m
[31m-[m
[31m-    :param indent_increment: the additional increment for each level.[m
[31m-    :param width: the width for the text.  This defaults to the terminal[m
[31m-                  width clamped to a maximum of 78.[m
[31m-    """[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        indent_increment: int = 2,[m
[31m-        width: int | None = None,[m
[31m-        max_width: int | None = None,[m
[31m-    ) -> None:[m
[31m-        import shutil[m
[31m-[m
[31m-        self.indent_increment = indent_increment[m
[31m-        if max_width is None:[m
[31m-            max_width = 80[m
[31m-        if width is None:[m
[31m-            width = FORCED_WIDTH[m
[31m-            if width is None:[m
[31m-                width = max(min(shutil.get_terminal_size().columns, max_width) - 2, 50)[m
[31m-        self.width = width[m
[31m-        self.current_indent: int = 0[m
[31m-        self.buffer: list[str] = [][m
[31m-[m
[31m-    def write(self, string: str) -> None:[m
[31m-        """Writes a unicode string into the internal buffer."""[m
[31m-        self.buffer.append(string)[m
[31m-[m
[31m-    def indent(self) -> None:[m
[31m-        """Increases the indentation."""[m
[31m-        self.current_indent += self.indent_increment[m
[31m-[m
[31m-    def dedent(self) -> None:[m
[31m-        """Decreases the indentation."""[m
[31m-        self.current_indent -= self.indent_increment[m
[31m-[m
[31m-    def write_usage(self, prog: str, args: str = "", prefix: str | None = None) -> None:[m
[31m-        """Writes a usage line into the buffer.[m
[31m-[m
[31m-        :param prog: the program name.[m
[31m-        :param args: whitespace separated list of arguments.[m
[31m-        :param prefix: The prefix for the first line. Defaults to[m
[31m-            ``"Usage: "``.[m
[31m-        """[m
[31m-        if prefix is None:[m
[31m-            prefix = f"{_('Usage:')} "[m
[31m-[m
[31m-        usage_prefix = f"{prefix:>{self.current_indent}}{prog} "[m
[31m-        text_width = self.width - self.current_indent[m
[31m-[m
[31m-        if text_width >= (term_len(usage_prefix) + 20):[m
[31m-            # The arguments will fit to the right of the prefix.[m
[31m-            indent = " " * term_len(usage_prefix)[m
[31m-            self.write([m
[31m-                wrap_text([m
[31m-                    args,[m
[31m-                    text_width,[m
[31m-                    initial_indent=usage_prefix,[m
[31m-                    subsequent_indent=indent,[m
[31m-                )[m
[31m-            )[m
[31m-        else:[m
[31m-            # The prefix is too long, put the arguments on the next line.[m
[31m-            self.write(usage_prefix)[m
[31m-            self.write("\n")[m
[31m-            indent = " " * (max(self.current_indent, term_len(prefix)) + 4)[m
[31m-            self.write([m
[31m-                wrap_text([m
[31m-                    args, text_width, initial_indent=indent, subsequent_indent=indent[m
[31m-                )[m
[31m-            )[m
[31m-[m
[31m-        self.write("\n")[m
[31m-[m
[31m-    def write_heading(self, heading: str) -> None:[m
[31m-        """Writes a heading into the buffer."""[m
[31m-        self.write(f"{'':>{self.current_indent}}{heading}:\n")[m
[31m-[m
[31m-    def write_paragraph(self) -> None:[m
[31m-        """Writes a paragraph into the buffer."""[m
[31m-        if self.buffer:[m
[31m-            self.write("\n")[m
[31m-[m
[31m-    def write_text(self, text: str) -> None:[m
[31m-        """Writes re-indented text into the buffer.  This rewraps and[m
[31m-        preserves paragraphs.[m
[31m-        """[m
[31m-        indent = " " * self.current_indent[m
[31m-        self.write([m
[31m-            wrap_text([m
[31m-                text,[m
[31m-                self.width,[m
[31m-                initial_indent=indent,[m
[31m-                subsequent_indent=indent,[m
[31m-                preserve_paragraphs=True,[m
[31m-            )[m
[31m-        )[m
[31m-        self.write("\n")[m
[31m-[m
[31m-    def write_dl([m
[31m-        self,[m
[31m-        rows: cabc.Sequence[tuple[str, str]],[m
[31m-        col_max: int = 30,[m
[31m-        col_spacing: int = 2,[m
[31m-    ) -> None:[m
[31m-        """Writes a definition list into the buffer.  This is how options[m
[31m-        and commands are usually formatted.[m
[31m-[m
[31m-        :param rows: a list of two item tuples for the terms and values.[m
[31m-        :param col_max: the maximum width of the first column.[m
[31m-        :param col_spacing: the number of spaces between the first and[m
[31m-                            second column.[m
[31m-        """[m
[31m-        rows = list(rows)[m
[31m-        widths = measure_table(rows)[m
[31m-        if len(widths) != 2:[m
[31m-            raise TypeError("Expected two columns for definition list")[m
[31m-[m
[31m-        first_col = min(widths[0], col_max) + col_spacing[m
[31m-[m
[31m-        for first, second in iter_rows(rows, len(widths)):[m
[31m-            self.write(f"{'':>{self.current_indent}}{first}")[m
[31m-            if not second:[m
[31m-                self.write("\n")[m
[31m-                continue[m
[31m-            if term_len(first) <= first_col - col_spacing:[m
[31m-                self.write(" " * (first_col - term_len(first)))[m
[31m-            else:[m
[31m-                self.write("\n")[m
[31m-                self.write(" " * (first_col + self.current_indent))[m
[31m-[m
[31m-            text_width = max(self.width - first_col - 2, 10)[m
[31m-            wrapped_text = wrap_text(second, text_width, preserve_paragraphs=True)[m
[31m-            lines = wrapped_text.splitlines()[m
[31m-[m
[31m-            if lines:[m
[31m-                self.write(f"{lines[0]}\n")[m
[31m-[m
[31m-                for line in lines[1:]:[m
[31m-                    self.write(f"{'':>{first_col + self.current_indent}}{line}\n")[m
[31m-            else:[m
[31m-                self.write("\n")[m
[31m-[m
[31m-    @contextmanager[m
[31m-    def section(self, name: str) -> cabc.Iterator[None]:[m
[31m-        """Helpful context manager that writes a paragraph, a heading,[m
[31m-        and the indents.[m
[31m-[m
[31m-        :param name: the section name that is written as heading.[m
[31m-        """[m
[31m-        self.write_paragraph()[m
[31m-        self.write_heading(name)[m
[31m-        self.indent()[m
[31m-        try:[m
[31m-            yield[m
[31m-        finally:[m
[31m-            self.dedent()[m
[31m-[m
[31m-    @contextmanager[m
[31m-    def indentation(self) -> cabc.Iterator[None]:[m
[31m-        """A context manager that increases the indentation."""[m
[31m-        self.indent()[m
[31m-        try:[m
[31m-            yield[m
[31m-        finally:[m
[31m-            self.dedent()[m
[31m-[m
[31m-    def getvalue(self) -> str:[m
[31m-        """Returns the buffer contents."""[m
[31m-        return "".join(self.buffer)[m
[31m-[m
[31m-[m
[31m-def join_options(options: cabc.Sequence[str]) -> tuple[str, bool]:[m
[31m-    """Given a list of option strings this joins them in the most appropriate[m
[31m-    way and returns them in the form ``(formatted_string,[m
[31m-    any_prefix_is_slash)`` where the second item in the tuple is a flag that[m
[31m-    indicates if any of the option prefixes was a slash.[m
[31m-    """[m
[31m-    rv = [][m
[31m-    any_prefix_is_slash = False[m
[31m-[m
[31m-    for opt in options:[m
[31m-        prefix = _split_opt(opt)[0][m
[31m-[m
[31m-        if prefix == "/":[m
[31m-            any_prefix_is_slash = True[m
[31m-[m
[31m-        rv.append((len(prefix), opt))[m
[31m-[m
[31m-    rv.sort(key=lambda x: x[0])[m
[31m-    return ", ".join(x[1] for x in rv), any_prefix_is_slash[m
[1mdiff --git a/venv/Lib/site-packages/click/globals.py b/venv/Lib/site-packages/click/globals.py[m
[1mdeleted file mode 100644[m
[1mindex a2f9172..0000000[m
[1m--- a/venv/Lib/site-packages/click/globals.py[m
[1m+++ /dev/null[m
[36m@@ -1,67 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import typing as t[m
[31m-from threading import local[m
[31m-[m
[31m-if t.TYPE_CHECKING:[m
[31m-    from .core import Context[m
[31m-[m
[31m-_local = local()[m
[31m-[m
[31m-[m
[31m-@t.overload[m
[31m-def get_current_context(silent: t.Literal[False] = False) -> Context: ...[m
[31m-[m
[31m-[m
[31m-@t.overload[m
[31m-def get_current_context(silent: bool = ...) -> Context | None: ...[m
[31m-[m
[31m-[m
[31m-def get_current_context(silent: bool = False) -> Context | None:[m
[31m-    """Returns the current click context.  This can be used as a way to[m
[31m-    access the current context object from anywhere.  This is a more implicit[m
[31m-    alternative to the :func:`pass_context` decorator.  This function is[m
[31m-    primarily useful for helpers such as :func:`echo` which might be[m
[31m-    interested in changing its behavior based on the current context.[m
[31m-[m
[31m-    To push the current context, :meth:`Context.scope` can be used.[m
[31m-[m
[31m-    .. versionadded:: 5.0[m
[31m-[m
[31m-    :param silent: if set to `True` the return value is `None` if no context[m
[31m-                   is available.  The default behavior is to raise a[m
[31m-                   :exc:`RuntimeError`.[m
[31m-    """[m
[31m-    try:[m
[31m-        return t.cast("Context", _local.stack[-1])[m
[31m-    except (AttributeError, IndexError) as e:[m
[31m-        if not silent:[m
[31m-            raise RuntimeError("There is no active click context.") from e[m
[31m-[m
[31m-    return None[m
[31m-[m
[31m-[m
[31m-def push_context(ctx: Context) -> None:[m
[31m-    """Pushes a new context to the current stack."""[m
[31m-    _local.__dict__.setdefault("stack", []).append(ctx)[m
[31m-[m
[31m-[m
[31m-def pop_context() -> None:[m
[31m-    """Removes the top level from the stack."""[m
[31m-    _local.stack.pop()[m
[31m-[m
[31m-[m
[31m-def resolve_color_default(color: bool | None = None) -> bool | None:[m
[31m-    """Internal helper to get the default value of the color flag.  If a[m
[31m-    value is passed it's returned unchanged, otherwise it's looked up from[m
[31m-    the current context.[m
[31m-    """[m
[31m-    if color is not None:[m
[31m-        return color[m
[31m-[m
[31m-    ctx = get_current_context(silent=True)[m
[31m-[m
[31m-    if ctx is not None:[m
[31m-        return ctx.color[m
[31m-[m
[31m-    return None[m
[1mdiff --git a/venv/Lib/site-packages/click/parser.py b/venv/Lib/site-packages/click/parser.py[m
[1mdeleted file mode 100644[m
[1mindex a8b7d26..0000000[m
[1m--- a/venv/Lib/site-packages/click/parser.py[m
[1m+++ /dev/null[m
[36m@@ -1,532 +0,0 @@[m
[31m-"""[m
[31m-This module started out as largely a copy paste from the stdlib's[m
[31m-optparse module with the features removed that we do not need from[m
[31m-optparse because we implement them in Click on a higher level (for[m
[31m-instance type handling, help formatting and a lot more).[m
[31m-[m
[31m-The plan is to remove more and more from here over time.[m
[31m-[m
[31m-The reason this is a different module and not optparse from the stdlib[m
[31m-is that there are differences in 2.x and 3.x about the error messages[m
[31m-generated and optparse in the stdlib uses gettext for no good reason[m
[31m-and might cause us issues.[m
[31m-[m
[31m-Click uses parts of optparse written by Gregory P. Ward and maintained[m
[31m-by the Python Software Foundation. This is limited to code in parser.py.[m
[31m-[m
[31m-Copyright 2001-2006 Gregory P. Ward. All rights reserved.[m
[31m-Copyright 2002-2006 Python Software Foundation. All rights reserved.[m
[31m-"""[m
[31m-[m
[31m-# This code uses parts of optparse written by Gregory P. Ward and[m
[31m-# maintained by the Python Software Foundation.[m
[31m-# Copyright 2001-2006 Gregory P. Ward[m
[31m-# Copyright 2002-2006 Python Software Foundation[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as cabc[m
[31m-import typing as t[m
[31m-from collections import deque[m
[31m-from gettext import gettext as _[m
[31m-from gettext import ngettext[m
[31m-[m
[31m-from .exceptions import BadArgumentUsage[m
[31m-from .exceptions import BadOptionUsage[m
[31m-from .exceptions import NoSuchOption[m
[31m-from .exceptions import UsageError[m
[31m-[m
[31m-if t.TYPE_CHECKING:[m
[31m-    from .core import Argument as CoreArgument[m
[31m-    from .core import Context[m
[31m-    from .core import Option as CoreOption[m
[31m-    from .core import Parameter as CoreParameter[m
[31m-[m
[31m-V = t.TypeVar("V")[m
[31m-[m
[31m-# Sentinel value that indicates an option was passed as a flag without a[m
[31m-# value but is not a flag option. Option.consume_value uses this to[m
[31m-# prompt or use the flag_value.[m
[31m-_flag_needs_value = object()[m
[31m-[m
[31m-[m
[31m-def _unpack_args([m
[31m-    args: cabc.Sequence[str], nargs_spec: cabc.Sequence[int][m
[31m-) -> tuple[cabc.Sequence[str | cabc.Sequence[str | None] | None], list[str]]:[m
[31m-    """Given an iterable of arguments and an iterable of nargs specifications,[m
[31m-    it returns a tuple with all the unpacked arguments at the first index[m
[31m-    and all remaining arguments as the second.[m
[31m-[m
[31m-    The nargs specification is the number of arguments that should be consumed[m
[31m-    or `-1` to indicate that this position should eat up all the remainders.[m
[31m-[m
[31m-    Missing items are filled with `None`.[m
[31m-    """[m
[31m-    args = deque(args)[m
[31m-    nargs_spec = deque(nargs_spec)[m
[31m-    rv: list[str | tuple[str | None, ...] | None] = [][m
[31m-    spos: int | None = None[m
[31m-[m
[31m-    def _fetch(c: deque[V]) -> V | None:[m
[31m-        try:[m
[31m-            if spos is None:[m
[31m-                return c.popleft()[m
[31m-            else:[m
[31m-                return c.pop()[m
[31m-        except IndexError:[m
[31m-            return None[m
[31m-[m
[31m-    while nargs_spec:[m
[31m-        nargs = _fetch(nargs_spec)[m
[31m-[m
[31m-        if nargs is None:[m
[31m-            continue[m
[31m-[m
[31m-        if nargs == 1:[m
[31m-            rv.append(_fetch(args))[m
[31m-        elif nargs > 1:[m
[31m-            x = [_fetch(args) for _ in range(nargs)][m
[31m-[m
[31m-            # If we're reversed, we're pulling in the arguments in reverse,[m
[31m-            # so we need to turn them around.[m
[31m-            if spos is not None:[m
[31m-                x.reverse()[m
[31m-[m
[31m-            rv.append(tuple(x))[m
[31m-        elif nargs < 0:[m
[31m-            if spos is not None:[m
[31m-                raise TypeError("Cannot have two nargs < 0")[m
[31m-[m
[31m-            spos = len(rv)[m
[31m-            rv.append(None)[m
[31m-[m
[31m-    # spos is the position of the wildcard (star).  If it's not `None`,[m
[31m-    # we fill it with the remainder.[m
[31m-    if spos is not None:[m
[31m-        rv[spos] = tuple(args)[m
[31m-        args = [][m
[31m-        rv[spos + 1 :] = reversed(rv[spos + 1 :])[m
[31m-[m
[31m-    return tuple(rv), list(args)[m
[31m-[m
[31m-[m
[31m-def _split_opt(opt: str) -> tuple[str, str]:[m
[31m-    first = opt[:1][m
[31m-    if first.isalnum():[m
[31m-        return "", opt[m
[31m-    if opt[1:2] == first:[m
[31m-        return opt[:2], opt[2:][m
[31m-    return first, opt[1:][m
[31m-[m
[31m-[m
[31m-def _normalize_opt(opt: str, ctx: Context | None) -> str:[m
[31m-    if ctx is None or ctx.token_normalize_func is None:[m
[31m-        return opt[m
[31m-    prefix, opt = _split_opt(opt)[m
[31m-    return f"{prefix}{ctx.token_normalize_func(opt)}"[m
[31m-[m
[31m-[m
[31m-class _Option:[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        obj: CoreOption,[m
[31m-        opts: cabc.Sequence[str],[m
[31m-        dest: str | None,[m
[31m-        action: str | None = None,[m
[31m-        nargs: int = 1,[m
[31m-        const: t.Any | None = None,[m
[31m-    ):[m
[31m-        self._short_opts = [][m
[31m-        self._long_opts = [][m
[31m-        self.prefixes: set[str] = set()[m
[31m-[m
[31m-        for opt in opts:[m
[31m-            prefix, value = _split_opt(opt)[m
[31m-            if not prefix:[m
[31m-                raise ValueError(f"Invalid start character for option ({opt})")[m
[31m-            self.prefixes.add(prefix[0])[m
[31m-            if len(prefix) == 1 and len(value) == 1:[m
[31m-                self._short_opts.append(opt)[m
[31m-            else:[m
[31m-                self._long_opts.append(opt)[m
[31m-                self.prefixes.add(prefix)[m
[31m-[m
[31m-        if action is None:[m
[31m-            action = "store"[m
[31m-[m
[31m-        self.dest = dest[m
[31m-        self.action = action[m
[31m-        self.nargs = nargs[m
[31m-        self.const = const[m
[31m-        self.obj = obj[m
[31m-[m
[31m-    @property[m
[31m-    def takes_value(self) -> bool:[m
[31m-        return self.action in ("store", "append")[m
[31m-[m
[31m-    def process(self, value: t.Any, state: _ParsingState) -> None:[m
[31m-        if self.action == "store":[m
[31m-            state.opts[self.dest] = value  # type: ignore[m
[31m-        elif self.action == "store_const":[m
[31m-            state.opts[self.dest] = self.const  # type: ignore[m
[31m-        elif self.action == "append":[m
[31m-            state.opts.setdefault(self.dest, []).append(value)  # type: ignore[m
[31m-        elif self.action == "append_const":[m
[31m-            state.opts.setdefault(self.dest, []).append(self.const)  # type: ignore[m
[31m-        elif self.action == "count":[m
[31m-            state.opts[self.dest] = state.opts.get(self.dest, 0) + 1  # type: ignore[m
[31m-        else:[m
[31m-            raise ValueError(f"unknown action '{self.action}'")[m
[31m-        state.order.append(self.obj)[m
[31m-[m
[31m-[m
[31m-class _Argument:[m
[31m-    def __init__(self, obj: CoreArgument, dest: str | None, nargs: int = 1):[m
[31m-        self.dest = dest[m
[31m-        self.nargs = nargs[m
[31m-        self.obj = obj[m
[31m-[m
[31m-    def process([m
[31m-        self,[m
[31m-        value: str | cabc.Sequence[str | None] | None,[m
[31m-        state: _ParsingState,[m
[31m-    ) -> None:[m
[31m-        if self.nargs > 1:[m
[31m-            assert value is not None[m
[31m-            holes = sum(1 for x in value if x is None)[m
[31m-            if holes == len(value):[m
[31m-                value = None[m
[31m-            elif holes != 0:[m
[31m-                raise BadArgumentUsage([m
[31m-                    _("Argument {name!r} takes {nargs} values.").format([m
[31m-                        name=self.dest, nargs=self.nargs[m
[31m-                    )[m
[31m-                )[m
[31m-[m
[31m-        if self.nargs == -1 and self.obj.envvar is not None and value == ():[m
[31m-            # Replace empty tuple with None so that a value from the[m
[31m-            # environment may be tried.[m
[31m-            value = None[m
[31m-[m
[31m-        state.opts[self.dest] = value  # type: ignore[m
[31m-        state.order.append(self.obj)[m
[31m-[m
[31m-[m
[31m-class _ParsingState:[m
[31m-    def __init__(self, rargs: list[str]) -> None:[m
[31m-        self.opts: dict[str, t.Any] = {}[m
[31m-        self.largs: list[str] = [][m
[31m-        self.rargs = rargs[m
[31m-        self.order: list[CoreParameter] = [][m
[31m-[m
[31m-[m
[31m-class _OptionParser:[m
[31m-    """The option parser is an internal class that is ultimately used to[m
[31m-    parse options and arguments.  It's modelled after optparse and brings[m
[31m-    a similar but vastly simplified API.  It should generally not be used[m
[31m-    directly as the high level Click classes wrap it for you.[m
[31m-[m
[31m-    It's not nearly as extensible as optparse or argparse as it does not[m
[31m-    implement features that are implemented on a higher level (such as[m
[31m-    types or defaults).[m
[31m-[m
[31m-    :param ctx: optionally the :class:`~click.Context` where this parser[m
[31m-                should go with.[m
[31m-[m
[31m-    .. deprecated:: 8.2[m
[31m-        Will be removed in Click 9.0.[m
[31m-    """[m
[31m-[m
[31m-    def __init__(self, ctx: Context | None = None) -> None:[m
[31m-        #: The :class:`~click.Context` for this parser.  This might be[m
[31m-        #: `None` for some advanced use cases.[m
[31m-        self.ctx = ctx[m
[31m-        #: This controls how the parser deals with interspersed arguments.[m
[31m-        #: If this is set to `False`, the parser will stop on the first[m
[31m-        #: non-option.  Click uses this to implement nested subcommands[m
[31m-        #: safely.[m
[31m-        self.allow_interspersed_args: bool = True[m
[31m-        #: This tells the parser how to deal with unknown options.  By[m
[31m-        #: default it will error out (which is sensible), but there is a[m
[31m-        #: second mode where it will ignore it and continue processing[m
[31m-        #: after shifting all the unknown options into the resulting args.[m
[31m-        self.ignore_unknown_options: bool = False[m
[31m-[m
[31m-        if ctx is not None:[m
[31m-            self.allow_interspersed_args = ctx.allow_interspersed_args[m
[31m-            self.ignore_unknown_options = ctx.ignore_unknown_options[m
[31m-[m
[31m-        self._short_opt: dict[str, _Option] = {}[m
[31m-        self._long_opt: dict[str, _Option] = {}[m
[31m-        self._opt_prefixes = {"-", "--"}[m
[31m-        self._args: list[_Argument] = [][m
[31m-[m
[31m-    def add_option([m
[31m-        self,[m
[31m-        obj: CoreOption,[m
[31m-        opts: cabc.Sequence[str],[m
[31m-        dest: str | None,[m
[31m-        action: str | None = None,[m
[31m-        nargs: int = 1,[m
[31m-        const: t.Any | None = None,[m
[31m-    ) -> None:[m
[31m-        """Adds a new option named `dest` to the parser.  The destination[m
[31m-        is not inferred (unlike with optparse) and needs to be explicitly[m
[31m-        provided.  Action can be any of ``store``, ``store_const``,[m
[31m-        ``append``, ``append_const`` or ``count``.[m
[31m-[m
[31m-        The `obj` can be used to identify the option in the order list[m
[31m-        that is returned from the parser.[m
[31m-        """[m
[31m-        opts = [_normalize_opt(opt, self.ctx) for opt in opts][m
[31m-        option = _Option(obj, opts, dest, action=action, nargs=nargs, const=const)[m
[31m-        self._opt_prefixes.update(option.prefixes)[m
[31m-        for opt in option._short_opts:[m
[31m-            self._short_opt[opt] = option[m
[31m-        for opt in option._long_opts:[m
[31m-            self._long_opt[opt] = option[m
[31m-[m
[31m-    def add_argument(self, obj: CoreArgument, dest: str | None, nargs: int = 1) -> None:[m
[31m-        """Adds a positional argument named `dest` to the parser.[m
[31m-[m
[31m-        The `obj` can be used to identify the option in the order list[m
[31m-        that is returned from the parser.[m
[31m-        """[m
[31m-        self._args.append(_Argument(obj, dest=dest, nargs=nargs))[m
[31m-[m
[31m-    def parse_args([m
[31m-        self, args: list[str][m
[31m-    ) -> tuple[dict[str, t.Any], list[str], list[CoreParameter]]:[m
[31m-        """Parses positional arguments and returns ``(values, args, order)``[m
[31m-        for the parsed options and arguments as well as the leftover[m
[31m-        arguments if there are any.  The order is a list of objects as they[m
[31m-        appear on the command line.  If arguments appear multiple times they[m
[31m-        will be memorized multiple times as well.[m
[31m-        """[m
[31m-        state = _ParsingState(args)[m
[31m-        try:[m
[31m-            self._process_args_for_options(state)[m
[31m-            self._process_args_for_args(state)[m
[31m-        except UsageError:[m
[31m-            if self.ctx is None or not self.ctx.resilient_parsing:[m
[31m-                raise[m
[31m-        return state.opts, state.largs, state.order[m
[31m-[m
[31m-    def _process_args_for_args(self, state: _ParsingState) -> None:[m
[31m-        pargs, args = _unpack_args([m
[31m-            state.largs + state.rargs, [x.nargs for x in self._args][m
[31m-        )[m
[31m-[m
[31m-        for idx, arg in enumerate(self._args):[m
[31m-            arg.process(pargs[idx], state)[m
[31m-[m
[31m-        state.largs = args[m
[31m-        state.rargs = [][m
[31m-[m
[31m-    def _process_args_for_options(self, state: _ParsingState) -> None:[m
[31m-        while state.rargs:[m
[31m-            arg = state.rargs.pop(0)[m
[31m-            arglen = len(arg)[m
[31m-            # Double dashes always handled explicitly regardless of what[m
[31m-            # prefixes are valid.[m
[31m-            if arg == "--":[m
[31m-                return[m
[31m-            elif arg[:1] in self._opt_prefixes and arglen > 1:[m
[31m-                self._process_opts(arg, state)[m
[31m-            elif self.allow_interspersed_args:[m
[31m-                state.largs.append(arg)[m
[31m-            else:[m
[31m-                state.rargs.insert(0, arg)[m
[31m-                return[m
[31m-[m
[31m-        # Say this is the original argument list:[m
[31m-        # [arg0, arg1, ..., arg(i-1), arg(i), arg(i+1), ..., arg(N-1)][m
[31m-        #                            ^[m
[31m-        # (we are about to process arg(i)).[m
[31m-        #[m
[31m-        # Then rargs is [arg(i), ..., arg(N-1)] and largs is a *subset* of[m
[31m-        # [arg0, ..., arg(i-1)] (any options and their arguments will have[m
[31m-        # been removed from largs).[m
[31m-        #[m
[31m-        # The while loop will usually consume 1 or more arguments per pass.[m
[31m-        # If it consumes 1 (eg. arg is an option that takes no arguments),[m
[31m-        # then after _process_arg() is done the situation is:[m
[31m-        #[m
[31m-        #   largs = subset of [arg0, ..., arg(i)][m
[31m-        #   rargs = [arg(i+1), ..., arg(N-1)][m
[31m-        #[m
[31m-        # If allow_interspersed_args is false, largs will always be[m
[31m-        # *empty* -- still a subset of [arg0, ..., arg(i-1)], but[m
[31m-        # not a very interesting subset![m
[31m-[m
[31m-    def _match_long_opt([m
[31m-        self, opt: str, explicit_value: str | None, state: _ParsingState[m
[31m-    ) -> None:[m
[31m-        if opt not in self._long_opt:[m
[31m-            from difflib import get_close_matches[m
[31m-[m
[31m-            possibilities = get_close_matches(opt, self._long_opt)[m
[31m-            raise NoSuchOption(opt, possibilities=possibilities, ctx=self.ctx)[m
[31m-[m
[31m-        option = self._long_opt[opt][m
[31m-        if option.takes_value:[m
[31m-            # At this point it's safe to modify rargs by injecting the[m
[31m-            # explicit value, because no exception is raised in this[m
[31m-            # branch.  This means that the inserted value will be fully[m
[31m-            # consumed.[m
[31m-            if explicit_value is not None:[m
[31m-                state.rargs.insert(0, explicit_value)[m
[31m-[m
[31m-            value = self._get_value_from_state(opt, option, state)[m
[31m-[m
[31m-        elif explicit_value is not None:[m
[31m-            raise BadOptionUsage([m
[31m-                opt, _("Option {name!r} does not take a value.").format(name=opt)[m
[31m-            )[m
[31m-[m
[31m-        else:[m
[31m-            value = None[m
[31m-[m
[31m-        option.process(value, state)[m
[31m-[m
[31m-    def _match_short_opt(self, arg: str, state: _ParsingState) -> None:[m
[31m-        stop = False[m
[31m-        i = 1[m
[31m-        prefix = arg[0][m
[31m-        unknown_options = [][m
[31m-[m
[31m-        for ch in arg[1:]:[m
[31m-            opt = _normalize_opt(f"{prefix}{ch}", self.ctx)[m
[31m-            option = self._short_opt.get(opt)[m
[31m-            i += 1[m
[31m-[m
[31m-            if not option:[m
[31m-                if self.ignore_unknown_options:[m
[31m-                    unknown_options.append(ch)[m
[31m-                    continue[m
[31m-                raise NoSuchOption(opt, ctx=self.ctx)[m
[31m-            if option.takes_value:[m
[31m-                # Any characters left in arg?  Pretend they're the[m
[31m-                # next arg, and stop consuming characters of arg.[m
[31m-                if i < len(arg):[m
[31m-                    state.rargs.insert(0, arg[i:])[m
[31m-                    stop = True[m
[31m-[m
[31m-                value = self._get_value_from_state(opt, option, state)[m
[31m-[m
[31m-            else:[m
[31m-                value = None[m
[31m-[m
[31m-            option.process(value, state)[m
[31m-[m
[31m-            if stop:[m
[31m-                break[m
[31m-[m
[31m-        # If we got any unknown options we recombine the string of the[m
[31m-        # remaining options and re-attach the prefix, then report that[m
[31m-        # to the state as new larg.  This way there is basic combinatorics[m
[31m-        # that can be achieved while still ignoring unknown arguments.[m
[31m-        if self.ignore_unknown_options and unknown_options:[m
[31m-            state.largs.append(f"{prefix}{''.join(unknown_options)}")[m
[31m-[m
[31m-    def _get_value_from_state([m
[31m-        self, option_name: str, option: _Option, state: _ParsingState[m
[31m-    ) -> t.Any:[m
[31m-        nargs = option.nargs[m
[31m-[m
[31m-        if len(state.rargs) < nargs:[m
[31m-            if option.obj._flag_needs_value:[m
[31m-                # Option allows omitting the value.[m
[31m-                value = _flag_needs_value[m
[31m-            else:[m
[31m-                raise BadOptionUsage([m
[31m-                    option_name,[m
[31m-                    ngettext([m
[31m-                        "Option {name!r} requires an argument.",[m
[31m-                        "Option {name!r} requires {nargs} arguments.",[m
[31m-                        nargs,[m
[31m-                    ).format(name=option_name, nargs=nargs),[m
[31m-                )[m
[31m-        elif nargs == 1:[m
[31m-            next_rarg = state.rargs[0][m
[31m-[m
[31m-            if ([m
[31m-                option.obj._flag_needs_value[m
[31m-                and isinstance(next_rarg, str)[m
[31m-                and next_rarg[:1] in self._opt_prefixes[m
[31m-                and len(next_rarg) > 1[m
[31m-            ):[m
[31m-                # The next arg looks like the start of an option, don't[m
[31m-                # use it as the value if omitting the value is allowed.[m
[31m-                value = _flag_needs_value[m
[31m-            else:[m
[31m-                value = state.rargs.pop(0)[m
[31m-        else:[m
[31m-            value = tuple(state.rargs[:nargs])[m
[31m-            del state.rargs[:nargs][m
[31m-[m
[31m-        return value[m
[31m-[m
[31m-    def _process_opts(self, arg: str, state: _ParsingState) -> None:[m
[31m-        explicit_value = None[m
[31m-        # Long option handling happens in two parts.  The first part is[m
[31m-        # supporting explicitly attached values.  In any case, we will try[m
[31m-        # to long match the option first.[m
[31m-        if "=" in arg:[m
[31m-            long_opt, explicit_value = arg.split("=", 1)[m
[31m-        else:[m
[31m-            long_opt = arg[m
[31m-        norm_long_opt = _normalize_opt(long_opt, self.ctx)[m
[31m-[m
[31m-        # At this point we will match the (assumed) long option through[m
[31m-        # the long option matching code.  Note that this allows options[m
[31m-        # like "-foo" to be matched as long options.[m
[31m-        try:[m
[31m-            self._match_long_opt(norm_long_opt, explicit_value, state)[m
[31m-        except NoSuchOption:[m
[31m-            # At this point the long option matching failed, and we need[m
[31m-            # to try with short options.  However there is a special rule[m
[31m-            # which says, that if we have a two character options prefix[m
[31m-            # (applies to "--foo" for instance), we do not dispatch to the[m
[31m-            # short option code and will instead raise the no option[m
[31m-            # error.[m
[31m-            if arg[:2] not in self._opt_prefixes:[m
[31m-                self._match_short_opt(arg, state)[m
[31m-                return[m
[31m-[m
[31m-            if not self.ignore_unknown_options:[m
[31m-                raise[m
[31m-[m
[31m-            state.largs.append(arg)[m
[31m-[m
[31m-[m
[31m-def __getattr__(name: str) -> object:[m
[31m-    import warnings[m
[31m-[m
[31m-    if name in {[m
[31m-        "OptionParser",[m
[31m-        "Argument",[m
[31m-        "Option",[m
[31m-        "split_opt",[m
[31m-        "normalize_opt",[m
[31m-        "ParsingState",[m
[31m-    }:[m
[31m-        warnings.warn([m
[31m-            f"'parser.{name}' is deprecated and will be removed in Click 9.0."[m
[31m-            " The old parser is available in 'optparse'.",[m
[31m-            DeprecationWarning,[m
[31m-            stacklevel=2,[m
[31m-        )[m
[31m-        return globals()[f"_{name}"][m
[31m-[m
[31m-    if name == "split_arg_string":[m
[31m-        from .shell_completion import split_arg_string[m
[31m-[m
[31m-        warnings.warn([m
[31m-            "Importing 'parser.split_arg_string' is deprecated, it will only be"[m
[31m-            " available in 'shell_completion' in Click 9.0.",[m
[31m-            DeprecationWarning,[m
[31m-            stacklevel=2,[m
[31m-        )[m
[31m-        return split_arg_string[m
[31m-[m
[31m-    raise AttributeError(name)[m
[1mdiff --git a/venv/Lib/site-packages/click/py.typed b/venv/Lib/site-packages/click/py.typed[m
[1mdeleted file mode 100644[m
[1mindex e69de29..0000000[m
[1mdiff --git a/venv/Lib/site-packages/click/shell_completion.py b/venv/Lib/site-packages/click/shell_completion.py[m
[1mdeleted file mode 100644[m
[1mindex cdb5822..0000000[m
[1m--- a/venv/Lib/site-packages/click/shell_completion.py[m
[1m+++ /dev/null[m
[36m@@ -1,644 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as cabc[m
[31m-import os[m
[31m-import re[m
[31m-import typing as t[m
[31m-from gettext import gettext as _[m
[31m-[m
[31m-from .core import Argument[m
[31m-from .core import Command[m
[31m-from .core import Context[m
[31m-from .core import Group[m
[31m-from .core import Option[m
[31m-from .core import Parameter[m
[31m-from .core import ParameterSource[m
[31m-from .utils import echo[m
[31m-[m
[31m-[m
[31m-def shell_complete([m
[31m-    cli: Command,[m
[31m-    ctx_args: cabc.MutableMapping[str, t.Any],[m
[31m-    prog_name: str,[m
[31m-    complete_var: str,[m
[31m-    instruction: str,[m
[31m-) -> int:[m
[31m-    """Perform shell completion for the given CLI program.[m
[31m-[m
[31m-    :param cli: Command being called.[m
[31m-    :param ctx_args: Extra arguments to pass to[m
[31m-        ``cli.make_context``.[m
[31m-    :param prog_name: Name of the executable in the shell.[m
[31m-    :param complete_var: Name of the environment variable that holds[m
[31m-        the completion instruction.[m
[31m-    :param instruction: Value of ``complete_var`` with the completion[m
[31m-        instruction and shell, in the form ``instruction_shell``.[m
[31m-    :return: Status code to exit with.[m
[31m-    """[m
[31m-    shell, _, instruction = instruction.partition("_")[m
[31m-    comp_cls = get_completion_class(shell)[m
[31m-[m
[31m-    if comp_cls is None:[m
[31m-        return 1[m
[31m-[m
[31m-    comp = comp_cls(cli, ctx_args, prog_name, complete_var)[m
[31m-[m
[31m-    if instruction == "source":[m
[31m-        echo(comp.source())[m
[31m-        return 0[m
[31m-[m
[31m-    if instruction == "complete":[m
[31m-        echo(comp.complete())[m
[31m-        return 0[m
[31m-[m
[31m-    return 1[m
[31m-[m
[31m-[m
[31m-class CompletionItem:[m
[31m-    """Represents a completion value and metadata about the value. The[m
[31m-    default metadata is ``type`` to indicate special shell handling,[m
[31m-    and ``help`` if a shell supports showing a help string next to the[m
[31m-    value.[m
[31m-[m
[31m-    Arbitrary parameters can be passed when creating the object, and[m
[31m-    accessed using ``item.attr``. If an attribute wasn't passed,[m
[31m-    accessing it returns ``None``.[m
[31m-[m
[31m-    :param value: The completion suggestion.[m
[31m-    :param type: Tells the shell script to provide special completion[m
[31m-        support for the type. Click uses ``"dir"`` and ``"file"``.[m
[31m-    :param help: String shown next to the value if supported.[m
[31m-    :param kwargs: Arbitrary metadata. The built-in implementations[m
[31m-        don't use this, but custom type completions paired with custom[m
[31m-        shell support could use it.[m
[31m-    """[m
[31m-[m
[31m-    __slots__ = ("value", "type", "help", "_info")[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        value: t.Any,[m
[31m-        type: str = "plain",[m
[31m-        help: str | None = None,[m
[31m-        **kwargs: t.Any,[m
[31m-    ) -> None:[m
[31m-        self.value: t.Any = value[m
[31m-        self.type: str = type[m
[31m-        self.help: str | None = help[m
[31m-        self._info = kwargs[m
[31m-[m
[31m-    def __getattr__(self, name: str) -> t.Any:[m
[31m-        return self._info.get(name)[m
[31m-[m
[31m-[m
[31m-# Only Bash >= 4.4 has the nosort option.[m
[31m-_SOURCE_BASH = """\[m
[31m-%(complete_func)s() {[m
[31m-    local IFS=$'\\n'[m
[31m-    local response[m
[31m-[m
[31m-    response=$(env COMP_WORDS="${COMP_WORDS[*]}" COMP_CWORD=$COMP_CWORD \[m
[31m-%(complete_var)s=bash_complete $1)[m
[31m-[m
[31m-    for completion in $response; do[m
[31m-        IFS=',' read type value <<< "$completion"[m
[31m-[m
[31m-        if [[ $type == 'dir' ]]; then[m
[31m-            COMPREPLY=()[m
[31m-            compopt -o dirnames[m
[31m-        elif [[ $type == 'file' ]]; then[m
[31m-            COMPREPLY=()[m
[31m-            compopt -o default[m
[31m-        elif [[ $type == 'plain' ]]; then[m
[31m-            COMPREPLY+=($value)[m
[31m-        fi[m
[31m-    done[m
[31m-[m
[31m-    return 0[m
[31m-}[m
[31m-[m
[31m-%(complete_func)s_setup() {[m
[31m-    complete -o nosort -F %(complete_func)s %(prog_name)s[m
[31m-}[m
[31m-[m
[31m-%(complete_func)s_setup;[m
[31m-"""[m
[31m-[m
[31m-_SOURCE_ZSH = """\[m
[31m-#compdef %(prog_name)s[m
[31m-[m
[31m-%(complete_func)s() {[m
[31m-    local -a completions[m
[31m-    local -a completions_with_descriptions[m
[31m-    local -a response[m
[31m-    (( ! $+commands[%(prog_name)s] )) && return 1[m
[31m-[m
[31m-    response=("${(@f)$(env COMP_WORDS="${words[*]}" COMP_CWORD=$((CURRENT-1)) \[m
[31m-%(complete_var)s=zsh_complete %(prog_name)s)}")[m
[31m-[m
[31m-    for type key descr in ${response}; do[m
[31m-        if [[ "$type" == "plain" ]]; then[m
[31m-            if [[ "$descr" == "_" ]]; then[m
[31m-                completions+=("$key")[m
[31m-            else[m
[31m-                completions_with_descriptions+=("$key":"$descr")[m
[31m-            fi[m
[31m-        elif [[ "$type" == "dir" ]]; then[m
[31m-            _path_files -/[m
[31m-        elif [[ "$type" == "file" ]]; then[m
[31m-            _path_files -f[m
[31m-        fi[m
[31m-    done[m
[31m-[m
[31m-    if [ -n "$completions_with_descriptions" ]; then[m
[31m-        _describe -V unsorted completions_with_descriptions -U[m
[31m-    fi[m
[31m-[m
[31m-    if [ -n "$completions" ]; then[m
[31m-        compadd -U -V unsorted -a completions[m
[31m-    fi[m
[31m-}[m
[31m-[m
[31m-if [[ $zsh_eval_context[-1] == loadautofunc ]]; then[m
[31m-    # autoload from fpath, call function directly[m
[31m-    %(complete_func)s "$@"[m
[31m-else[m
[31m-    # eval/source/. command, register function for later[m
[31m-    compdef %(complete_func)s %(prog_name)s[m
[31m-fi[m
[31m-"""[m
[31m-[m
[31m-_SOURCE_FISH = """\[m
[31m-function %(complete_func)s;[m
[31m-    set -l response (env %(complete_var)s=fish_complete COMP_WORDS=(commandline -cp) \[m
[31m-COMP_CWORD=(commandline -t) %(prog_name)s);[m
[31m-[m
[31m-    for completion in $response;[m
[31m-        set -l metadata (string split "," $completion);[m
[31m-[m
[31m-        if test $metadata[1] = "dir";[m
[31m-            __fish_complete_directories $metadata[2];[m
[31m-        else if test $metadata[1] = "file";[m
[31m-            __fish_complete_path $metadata[2];[m
[31m-        else if test $metadata[1] = "plain";[m
[31m-            echo $metadata[2];[m
[31m-        end;[m
[31m-    end;[m
[31m-end;[m
[31m-[m
[31m-complete --no-files --command %(prog_name)s --arguments \[m
[31m-"(%(complete_func)s)";[m
[31m-"""[m
[31m-[m
[31m-[m
[31m-class ShellComplete:[m
[31m-    """Base class for providing shell completion support. A subclass for[m
[31m-    a given shell will override attributes and methods to implement the[m
[31m-    completion instructions (``source`` and ``complete``).[m
[31m-[m
[31m-    :param cli: Command being called.[m
[31m-    :param prog_name: Name of the executable in the shell.[m
[31m-    :param complete_var: Name of the environment variable that holds[m
[31m-        the completion instruction.[m
[31m-[m
[31m-    .. versionadded:: 8.0[m
[31m-    """[m
[31m-[m
[31m-    name: t.ClassVar[str][m
[31m-    """Name to register the shell as with :func:`add_completion_class`.[m
[31m-    This is used in completion instructions (``{name}_source`` and[m
[31m-    ``{name}_complete``).[m
[31m-    """[m
[31m-[m
[31m-    source_template: t.ClassVar[str][m
[31m-    """Completion script template formatted by :meth:`source`. This must[m
[31m-    be provided by subclasses.[m
[31m-    """[m
[31m-[m
[31m-    def __init__([m
[31m-        self,[m
[31m-        cli: Command,[m
[31m-        ctx_args: cabc.MutableMapping[str, t.Any],[m
[31m-        prog_name: str,[m
[31m-        complete_var: str,[m
[31m-    ) -> None:[m
[31m-        self.cli = cli[m
[31m-        self.ctx_args = ctx_args[m
[31m-        self.prog_name = prog_name[m
[31m-        self.complete_var = complete_var[m
[31m-[m
[31m-    @property[m
[31m-    def func_name(self) -> str:[m
[31m-        """The name of the shell function defined by the completion[m
[31m-        script.[m
[31m-        """[m
[31m-        safe_name = re.sub(r"\W*", "", self.prog_name.replace("-", "_"), flags=re.ASCII)[m
[31m-        return f"_{safe_name}_completion"[m
[31m-[m
[31m-    def source_vars(self) -> dict[str, t.Any]:[m
[31m-        """Vars for formatting :attr:`source_template`.[m
[31m-[m
[31m-        By default this provides ``complete_func``, ``complete_var``,[m
[31m-        and ``prog_name``.[m
[31m-        """[m
[31m-        return {[m
[31m-            "complete_func": self.func_name,[m
[31m-            "complete_var": self.complete_var,[m
[31m-            "prog_name": self.prog_name,[m
[31m-        }[m
[31m-[m
[31m-    def source(self) -> str:[m
[31m-        """Produce the shell script that defines the completion[m
[31m-        function. By default this ``%``-style formats[m
[31m-        :attr:`source_template` with the dict returned by[m
[31m-        :meth:`source_vars`.[m
[31m-        """[m
[31m-        return self.source_template % self.source_vars()[m
[31m-[m
[31m-    def get_completion_args(self) -> tuple[list[str], str]:[m
[31m-        """Use the env vars defined by the shell script to return a[m
[31m-        tuple of ``args, incomplete``. This must be implemented by[m
[31m-        subclasses.[m
[31m-        """[m
[31m-        raise NotImplementedError[m
[31m-[m
[31m-    def get_completions(self, args: list[str], incomplete: str) -> list[CompletionItem]:[m
[31m-        """Determine the context and last complete command or parameter[m
[31m-        from the complete args. Call that object's ``shell_complete``[m
[31m-        method to get the completions for the incomplete value.[m
[31m-[m
[31m-        :param args: List of complete args before the incomplete value.[m
[31m-        :param incomplete: Value being completed. May be empty.[m
[31m-        """[m
[31m-        ctx = _resolve_context(self.cli, self.ctx_args, self.prog_name, args)[m
[31m-        obj, incomplete = _resolve_incomplete(ctx, args, incomplete)[m
[31m-        return obj.shell_complete(ctx, incomplete)[m
[31m-[m
[31m-    def format_completion(self, item: CompletionItem) -> str:[m
[31m-        """Format a completion item into the form recognized by the[m
[31m-        shell script. This must be implemented by subclasses.[m
[31m-[m
[31m-        :param item: Completion item to format.[m
[31m-        """[m
[31m-        raise NotImplementedError[m
[31m-[m
[31m-    def complete(self) -> str:[m
[31m-        """Produce the completion data to send back to the shell.[m
[31m-[m
[31m-        By default this calls :meth:`get_completion_args`, gets the[m
[31m-        completions, then calls :meth:`format_completion` for each[m
[31m-        completion.[m
[31m-        """[m
[31m-        args, incomplete = self.get_completion_args()[m
[31m-        completions = self.get_completions(args, incomplete)[m
[31m-        out = [self.format_completion(item) for item in completions][m
[31m-        return "\n".join(out)[m
[31m-[m
[31m-[m
[31m-class BashComplete(ShellComplete):[m
[31m-    """Shell completion for Bash."""[m
[31m-[m
[31m-    name = "bash"[m
[31m-    source_template = _SOURCE_BASH[m
[31m-[m
[31m-    @staticmethod[m
[31m-    def _check_version() -> None:[m
[31m-        import shutil[m
[31m-        import subprocess[m
[31m-[m
[31m-        bash_exe = shutil.which("bash")[m
[31m-[m
[31m-        if bash_exe is None:[m
[31m-            match = None[m
[31m-        else:[m
[31m-            output = subprocess.run([m
[31m-                [bash_exe, "--norc", "-c", 'echo "${BASH_VERSION}"'],[m
[31m-                stdout=subprocess.PIPE,[m
[31m-            )[m
[31m-            match = re.search(r"^(\d+)\.(\d+)\.\d+", output.stdout.decode())[m
[31m-[m
[31m-        if match is not None:[m
[31m-            major, minor = match.groups()[m
[31m-[m
[31m-            if major < "4" or major == "4" and minor < "4":[m
[31m-                echo([m
[31m-                    _([m
[31m-                        "Shell completion is not supported for Bash"[m
[31m-                        " versions older than 4.4."[m
[31m-                    ),[m
[31m-                    err=True,[m
[31m-                )[m
[31m-        else:[m
[31m-            echo([m
[31m-                _("Couldn't detect Bash version, shell completion is not supported."),[m
[31m-                err=True,[m
[31m-            )[m
[31m-[m
[31m-    def source(self) -> str:[m
[31m-        self._check_version()[m
[31m-        return super().source()[m
[31m-[m
[31m-    def get_completion_args(self) -> tuple[list[str], str]:[m
[31m-        cwords = split_arg_string(os.environ["COMP_WORDS"])[m
[31m-        cword = int(os.environ["COMP_CWORD"])[m
[31m-        args = cwords[1:cword][m
[31m-[m
[31m-        try:[m
[31m-            incomplete = cwords[cword][m
[31m-        except IndexError:[m
[31m-            incomplete = ""[m
[31m-[m
[31m-        return args, incomplete[m
[31m-[m
[31m-    def format_completion(self, item: CompletionItem) -> str:[m
[31m-        return f"{item.type},{item.value}"[m
[31m-[m
[31m-[m
[31m-class ZshComplete(ShellComplete):[m
[31m-    """Shell completion for Zsh."""[m
[31m-[m
[31m-    name = "zsh"[m
[31m-    source_template = _SOURCE_ZSH[m
[31m-[m
[31m-    def get_completion_args(self) -> tuple[list[str], str]:[m
[31m-        cwords = split_arg_string(os.environ["COMP_WORDS"])[m
[31m-        cword = int(os.environ["COMP_CWORD"])[m
[31m-        args = cwords[1:cword][m
[31m-[m
[31m-        try:[m
[31m-            incomplete = cwords[cword][m
[31m-        except IndexError:[m
[31m-            incomplete = ""[m
[31m-[m
[31m-        return args, incomplete[m
[31m-[m
[31m-    def format_completion(self, item: CompletionItem) -> str:[m
[31m-        return f"{item.type}\n{item.value}\n{item.help if item.help else '_'}"[m
[31m-[m
[31m-[m
[31m-class FishComplete(ShellComplete):[m
[31m-    """Shell completion for Fish."""[m
[31m-[m
[31m-    name = "fish"[m
[31m-    source_template = _SOURCE_FISH[m
[31m-[m
[31m-    def get_completion_args(self) -> tuple[list[str], str]:[m
[31m-        cwords = split_arg_string(os.environ["COMP_WORDS"])[m
[31m-        incomplete = os.environ["COMP_CWORD"][m
[31m-        args = cwords[1:][m
[31m-[m
[31m-        # Fish stores the partial word in both COMP_WORDS and[m
[31m-        # COMP_CWORD, remove it from complete args.[m
[31m-        if incomplete and args and args[-1] == incomplete:[m
[31m-            args.pop()[m
[31m-[m
[31m-        return args, incomplete[m
[31m-[m
[31m-    def format_completion(self, item: CompletionItem) -> str:[m
[31m-        if item.help:[m
[31m-            return f"{item.type},{item.value}\t{item.help}"[m
[31m-[m
[31m-        return f"{item.type},{item.value}"[m
[31m-[m
[31m-[m
[31m-ShellCompleteType = t.TypeVar("ShellCompleteType", bound="type[ShellComplete]")[m
[31m-[m
[31m-[m
[31m-_available_shells: dict[str, type[ShellComplete]] = {[m
[31m-    "bash": BashComplete,[m
[31m-    "fish": FishComplete,[m
[31m-    "zsh": ZshComplete,[m
[31m-}[m
[31m-[m
[31m-[m
[31m-def add_completion_class([m
[31m-    cls: ShellCompleteType, name: str | None = None[m
[31m-) -> ShellCompleteType:[m
[31m-    """Register a :class:`ShellComplete` subclass under the given name.[m
[31m-    The name will be provided by the completion instruction environment[m
[31m-    variable during completion.[m
[31m-[m
[31m-    :param cls: The completion class that will handle completion for the[m
[31m-        shell.[m
[31m-    :param name: Name to register the class under. Defaults to the[m
[31m-        class's ``name`` attribute.[m
[31m-    """[m
[31m-    if name is None:[m
[31m-        name = cls.name[m
[31m-[m
[31m-    _available_shells[name] = cls[m
[31m-[m
[31m-    return cls[m
[31m-[m
[31m-[m
[31m-def get_completion_class(shell: str) -> type[ShellComplete] | None:[m
[31m-    """Look up a registered :class:`ShellComplete` subclass by the name[m
[31m-    provided by the completion instruction environment variable. If the[m
[31m-    name isn't registered, returns ``None``.[m
[31m-[m
[31m-    :param shell: Name the class is registered under.[m
[31m-    """[m
[31m-    return _available_shells.get(shell)[m
[31m-[m
[31m-[m
[31m-def split_arg_string(string: str) -> list[str]:[m
[31m-    """Split an argument string as with :func:`shlex.split`, but don't[m
[31m-    fail if the string is incomplete. Ignores a missing closing quote or[m
[31m-    incomplete escape sequence and uses the partial token as-is.[m
[31m-[m
[31m-    .. code-block:: python[m
[31m-[m
[31m-        split_arg_string("example 'my file")[m
[31m-        ["example", "my file"][m
[31m-[m
[31m-        split_arg_string("example my\\")[m
[31m-        ["example", "my"][m
[31m-[m
[31m-    :param string: String to split.[m
[31m-[m
[31m-    .. versionchanged:: 8.2[m
[31m-        Moved to ``shell_completion`` from ``parser``.[m
[31m-    """[m
[31m-    import shlex[m
[31m-[m
[31m-    lex = shlex.shlex(string, posix=True)[m
[31m-    lex.whitespace_split = True[m
[31m-    lex.commenters = ""[m
[31m-    out = [][m
[31m-[m
[31m-    try:[m
[31m-        for token in lex:[m
[31m-            out.append(token)[m
[31m-    except ValueError:[m
[31m-        # Raised when end-of-string is reached in an invalid state. Use[m
[31m-        # the partial token as-is. The quote or escape character is in[m
[31m-        # lex.state, not lex.token.[m
[31m-        out.append(lex.token)[m
[31m-[m
[31m-    return out[m
[31m-[m
[31m-[m
[31m-def _is_incomplete_argument(ctx: Context, param: Parameter) -> bool:[m
[31m-    """Determine if the given parameter is an argument that can still[m
[31m-    accept values.[m
[31m-[m
[31m-    :param ctx: Invocation context for the command represented by the[m
[31m-        parsed complete args.[m
[31m-    :param param: Argument object being checked.[m
[31m-    """[m
[31m-    if not isinstance(param, Argument):[m
[31m-        return False[m
[31m-[m
[31m-    assert param.name is not None[m
[31m-    # Will be None if expose_value is False.[m
[31m-    value = ctx.params.get(param.name)[m
[31m-    return ([m
[31m-        param.nargs == -1[m
[31m-        or ctx.get_parameter_source(param.name) is not ParameterSource.COMMANDLINE[m
[31m-        or ([m
[31m-            param.nargs > 1[m
[31m-            and isinstance(value, (tuple, list))[m
[31m-            and len(value) < param.nargs[m
[31m-        )[m
[31m-    )[m
[31m-[m
[31m-[m
[31m-def _start_of_option(ctx: Context, value: str) -> bool:[m
[31m-    """Check if the value looks like the start of an option."""[m
[31m-    if not value:[m
[31m-        return False[m
[31m-[m
[31m-    c = value[0][m
[31m-    return c in ctx._opt_prefixes[m
[31m-[m
[31m-[m
[31m-def _is_incomplete_option(ctx: Context, args: list[str], param: Parameter) -> bool:[m
[31m-    """Determine if the given parameter is an option that needs a value.[m
[31m-[m
[31m-    :param args: List of complete args before the incomplete value.[m
[31m-    :param param: Option object being checked.[m
[31m-    """[m
[31m-    if not isinstance(param, Option):[m
[31m-        return False[m
[31m-[m
[31m-    if param.is_flag or param.count:[m
[31m-        return False[m
[31m-[m
[31m-    last_option = None[m
[31m-[m
[31m-    for index, arg in enumerate(reversed(args)):[m
[31m-        if index + 1 > param.nargs:[m
[31m-            break[m
[31m-[m
[31m-        if _start_of_option(ctx, arg):[m
[31m-            last_option = arg[m
[31m-[m
[31m-    return last_option is not None and last_option in param.opts[m
[31m-[m
[31m-[m
[31m-def _resolve_context([m
[31m-    cli: Command,[m
[31m-    ctx_args: cabc.MutableMapping[str, t.Any],[m
[31m-    prog_name: str,[m
[31m-    args: list[str],[m
[31m-) -> Context:[m
[31m-    """Produce the context hierarchy starting with the command and[m
[31m-    traversing the complete arguments. This only follows the commands,[m
[31m-    it doesn't trigger input prompts or callbacks.[m
[31m-[m
[31m-    :param cli: Command being called.[m
[31m-    :param prog_name: Name of the executable in the shell.[m
[31m-    :param args: List of complete args before the incomplete value.[m
[31m-    """[m
[31m-    ctx_args["resilient_parsing"] = True[m
[31m-    with cli.make_context(prog_name, args.copy(), **ctx_args) as ctx:[m
[31m-        args = ctx._protected_args + ctx.args[m
[31m-[m
[31m-        while args:[m
[31m-            command = ctx.command[m
[31m-[m
[31m-            if isinstance(command, Group):[m
[31m-                if not command.chain:[m
[31m-                    name, cmd, args = command.resolve_command(ctx, args)[m
[31m-[m
[31m-                    if cmd is None:[m
[31m-                        return ctx[m
[31m-[m
[31m-                    with cmd.make_context([m
[31m-                        name, args, parent=ctx, resilient_parsing=True[m
[31m-                    ) as sub_ctx:[m
[31m-                        args = ctx._protected_args + ctx.args[m
[31m-                        ctx = sub_ctx[m
[31m-                else:[m
[31m-                    sub_ctx = ctx[m
[31m-[m
[31m-                    while args:[m
[31m-                        name, cmd, args = command.resolve_command(ctx, args)[m
[31m-[m
[31m-                        if cmd is None:[m
[31m-                            return ctx[m
[31m-[m
[31m-                        with cmd.make_context([m
[31m-                            name,[m
[31m-                            args,[m
[31m-                            parent=ctx,[m
[31m-                            allow_extra_args=True,[m
[31m-                            allow_interspersed_args=False,[m
[31m-                            resilient_parsing=True,[m
[31m-                        ) as sub_sub_ctx:[m
[31m-                            args = sub_ctx.args[m
[31m-                            sub_ctx = sub_sub_ctx[m
[31m-[m
[31m-                    ctx = sub_ctx[m
[31m-                    args = [*sub_ctx._protected_args, *sub_ctx.args][m
[31m-            else:[m
[31m-                break[m
[31m-[m
[31m-    return ctx[m
[31m-[m
[31m-[m
[31m-def _resolve_incomplete([m
[31m-    ctx: Context, args: list[str], incomplete: str[m
[31m-) -> tuple[Command | Parameter, str]:[m
[31m-    """Find the Click object that will handle the completion of the[m
[31m-    incomplete value. Return the object and the incomplete value.[m
[31m-[m
[31m-    :param ctx: Invocation context for the command represented by[m
[31m-        the parsed complete args.[m
[31m-    :param args: List of complete args before the incomplete value.[m
[31m-    :param incomplete: Value being completed. May be empty.[m
[31m-    """[m
[31m-    # Different shells treat an "=" between a long option name and[m
[31m-    # value differently. Might keep the value joined, return the "="[m
[31m-    # as a separate item, or return the split name and value. Always[m
[31m-    # split and discard the "=" to make completion easier.[m
[31m-    if incomplete == "=":[m
[31m-        incomplete = ""[m
[31m-    elif "=" in incomplete and _start_of_option(ctx, incomplete):[m
[31m-        name, _, incomplete = incomplete.partition("=")[m
[31m-        args.append(name)[m
[31m-[m
[31m-    # The "--" marker tells Click to stop treating values as options[m
[31m-    # even if they start with the option character. If it hasn't been[m
[31m-    # given and the incomplete arg looks like an option, the current[m
[31m-    # command will provide option name completions.[m
[31m-    if "--" not in args and _start_of_option(ctx, incomplete):[m
[31m-        return ctx.command, incomplete[m
[31m-[m
[31m-    params = ctx.command.get_params(ctx)[m
[31m-[m
[31m-    # If the last complete arg is an option name with an incomplete[m
[31m-    # value, the option will provide value completions.[m
[31m-    for param in params:[m
[31m-        if _is_incomplete_option(ctx, args, param):[m
[31m-            return param, incomplete[m
[31m-[m
[31m-    # It's not an option name or value. The first argument without a[m
[31m-    # parsed value will provide value completions.[m
[31m-    for param in params:[m
[31m-        if _is_incomplete_argument(ctx, param):[m
[31m-            return param, incomplete[m
[31m-[m
[31m-    # There were no unparsed arguments, the command may be a group that[m
[31m-    # will provide command name completions.[m
[31m-    return ctx.command, incomplete[m
[1mdiff --git a/venv/Lib/site-packages/click/termui.py b/venv/Lib/site-packages/click/termui.py[m
[1mdeleted file mode 100644[m
[1mindex dcbb222..0000000[m
[1m--- a/venv/Lib/site-packages/click/termui.py[m
[1m+++ /dev/null[m
[36m@@ -1,877 +0,0 @@[m
[31m-from __future__ import annotations[m
[31m-[m
[31m-import collections.abc as cabc[m
[31m-import inspect[m
[31m-import io[m
[31m-import itertools[m
[31m-import sys[m
[31m-import t